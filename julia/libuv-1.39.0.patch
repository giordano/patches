diff --git a/CMakeLists.txt b/CMakeLists.txt
index e9bf77f7..b94bdf1c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -99,6 +99,7 @@ set(uv_sources
     src/fs-poll.c
     src/idna.c
     src/inet.c
+    src/loop-watcher.c
     src/random.c
     src/strscpy.c
     src/threadpool.c
@@ -111,6 +112,7 @@ if(WIN32)
   list(APPEND uv_defines WIN32_LEAN_AND_MEAN _WIN32_WINNT=0x0600)
   list(APPEND uv_libraries
        psapi
+       secur32
        user32
        advapi32
        iphlpapi
@@ -127,14 +129,12 @@ if(WIN32)
        src/win/getaddrinfo.c
        src/win/getnameinfo.c
        src/win/handle.c
-       src/win/loop-watcher.c
        src/win/pipe.c
        src/win/thread.c
        src/win/poll.c
        src/win/process.c
        src/win/process-stdio.c
        src/win/signal.c
-       src/win/snprintf.c
        src/win/stream.c
        src/win/tcp.c
        src/win/tty.c
@@ -143,7 +143,7 @@ if(WIN32)
        src/win/winapi.c
        src/win/winsock.c)
   list(APPEND uv_test_libraries ws2_32)
-  list(APPEND uv_test_sources src/win/snprintf.c test/runner-win.c)
+  list(APPEND uv_test_sources test/runner-win.c)
 else()
   list(APPEND uv_defines _FILE_OFFSET_BITS=64 _LARGEFILE_SOURCE)
   if(NOT CMAKE_SYSTEM_NAME MATCHES "Android|OS390")
@@ -159,7 +159,6 @@ else()
        src/unix/fs.c
        src/unix/getaddrinfo.c
        src/unix/getnameinfo.c
-       src/unix/loop-watcher.c
        src/unix/loop.c
        src/unix/pipe.c
        src/unix/poll.c
@@ -367,9 +366,11 @@ if(LIBUV_BUILD_TESTS)
        test/run-tests.c
        test/runner.c
        test/test-active.c
+       test/test-async-multi.c
        test/test-async-null-cb.c
        test/test-async.c
        test/test-barrier.c
+       test/test-buf.c
        test/test-callback-order.c
        test/test-callback-stack.c
        test/test-close-fd.c
@@ -387,14 +388,13 @@ if(LIBUV_BUILD_TESTS)
        test/test-env-vars.c
        test/test-error.c
        test/test-fail-always.c
-       test/test-fork.c
        test/test-fs-copyfile.c
        test/test-fs-event.c
-       test/test-fs-poll.c
-       test/test-fs.c
-       test/test-fs-readdir.c
        test/test-fs-fd-hash.c
        test/test-fs-open-flags.c
+       test/test-fs-poll.c
+       test/test-fs-readdir.c
+       test/test-fs.c
        test/test-get-currentexe.c
        test/test-get-loadavg.c
        test/test-get-memory.c
@@ -467,9 +467,9 @@ if(LIBUV_BUILD_TESTS)
        test/test-tcp-bind-error.c
        test/test-tcp-bind6-error.c
        test/test-tcp-close-accept.c
+       test/test-tcp-close-reset.c
        test/test-tcp-close-while-connecting.c
        test/test-tcp-close.c
-       test/test-tcp-close-reset.c
        test/test-tcp-connect-error-after-write.c
        test/test-tcp-connect-error.c
        test/test-tcp-connect-timeout.c
@@ -481,8 +481,8 @@ if(LIBUV_BUILD_TESTS)
        test/test-tcp-read-stop.c
        test/test-tcp-read-stop-start.c
        test/test-tcp-shutdown-after-write.c
-       test/test-tcp-try-write.c
        test/test-tcp-try-write-error.c
+       test/test-tcp-try-write.c
        test/test-tcp-unexpected-read.c
        test/test-tcp-write-after-connect.c
        test/test-tcp-write-fail.c
@@ -490,6 +490,7 @@ if(LIBUV_BUILD_TESTS)
        test/test-tcp-write-to-half-open-connection.c
        test/test-tcp-writealot.c
        test/test-test-macros.c
+       test/test-thread-affinity.c
        test/test-thread-equal.c
        test/test-thread.c
        test/test-threadpool-cancel.c
@@ -518,8 +519,8 @@ if(LIBUV_BUILD_TESTS)
        test/test-udp-send-and-recv.c
        test/test-udp-send-hang-loop.c
        test/test-udp-send-immediate.c
-       test/test-udp-sendmmsg-error.c
        test/test-udp-send-unreachable.c
+       test/test-udp-sendmmsg-error.c
        test/test-udp-try-send.c
        test/test-uname.c
        test/test-walk-handles.c
diff --git a/Makefile.am b/Makefile.am
index 46308eaa..47ef691a 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -28,12 +28,13 @@ CLEANFILES =
 
 lib_LTLIBRARIES = libuv.la
 libuv_la_CFLAGS = @CFLAGS@
-libuv_la_LDFLAGS = -no-undefined -version-info 1:0:0
+libuv_la_LDFLAGS = -no-undefined -version-info 2:0:0
 libuv_la_SOURCES = src/fs-poll.c \
                    src/heap-inl.h \
                    src/idna.c \
                    src/idna.h \
                    src/inet.c \
+                   src/loop-watcher.c \
                    src/queue.h \
                    src/random.c \
                    src/strscpy.c \
@@ -58,7 +59,6 @@ AM_CPPFLAGS += -I$(top_srcdir)/src/win \
                -DWIN32_LEAN_AND_MEAN \
                -D_WIN32_WINNT=0x0600
 libuv_la_SOURCES += src/win/async.c \
-                    src/win/atomicops-inl.h \
                     src/win/core.c \
                     src/win/detect-wakeup.c \
                     src/win/dl.c \
@@ -70,7 +70,6 @@ libuv_la_SOURCES += src/win/async.c \
                     src/win/handle.c \
                     src/win/handle-inl.h \
                     src/win/internal.h \
-                    src/win/loop-watcher.c \
                     src/win/pipe.c \
                     src/win/poll.c \
                     src/win/process-stdio.c \
@@ -101,7 +100,6 @@ libuv_la_SOURCES += src/unix/async.c \
                    src/unix/getaddrinfo.c \
                    src/unix/getnameinfo.c \
                    src/unix/internal.h \
-                   src/unix/loop-watcher.c \
                    src/unix/loop.c \
                    src/unix/pipe.c \
                    src/unix/poll.c \
@@ -149,8 +147,10 @@ test_run_tests_SOURCES = test/blackhole-server.c \
                          test/task.h \
                          test/test-active.c \
                          test/test-async.c \
+                         test/test-async-multi.c \
                          test/test-async-null-cb.c \
                          test/test-barrier.c \
+                         test/test-buf.c \
                          test/test-callback-order.c \
                          test/test-callback-stack.c \
                          test/test-close-fd.c \
@@ -175,7 +175,6 @@ test_run_tests_SOURCES = test/blackhole-server.c \
                          test/test-fs-readdir.c \
                          test/test-fs-fd-hash.c \
                          test/test-fs-open-flags.c \
-                         test/test-fork.c \
                          test/test-getters-setters.c \
                          test/test-get-currentexe.c \
                          test/test-get-loadavg.c \
@@ -274,6 +273,7 @@ test_run_tests_SOURCES = test/blackhole-server.c \
                          test/test-test-macros.c \
                          test/test-thread-equal.c \
                          test/test-thread.c \
+                         test/test-thread-affinity.c \
                          test/test-threadpool-cancel.c \
                          test/test-threadpool.c \
                          test/test-timer-again.c \
@@ -338,7 +338,7 @@ endif
 
 if SUNOS
 test_run_tests_CFLAGS += -D__EXTENSIONS__ \
-                         -D_XOPEN_SOURCE=500 \
+                         -D_XOPEN_SOURCE=600 \
                          -D_REENTRANT
 endif
 
@@ -513,7 +513,7 @@ endif
 if SUNOS
 uvinclude_HEADERS += include/uv/sunos.h
 libuv_la_CFLAGS += -D__EXTENSIONS__ \
-                   -D_XOPEN_SOURCE=500 \
+                   -D_XOPEN_SOURCE=600 \
                    -D_REENTRANT
 libuv_la_SOURCES += src/unix/no-proctitle.c \
                     src/unix/sunos.c
diff --git a/SUPPORTED_PLATFORMS.md b/SUPPORTED_PLATFORMS.md
index 72e054eb..88569437 100644
--- a/SUPPORTED_PLATFORMS.md
+++ b/SUPPORTED_PLATFORMS.md
@@ -3,8 +3,8 @@
 |  System | Support type | Supported versions | Notes |
 |---|---|---|---|
 | GNU/Linux | Tier 1 | Linux >= 2.6.32 with glibc >= 2.12 | |
-| macOS | Tier 1 | macOS >= 10.7 | |
-| Windows | Tier 1 | >= Windows 7 | MSVC 2008 and later are supported |
+| macOS | Tier 1 | macOS >= 10.9 | |
+| Windows | Tier 1 | Windows >= 7 | MSVC 2015 and later are supported |
 | FreeBSD | Tier 1 | >= 10 | |
 | AIX | Tier 2 | >= 6 | Maintainers: @libuv/aix |
 | z/OS | Tier 2 | >= V2R2 | Maintainers: @libuv/zos |
diff --git a/configure.ac b/configure.ac
index 8f5c89b1..f311e97b 100644
--- a/configure.ac
+++ b/configure.ac
@@ -13,7 +13,7 @@
 # OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
 AC_PREREQ(2.57)
-AC_INIT([libuv], [1.39.0], [https://github.com/libuv/libuv/issues])
+AC_INIT([libuv], [2.0.0], [https://github.com/libuv/libuv/issues])
 AC_CONFIG_MACRO_DIR([m4])
 m4_include([m4/libuv-extra-automake-flags.m4])
 m4_include([m4/as_case.m4])
@@ -26,7 +26,7 @@ AC_PROG_CC
 AM_PROG_CC_C_O
 CC_FLAG_VISIBILITY #[-fvisibility=hidden]
 CC_CHECK_CFLAGS_APPEND([-g])
-CC_CHECK_CFLAGS_APPEND([-std=gnu89])
+CC_CHECK_CFLAGS_APPEND([-std=gnu99])
 CC_CHECK_CFLAGS_APPEND([-Wall])
 CC_CHECK_CFLAGS_APPEND([-Wextra])
 CC_CHECK_CFLAGS_APPEND([-Wno-long-long])
@@ -67,7 +67,7 @@ AM_CONDITIONAL([OS400],    [AS_CASE([$host_os],[os400],         [true], [false])
 AM_CONDITIONAL([SUNOS],    [AS_CASE([$host_os],[solaris*],      [true], [false])])
 AM_CONDITIONAL([WINNT],    [AS_CASE([$host_os],[mingw*],        [true], [false])])
 AS_CASE([$host_os],[mingw*], [
-    LIBS="$LIBS -lws2_32 -lpsapi -liphlpapi -lshell32 -luserenv -luser32"
+    LIBS="$LIBS -lws2_32 -lpsapi -liphlpapi -lshell32 -lsecur32 -luserenv -luser32"
 ])
 AS_CASE([$host_os], [netbsd*], [AC_CHECK_LIB([kvm], [kvm_open])])
 AS_CASE([$host_os], [kfreebsd*], [
diff --git a/docs/src/dns.rst b/docs/src/dns.rst
index 1d881580..8920af78 100644
--- a/docs/src/dns.rst
+++ b/docs/src/dns.rst
@@ -34,11 +34,6 @@ Data types
 Public members
 ^^^^^^^^^^^^^^
 
-.. c:member:: uv_loop_t* uv_getaddrinfo_t.loop
-
-    Loop that started this getaddrinfo request and where completion will be
-    reported. Readonly.
-
 .. c:member:: struct addrinfo* uv_getaddrinfo_t.addrinfo
 
     Pointer to a `struct addrinfo` containing the result. Must be freed by the user
diff --git a/docs/src/fs.rst b/docs/src/fs.rst
index 0bf2abed..8d437827 100644
--- a/docs/src/fs.rst
+++ b/docs/src/fs.rst
@@ -94,9 +94,9 @@ Data types
             UV_FS_READLINK,
             UV_FS_CHOWN,
             UV_FS_FCHOWN,
+            UV_FS_LCHOWN,
             UV_FS_REALPATH,
             UV_FS_COPYFILE,
-            UV_FS_LCHOWN,
             UV_FS_OPENDIR,
             UV_FS_READDIR,
             UV_FS_CLOSEDIR,
@@ -164,11 +164,6 @@ Data types
 Public members
 ^^^^^^^^^^^^^^
 
-.. c:member:: uv_loop_t* uv_fs_t.loop
-
-    Loop that started this request and where completion will be reported.
-    Readonly.
-
 .. c:member:: uv_fs_type uv_fs_t.fs_type
 
     FS request type.
@@ -203,10 +198,12 @@ API
     Cleanup request. Must be called after a request is finished to deallocate
     any memory libuv might have allocated.
 
-.. c:function:: int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb)
+.. c:function:: int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t file, uv_fs_cb cb)
 
     Equivalent to :man:`close(2)`.
 
+    .. versionchanged:: 2.0.0 replace uv_file with uv_os_fd_t
+
 .. c:function:: int uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags, int mode, uv_fs_cb cb)
 
     Equivalent to :man:`open(2)`.
@@ -216,7 +213,7 @@ API
         in binary mode. Because of this the O_BINARY and O_TEXT flags are not
         supported.
 
-.. c:function:: int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file file, const uv_buf_t bufs[], unsigned int nbufs, int64_t offset, uv_fs_cb cb)
+.. c:function:: int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t file, const uv_buf_t bufs[], unsigned int nbufs, int64_t offset, uv_fs_cb cb)
 
     Equivalent to :man:`preadv(2)`.
 
@@ -225,11 +222,13 @@ API
         to build libuv), files opened using ``UV_FS_O_FILEMAP`` may cause a fatal
         crash if the memory mapped read operation fails.
 
+    .. versionchanged:: 2.0.0 replace uv_file with uv_os_fd_t
+
 .. c:function:: int uv_fs_unlink(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb)
 
     Equivalent to :man:`unlink(2)`.
 
-.. c:function:: int uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file file, const uv_buf_t bufs[], unsigned int nbufs, int64_t offset, uv_fs_cb cb)
+.. c:function:: int uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t file, const uv_buf_t bufs[], unsigned int nbufs, int64_t offset, uv_fs_cb cb)
 
     Equivalent to :man:`pwritev(2)`.
 
@@ -238,6 +237,8 @@ API
         to build libuv), files opened using ``UV_FS_O_FILEMAP`` may cause a fatal
         crash if the memory mapped write operation fails.
 
+    .. versionchanged:: 2.0.0 replace uv_file with uv_os_fd_t
+
 .. c:function:: int uv_fs_mkdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode, uv_fs_cb cb)
 
     Equivalent to :man:`mkdir(2)`.
@@ -320,11 +321,13 @@ API
         ext3 and ext4 at the time of this writing), check the :man:`getdents(2)` man page.
 
 .. c:function:: int uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb)
-.. c:function:: int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb)
+.. c:function:: int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t file, uv_fs_cb cb)
 .. c:function:: int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb)
 
     Equivalent to :man:`stat(2)`, :man:`fstat(2)` and :man:`lstat(2)` respectively.
 
+    .. versionchanged:: 2.0.0 replace uv_file with uv_os_fd_t
+
 .. c:function:: int uv_fs_statfs(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb)
 
     Equivalent to :man:`statfs(2)`. On success, a `uv_statfs_t` is allocated
@@ -340,7 +343,7 @@ API
 
     Equivalent to :man:`rename(2)`.
 
-.. c:function:: int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb)
+.. c:function:: int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t file, uv_fs_cb cb)
 
     Equivalent to :man:`fsync(2)`.
 
@@ -348,14 +351,20 @@ API
         For AIX, `uv_fs_fsync` returns `UV_EBADF` on file descriptors referencing
         non regular files.
 
-.. c:function:: int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb)
+    .. versionchanged:: 2.0.0 replace uv_file with uv_os_fd_t
+
+.. c:function:: int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t file, uv_fs_cb cb)
 
     Equivalent to :man:`fdatasync(2)`.
 
-.. c:function:: int uv_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req, uv_file file, int64_t offset, uv_fs_cb cb)
+    .. versionchanged:: 2.0.0 replace uv_file with uv_os_fd_t
+
+.. c:function:: int uv_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t file, int64_t offset, uv_fs_cb cb)
 
     Equivalent to :man:`ftruncate(2)`.
 
+    .. versionchanged:: 2.0.0 replace uv_file with uv_os_fd_t
+
 .. c:function:: int uv_fs_copyfile(uv_loop_t* loop, uv_fs_t* req, const char* path, const char* new_path, int flags, uv_fs_cb cb)
 
     Copies a file from `path` to `new_path`. Supported `flags` are described below.
@@ -388,21 +397,25 @@ API
         `UV_FS_COPYFILE_FICLONE_FORCE`, that error is returned. Previously,
         all errors were mapped to `UV_ENOTSUP`.
 
-.. c:function:: int uv_fs_sendfile(uv_loop_t* loop, uv_fs_t* req, uv_file out_fd, uv_file in_fd, int64_t in_offset, size_t length, uv_fs_cb cb)
+.. c:function:: int uv_fs_sendfile(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t out_fd, uv_os_fd_t in_fd, int64_t in_offset, size_t length, uv_fs_cb cb)
 
     Limited equivalent to :man:`sendfile(2)`.
 
+    .. versionchanged:: 2.0.0 replace uv_file with uv_os_fd_t
+
 .. c:function:: int uv_fs_access(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode, uv_fs_cb cb)
 
     Equivalent to :man:`access(2)` on Unix. Windows uses ``GetFileAttributesW()``.
 
 .. c:function:: int uv_fs_chmod(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode, uv_fs_cb cb)
-.. c:function:: int uv_fs_fchmod(uv_loop_t* loop, uv_fs_t* req, uv_file file, int mode, uv_fs_cb cb)
+.. c:function:: int uv_fs_fchmod(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t file, int mode, uv_fs_cb cb)
 
     Equivalent to :man:`chmod(2)` and :man:`fchmod(2)` respectively.
 
+    .. versionchanged:: 2.0.0 replace uv_file with uv_os_fd_t
+
 .. c:function:: int uv_fs_utime(uv_loop_t* loop, uv_fs_t* req, const char* path, double atime, double mtime, uv_fs_cb cb)
-.. c:function:: int uv_fs_futime(uv_loop_t* loop, uv_fs_t* req, uv_file file, double atime, double mtime, uv_fs_cb cb)
+.. c:function:: int uv_fs_futime(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t file, double atime, double mtime, uv_fs_cb cb)
 .. c:function:: int uv_fs_lutime(uv_loop_t* loop, uv_fs_t* req, const char* path, double atime, double mtime, uv_fs_cb cb)
 
     Equivalent to :man:`utime(2)`, :man:`futimes(3)` and :man:`lutimes(3)` respectively.
@@ -415,7 +428,17 @@ API
       AIX: `uv_fs_futime()` and `uv_fs_lutime()` functions only work for AIX 7.1 and newer.
       They can still be called on older versions but will return ``UV_ENOSYS``.
 
-    .. versionchanged:: 1.10.0 sub-second precission is supported on Windows
+    .. versionchanged:: 1.10.0 sub-second precision is supported on Windows
+    .. versionchanged:: 2.0.0 replace uv_file with uv_os_fd_t
+
+.. c:function:: int uv_fs_utime_ex(uv_loop_t* loop, uv_fs_t* req, const char* path, double btime, double atime, double mtime, uv_fs_cb cb)
+.. c:function:: int uv_fs_futime_ex(uv_loop_t* loop, uv_fs_t* req, uv_file file, double btime, double atime, double mtime, uv_fs_cb cb)
+
+    Equivalent to :c:func:`uv_fs_utime` and :c:func:`uv_fs_futime` except on
+    macOS and Windows, in which case these variants also allow the
+    birth/creation time to be set.
+
+    .. versionadded:: 2.0.0
 
 .. c:function:: int uv_fs_link(uv_loop_t* loop, uv_fs_t* req, const char* path, const char* new_path, uv_fs_cb cb)
 
@@ -463,14 +486,10 @@ API
         The background story and some more details on these issues can be checked
         `here <https://github.com/nodejs/node/issues/7726>`_.
 
-    .. note::
-      This function is not implemented on Windows XP and Windows Server 2003.
-      On these systems, UV_ENOSYS is returned.
-
     .. versionadded:: 1.8.0
 
 .. c:function:: int uv_fs_chown(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb)
-.. c:function:: int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb)
+.. c:function:: int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t file, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb)
 .. c:function:: int uv_fs_lchown(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb)
 
     Equivalent to :man:`chown(2)`, :man:`fchown(2)` and :man:`lchown(2)` respectively.
@@ -480,6 +499,8 @@ API
 
     .. versionchanged:: 1.21.0 implemented uv_fs_lchown
 
+    .. versionchanged:: 2.0.0 replace uv_file with uv_os_fd_t
+
 .. c:function:: uv_fs_type uv_fs_get_type(const uv_fs_t* req)
 
     Returns `req->fs_type`.
@@ -522,6 +543,19 @@ API
 Helper functions
 ----------------
 
+.. c:function:: uv_os_fd_t uv_convert_fd_to_handle(int fd)
+
+   Destructively converts a file descriptor in the C runtime
+   to the OS-dependent handle.
+   Upon return, the input ``fd`` parameter is invalid and closed.
+
+   This is only useful on Windows, where it calls DuplicateHandle
+   to make a new HANDLE independent from the MSVCRT library,
+   and then closes the handle out of the C runtime to avoid leaks
+   and to avoid having multiple handles open for the same underlying resource.
+
+    .. versionadded:: 2.0.0 replace uv_file with uv_os_fd_t
+
 .. c:function:: uv_os_fd_t uv_get_osfhandle(int fd)
 
    For a file descriptor in the C runtime, get the OS-dependent handle.
@@ -531,14 +565,7 @@ Helper functions
 
     .. versionadded:: 1.12.0
 
-.. c:function:: int uv_open_osfhandle(uv_os_fd_t os_fd)
-
-   For a OS-dependent handle, get the file descriptor in the C runtime.
-   On UNIX, returns the ``os_fd`` intact. On Windows, this calls `_open_osfhandle <https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/open-osfhandle?view=vs-2019>`_.
-   Note that this consumes the argument, any attempts to close it or to use it
-   after closing the return value may lead to malfunction.
-
-    .. versionadded:: 1.23.0
+    .. versionadded:: 2.0.0 replace uv_file with uv_os_fd_t and remove ``uv_open_osfhandle``
 
 File open constants
 -------------------
diff --git a/docs/src/guide/filesystem.rst b/docs/src/guide/filesystem.rst
index e89d4cd5..8cf3d1aa 100644
--- a/docs/src/guide/filesystem.rst
+++ b/docs/src/guide/filesystem.rst
@@ -40,7 +40,7 @@ File descriptors are closed using
 
 .. code-block:: c
 
-    int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb)
+    int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t fd, uv_fs_cb cb)
 
 
 Filesystem operation callbacks have the signature:
diff --git a/docs/src/guide/utilities.rst b/docs/src/guide/utilities.rst
index a863c5ea..20a97de4 100644
--- a/docs/src/guide/utilities.rst
+++ b/docs/src/guide/utilities.rst
@@ -51,8 +51,8 @@ The utility function::
 
 applies **only to repeating timers** and is equivalent to stopping the timer
 and then starting it with both initial ``timeout`` and ``repeat`` set to the
-old ``repeat`` value. If the timer hasn't been started it fails (error code
-``UV_EINVAL``) and returns -1.
+old ``repeat`` value. If the timer hasn't been started, or isn't a repeating
+timer, it fails with ``UV_EINVAL``.
 
 An actual timer example is in the :ref:`reference count section
 <reference-count>`.
@@ -370,7 +370,7 @@ terminal information.
 The first thing to do is to initialize a ``uv_tty_t`` with the file descriptor
 it reads/writes from. This is achieved with::
 
-    int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd, int unused)
+    int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_os_fd_t fd, int unused)
 
 The ``unused`` parameter is now auto-detected and ignored. It previously needed
 to be set to use ``uv_read_start()`` on the stream.
diff --git a/docs/src/loop.rst b/docs/src/loop.rst
index f9ebb9d4..51d08cf0 100644
--- a/docs/src/loop.rst
+++ b/docs/src/loop.rst
@@ -131,10 +131,10 @@ API
     Returns the size of the `uv_loop_t` structure. Useful for FFI binding
     writers who don't want to know the structure layout.
 
-.. c:function:: int uv_backend_fd(const uv_loop_t* loop)
+.. c:function:: uv_os_fd_t uv_backend_fd(const uv_loop_t* loop)
 
-    Get backend file descriptor. Only kqueue, epoll and event ports are
-    supported.
+    Get backend file descriptor. Returns the epoll / kqueue / event ports file
+    descriptor on Unix and the IOCP `HANDLE` on Windows.
 
     This can be used in conjunction with `uv_run(loop, UV_RUN_NOWAIT)` to
     poll in one thread and run the event loop's callbacks in another see
@@ -144,6 +144,9 @@ API
         Embedding a kqueue fd in another kqueue pollset doesn't work on all platforms. It's not
         an error to add the fd but it never generates events.
 
+    .. versionchanged:: 2.0.0: added support for Windows and changed return type
+        to ``uv_os_fd_t``.
+
 .. c:function:: int uv_backend_timeout(const uv_loop_t* loop)
 
     Get the poll timeout. The return value is in milliseconds, or -1 for no
@@ -176,60 +179,6 @@ API
 
     Walk the list of handles: `walk_cb` will be executed with the given `arg`.
 
-.. c:function:: int uv_loop_fork(uv_loop_t* loop)
-
-    .. versionadded:: 1.12.0
-
-    Reinitialize any kernel state necessary in the child process after
-    a :man:`fork(2)` system call.
-
-    Previously started watchers will continue to be started in the
-    child process.
-
-    It is necessary to explicitly call this function on every event
-    loop created in the parent process that you plan to continue to
-    use in the child, including the default loop (even if you don't
-    continue to use it in the parent). This function must be called
-    before calling :c:func:`uv_run` or any other API function using
-    the loop in the child. Failure to do so will result in undefined
-    behaviour, possibly including duplicate events delivered to both
-    parent and child or aborting the child process.
-
-    When possible, it is preferred to create a new loop in the child
-    process instead of reusing a loop created in the parent. New loops
-    created in the child process after the fork should not use this
-    function.
-
-    This function is not implemented on Windows, where it returns ``UV_ENOSYS``.
-
-    .. caution::
-
-       This function is experimental. It may contain bugs, and is subject to
-       change or removal. API and ABI stability is not guaranteed.
-
-    .. note::
-
-        On Mac OS X, if directory FS event handles were in use in the
-        parent process *for any event loop*, the child process will no
-        longer be able to use the most efficient FSEvent
-        implementation. Instead, uses of directory FS event handles in
-        the child will fall back to the same implementation used for
-        files and on other kqueue-based systems.
-
-    .. caution::
-
-       On AIX and SunOS, FS event handles that were already started in
-       the parent process at the time of forking will *not* deliver
-       events in the child process; they must be closed and restarted.
-       On all other platforms, they will continue to work normally
-       without any further intervention.
-
-    .. caution::
-
-       Any previous value returned from :c:func:`uv_backend_fd` is now
-       invalid. That function must be called again to determine the
-       correct backend file descriptor.
-
 .. c:function:: void* uv_loop_get_data(const uv_loop_t* loop)
 
     Returns `loop->data`.
diff --git a/docs/src/migration_100_200.rst b/docs/src/migration_100_200.rst
new file mode 100644
index 00000000..a286f23c
--- /dev/null
+++ b/docs/src/migration_100_200.rst
@@ -0,0 +1,38 @@
+
+.. _migration_100_200:
+
+libuv v1 -> v2 migration guide
+===================================
+
+Some APIs changed quite a bit throughout the v2 development process. Here
+is a migration guide for the most significant changes that happened after v1
+was released.
+
+
+Windows HANDLEs are used instead of MSVCRT file descriptors
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+The ``uv_file`` typedef was deleted and replaced by ``uv_os_fd_t`` uniformly across all APIs.
+Constants ``UV_STDIN_FD``, ``UV_STDOUT_FD``, and ``UV_STDERR_FD`` provide cross-platform
+references to the standard constants for stdio access, and can be used in place of any ``uv_os_fd_t``.
+Existing clients can transition to the new API by using the conversion function ``uv_convert_fd_to_handle``
+defined in the libuv header file.
+
+For example, previously a library might pass ``0`` or ``STDIN_FILENO`` to ``uv_guess_handle`` to determine its type
+before calling the appropriate uv_open function.
+Now those uses should be handled by passing the constant ``UV_STDIN_FD`` instead.
+
+If instead a library had an open file descriptor inherited from some other library,
+instead of using the ``int fd`` directly, the value should first be converted to a native handle
+by either calling ``uv_convert_fd_to_handle`` or ``uv_get_osfhandle``, depending on the required lifetime.
+For example, a client might need to call::
+
+    int fd;
+    uv_os_fd_t newfd;
+    DuplicateHandle(GetCurrentProcess(), uv_get_osfhandle(fd),
+                    GetCurrentProcess(), &newfd,
+                    0, FALSE, DUPLICATE_SAME_ACCESS);
+
+to get a new handle to the file where either handle could be closed without affecting the other,
+and the closing of both would be required to release the underlying file resource.
+Or if it is a ``SOCKET``, the user may need to call ``WSADuplicateSocket``.
diff --git a/docs/src/misc.rst b/docs/src/misc.rst
index b2725c39..51f4efaf 100644
--- a/docs/src/misc.rst
+++ b/docs/src/misc.rst
@@ -52,18 +52,15 @@ Data types
     error. The `buf` pointer is the same pointer that was passed to
     :c:func:`uv_random`.
 
-.. c:type:: uv_file
+.. c:type:: uv_os_fd_t
 
     Cross platform representation of a file handle.
+    On Unix systems this is a `typedef` of `int` and on Windows a `HANDLE`.
 
 .. c:type:: uv_os_sock_t
 
     Cross platform representation of a socket handle.
-
-.. c:type:: uv_os_fd_t
-
-    Abstract representation of a file descriptor. On Unix systems this is a
-    `typedef` of `int` and on Windows a `HANDLE`.
+    On Unix systems this is a `typedef` of `int` and on Windows a `SOCKET`.
 
 .. c:type:: uv_pid_t
 
@@ -171,6 +168,7 @@ Data types
             long gid;
             char* shell;
             char* homedir;
+            char* gecos;
         } uv_passwd_t;
 
 .. c:type:: uv_utsname_t
@@ -204,7 +202,7 @@ Data types
 API
 ---
 
-.. c:function:: uv_handle_type uv_guess_handle(uv_file file)
+.. c:function:: uv_handle_type uv_guess_handle(uv_os_fd_t file)
 
     Used to detect what type of stream should be used with a given file
     descriptor. Usually this will be used during initialization to guess the
@@ -213,6 +211,9 @@ API
     For :man:`isatty(3)` equivalent functionality use this function and test
     for ``UV_TTY``.
 
+    STDIO file descriptor pseudo-handles ``UV_STDIN_FD``, ``UV_STDOUT_FD``, and ``UV_STDERR_FD``
+    can be passed to any uv_os_fd_t field for cross-platform support of stdio.
+
 .. c:function:: int uv_replace_allocator(uv_malloc_func malloc_func, uv_realloc_func realloc_func, uv_calloc_func calloc_func, uv_free_func free_func)
 
     .. versionadded:: 1.6.0
@@ -343,6 +344,13 @@ API
 
     Frees the `cpu_infos` array previously allocated with :c:func:`uv_cpu_info`.
 
+.. c:function:: int uv_cpumask_size(void)
+
+    Returns the maximum size of the mask used for process/thread affinities,
+    or ``UV_ENOTSUP`` if affinities are not supported on the current platform.
+
+    .. versionadded:: 2.0.0
+
 .. c:function:: int uv_interface_addresses(uv_interface_address_t** addresses, int* count)
 
     Gets address information about the network interfaces on the system. An
@@ -369,6 +377,9 @@ API
 
     Convert a string containing an IPv6 addresses to a binary structure.
 
+    .. versionchanged:: 2.0.0: :man:`if_nametoindex(3)` errors are no longer
+                        ignored on Unix platforms.
+
 .. c:function:: int uv_ip4_name(const struct sockaddr_in* src, char* dst, size_t size)
 
     Convert a binary structure containing an IPv4 address to a string.
@@ -510,6 +521,8 @@ API
 
     .. versionadded:: 1.9.0
 
+    .. versionchanged:: 2.0.0 `gecos` support is added.
+
 .. c:function:: void uv_os_free_passwd(uv_passwd_t* pwd)
 
     Frees the `pwd` memory previously allocated with :c:func:`uv_os_get_passwd`.
diff --git a/docs/src/pipe.rst b/docs/src/pipe.rst
index 6437a9d9..81189e1b 100644
--- a/docs/src/pipe.rst
+++ b/docs/src/pipe.rst
@@ -41,7 +41,7 @@ API
     passing the handles should have this flag set, not the listening pipe
     that uv_accept is called on.
 
-.. c:function:: int uv_pipe_open(uv_pipe_t* handle, uv_file file)
+.. c:function:: int uv_pipe_open(uv_pipe_t* handle, uv_os_fd_t file)
 
     Open an existing file descriptor or HANDLE as a pipe.
 
@@ -56,16 +56,20 @@ API
     Bind the pipe to a file path (Unix) or a name (Windows).
 
     .. note::
-        Paths on Unix get truncated to ``sizeof(sockaddr_un.sun_path)`` bytes, typically between
-        92 and 108 bytes.
+        If a path on Unix exceeds ``sizeof(sockaddr_un.sun_path)`` bytes, typically between
+        92 and 108 bytes, ``uv_pipe_bind`` will fail with ``UV_ENAMETOOLONG``.
+
+    .. versionchanged: 2.0.0 long filenames will lead to an error rather than being truncated
 
 .. c:function:: void uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle, const char* name, uv_connect_cb cb)
 
     Connect to the Unix domain socket or the named pipe.
 
     .. note::
-        Paths on Unix get truncated to ``sizeof(sockaddr_un.sun_path)`` bytes, typically between
-        92 and 108 bytes.
+        If a path on Unix exceeds ``sizeof(sockaddr_un.sun_path)`` bytes, typically between
+        92 and 108 bytes, ``uv_pipe_bind`` will fail with ``UV_ENAMETOOLONG``.
+
+    .. versionchanged: 2.0.0 long filenames will lead to an error rather than being truncated
 
 .. c:function:: int uv_pipe_getsockname(const uv_pipe_t* handle, char* buffer, size_t* size)
 
@@ -118,3 +122,21 @@ API
     function is blocking.
 
     .. versionadded:: 1.16.0
+
+.. c:function:: int uv_pipe(uv_file fds[2], int read_flags, int write_flags)
+
+    Create a pair of connected pipe handles.
+    Data may be written to `fds[1]` and read from `fds[0]`.
+    The resulting handles can be passed to `uv_pipe_open`, used with `uv_spawn`,
+    or for any other purpose.
+
+    Valid values for `flags` are:
+
+      - UV_NONBLOCK_PIPE: Opens the specified socket handle for `OVERLAPPED`
+        or `FIONBIO`/`O_NONBLOCK` I/O usage.
+        This is recommended for handles that will be used by libuv,
+        and not usually recommended otherwise.
+
+    Equivalent to :man:`pipe(2)` with the `O_CLOEXEC` flag set.
+
+    .. versionadded:: 1.x.0
diff --git a/docs/src/poll.rst b/docs/src/poll.rst
index aba89158..01a8a900 100644
--- a/docs/src/poll.rst
+++ b/docs/src/poll.rst
@@ -70,19 +70,12 @@ N/A
 API
 ---
 
-.. c:function:: int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd)
+.. c:function:: int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, uv_os_sock_t socket)
 
     Initialize the handle using a file descriptor.
 
     .. versionchanged:: 1.2.2 the file descriptor is set to non-blocking mode.
 
-.. c:function:: int uv_poll_init_socket(uv_loop_t* loop, uv_poll_t* handle, uv_os_sock_t socket)
-
-    Initialize the handle using a socket descriptor. On Unix this is identical
-    to :c:func:`uv_poll_init`. On windows it takes a SOCKET handle.
-
-    .. versionchanged:: 1.2.2 the socket is set to non-blocking mode.
-
 .. c:function:: int uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb)
 
     Starts polling the file descriptor. `events` is a bitmask made up of
diff --git a/docs/src/process.rst b/docs/src/process.rst
index 8ff19add..d6f99f5d 100644
--- a/docs/src/process.rst
+++ b/docs/src/process.rst
@@ -32,6 +32,8 @@ Data types
             uv_stdio_container_t* stdio;
             uv_uid_t uid;
             uv_gid_t gid;
+            char* cpumask;
+            size_t cpumask_size;
         } uv_process_options_t;
 
 .. c:type:: void (*uv_exit_cb)(uv_process_t*, int64_t exit_status, int term_signal)
@@ -119,12 +121,14 @@ Data types
             * flags may be specified to create a duplex data stream.
             */
             UV_READABLE_PIPE = 0x10,
-            UV_WRITABLE_PIPE = 0x20
+            UV_WRITABLE_PIPE = 0x20,
             /*
-             * Open the child pipe handle in overlapped mode on Windows.
-             * On Unix it is silently ignored.
-             */
-            UV_OVERLAPPED_PIPE = 0x40
+            * When UV_CREATE_PIPE is specified, specifying UV_NONBLOCK_PIPE opens the
+            * handle in non-blocking mode in the child. This may cause loss of data,
+            * if the child is not designed to handle to encounter this mode,
+            * but can also be significantly more efficient.
+            */
+            UV_NONBLOCK_PIPE = 0x40
         } uv_stdio_flags;
 
 
@@ -176,7 +180,7 @@ Public members
 
     .. note::
         On Windows file descriptors greater than 2 are available to the child process only if
-        the child processes uses the MSVCRT runtime.
+        the child executable uses the MSVCRT runtime.
 
 .. c:member:: uv_uid_t uv_process_options_t.uid
 .. c:member:: uv_gid_t uv_process_options_t.gid
@@ -188,6 +192,23 @@ Public members
         This is not supported on Windows, :c:func:`uv_spawn` will fail and set the error
         to ``UV_ENOTSUP``.
 
+.. c:member:: char* uv_process_options_t.cpumask
+.. c:member:: size_t uv_process_options_t.cpumask_size
+
+    Libuv can set the child process' CPU affinity mask.  This happens when
+    `cpumask` is non-NULL.  It must point to an array of char values
+    of length `cpumask_size`, whose value must be at least that returned by
+    :c:func:`uv_cpumask_size`.  Each byte in the mask can be either
+    zero (false) or non-zero (true) to indicate whether the corresponding
+    processor at that index is included.
+
+    .. note::
+
+        If enabled on an unsupported platform, :c:func:`uv_spawn` will fail
+        with ``UV_ENOTSUP``.
+
+    .. versionadded:: 2.0.0
+
 .. c:member:: uv_stdio_flags uv_stdio_container_t.flags
 
     Flags specifying how the stdio container should be passed to the child.
diff --git a/docs/src/request.rst b/docs/src/request.rst
index a0414431..0891e019 100644
--- a/docs/src/request.rst
+++ b/docs/src/request.rst
@@ -25,6 +25,14 @@ Data types
 Public members
 ^^^^^^^^^^^^^^
 
+.. c:member:: uv_loop_t* uv_req_t.loop
+
+    Loop that started this request and where completion will be reported.
+    Readonly.
+    
+    .. versionadded:: 2.0.0
+       Moved from derived types (uv_connect_t, uv_fs_t, etc.) to uv_req_t.
+
 .. c:member:: void* uv_req_t.data
 
     Space for user-defined arbitrary data. libuv does not use this field.
@@ -89,6 +97,12 @@ API
     Returns the size of the given request type. Useful for FFI binding writers
     who don't want to know the structure layout.
 
+.. c:function:: uv_loop_t* uv_req_get_loop(const uv_req_t* req)
+
+    Returns `req->loop`.
+
+    .. versionadded:: 2.0.0
+
 .. c:function:: void* uv_req_get_data(const uv_req_t* req)
 
     Returns `req->data`.
diff --git a/docs/src/tcp.rst b/docs/src/tcp.rst
index 3cc8efaa..8fab6c10 100644
--- a/docs/src/tcp.rst
+++ b/docs/src/tcp.rst
@@ -128,3 +128,20 @@ API
     :c:func:`uv_tcp_close_reset` calls is not allowed.
 
     .. versionadded:: 1.32.0
+
+.. c:function:: int uv_socketpair(int type, int protocol, uv_os_sock_t socket_vector[2], int flags0, int flags1)
+
+    Create a pair of connected sockets with the specified properties.
+    The resulting handles can be passed to `uv_tcp_open`, used with `uv_spawn`,
+    or for any other purpose.
+
+    Valid values for `flags0` and `flags1` are:
+
+      - UV_NONBLOCK_PIPE: Opens the specified socket handle for `OVERLAPPED`
+        or `FIONBIO`/`O_NONBLOCK` I/O usage.
+        This is recommended for handles that will be used by libuv,
+        and not usually recommended otherwise.
+
+    Equivalent to :man:`socketpair(2)` with a domain of AF_UNIX.
+
+    .. versionadded:: 1.x.0
diff --git a/docs/src/threading.rst b/docs/src/threading.rst
index 7ca1d4b7..162de0e0 100644
--- a/docs/src/threading.rst
+++ b/docs/src/threading.rst
@@ -88,6 +88,45 @@ Threads
 
     .. versionadded:: 1.26.0
 
+.. c:function:: int uv_thread_setaffinity(uv_thread_t* tid, char* cpumask, char* oldmask, size_t mask_size)
+
+    Sets the specified thread's affinity to cpumask, which is specified in
+    bytes. Optionally returning the previous affinity setting in oldmask.
+    On Unix, uses :man:`pthread_getaffinity_np(3)` to get the affinity setting
+    and maps the cpu_set_t to bytes in oldmask. Then maps the bytes in cpumask
+    to a cpu_set_t and uses :man:`pthread_setaffinity_np(3)`. On Windows, maps
+    the bytes in cpumask to a bitmask and uses SetThreadAffinityMask() which
+    returns the previous affinity setting.
+
+    The mask_size specifies the number of entries (bytes) in cpumask / oldmask,
+    and must be greater-than-or-equal-to :c:func:`uv_cpumask_size`.
+
+    .. note::
+        Thread affinity setting is not atomic on Windows. Unsupported on macOS.
+
+    .. versionadded:: 2.0.0
+
+.. c:function:: int uv_thread_getaffinity(uv_thread_t* tid, char* cpumask, size_t mask_size)
+
+    Gets the specified thread's affinity setting. On Unix, this maps the
+    cpu_set_t returned by :man:`pthread_getaffinity_np(3)` to bytes in cpumask.
+
+    The mask_size specifies the number of entries (bytes) in cpumask,
+    and must be greater-than-or-equal-to :c:func:`uv_cpumask_size`.
+
+    .. note::
+        Thread affinity getting is not atomic on Windows. Unsupported on macOS.
+
+    .. versionadded:: 2.0.0
+
+.. c:function:: int uv_thread_detach(uv_thread_t* tid)
+
+   Detaches the specified thread so it will be cleaned up on exit automatically;
+   joining it is no longer necessary (or possible).
+   Uses :man:`pthread_detach(3)` on Unix and CloseHandle() on Windows.
+
+    .. versionadded:: 2.0.0
+
 .. c:function:: uv_thread_t uv_thread_self(void)
 .. c:function:: int uv_thread_join(uv_thread_t *tid)
 .. c:function:: int uv_thread_equal(const uv_thread_t* t1, const uv_thread_t* t2)
diff --git a/docs/src/threadpool.rst b/docs/src/threadpool.rst
index cf6cdc1b..d08fe804 100644
--- a/docs/src/threadpool.rst
+++ b/docs/src/threadpool.rst
@@ -47,11 +47,6 @@ Data types
 Public members
 ^^^^^^^^^^^^^^
 
-.. c:member:: uv_loop_t* uv_work_t.loop
-
-    Loop that started this request and where completion will be reported.
-    Readonly.
-
 .. seealso:: The :c:type:`uv_req_t` members also apply.
 
 
diff --git a/docs/src/timer.rst b/docs/src/timer.rst
index e163e288..2be6dddd 100644
--- a/docs/src/timer.rst
+++ b/docs/src/timer.rst
@@ -53,9 +53,9 @@ API
 
 .. c:function:: int uv_timer_again(uv_timer_t* handle)
 
-    Stop the timer, and if it is repeating restart it using the repeat value
-    as the timeout. If the timer has never been started before it returns
-    UV_EINVAL.
+    Stop the timer and restart it using the repeat value as the timeout. If the
+    timer has never been started before, or the timer is not a repeating timer,
+    it returns `UV_EINVAL`.
 
 .. c:function:: void uv_timer_set_repeat(uv_timer_t* handle, uint64_t repeat)
 
diff --git a/docs/src/tty.rst b/docs/src/tty.rst
index f1acfdc1..f2f92394 100644
--- a/docs/src/tty.rst
+++ b/docs/src/tty.rst
@@ -64,7 +64,7 @@ N/A
 API
 ---
 
-.. c:function:: int uv_tty_init(uv_loop_t* loop, uv_tty_t* handle, uv_file fd, int unused)
+.. c:function:: int uv_tty_init(uv_loop_t* loop, uv_tty_t* handle, uv_os_fd_t fd, int unused)
 
     Initialize a new TTY stream with the given file descriptor. Usually the
     file descriptor will be:
diff --git a/docs/src/upgrading.rst b/docs/src/upgrading.rst
index 32840c26..2c853a0b 100644
--- a/docs/src/upgrading.rst
+++ b/docs/src/upgrading.rst
@@ -9,3 +9,4 @@ Migration guides for different libuv versions, starting with 1.0.
    :maxdepth: 1
 
    migration_010_100
+   migration_100_200
diff --git a/include/uv.h b/include/uv.h
index 06b6d001..40dc1e7d 100644
--- a/include/uv.h
+++ b/include/uv.h
@@ -52,16 +52,13 @@ extern "C" {
 #include "uv/errno.h"
 #include "uv/version.h"
 #include <stddef.h>
-#include <stdio.h>
-
-#if defined(_MSC_VER) && _MSC_VER < 1600
-# include "uv/stdint-msvc2008.h"
-#else
-# include <stdint.h>
-#endif
+#include <stdint.h>
 
 #if defined(_WIN32)
 # include "uv/win.h"
+# if !defined(BUILDING_UV_SHARED)
+#   include "io.h" /* this header is not correct in a shared library environment */
+# endif
 #else
 # include "uv/unix.h"
 #endif
@@ -291,7 +288,6 @@ UV_EXTERN void uv_loop_delete(uv_loop_t*);
 UV_EXTERN size_t uv_loop_size(void);
 UV_EXTERN int uv_loop_alive(const uv_loop_t* loop);
 UV_EXTERN int uv_loop_configure(uv_loop_t* loop, uv_loop_option option, ...);
-UV_EXTERN int uv_loop_fork(uv_loop_t* loop);
 
 UV_EXTERN int uv_run(uv_loop_t*, uv_run_mode mode);
 UV_EXTERN void uv_stop(uv_loop_t*);
@@ -303,7 +299,7 @@ UV_EXTERN int uv_has_ref(const uv_handle_t*);
 UV_EXTERN void uv_update_time(uv_loop_t*);
 UV_EXTERN uint64_t uv_now(const uv_loop_t*);
 
-UV_EXTERN int uv_backend_fd(const uv_loop_t*);
+UV_EXTERN uv_os_fd_t uv_backend_fd(const uv_loop_t*);
 UV_EXTERN int uv_backend_timeout(const uv_loop_t*);
 
 typedef void (*uv_alloc_cb)(uv_handle_t* handle,
@@ -398,6 +394,7 @@ UV_EXTERN char* uv_err_name_r(int err, char* buf, size_t buflen);
   /* public */                                                                \
   void* data;                                                                 \
   /* read-only */                                                             \
+  uv_loop_t* loop;                                                            \
   uv_req_type type;                                                           \
   /* private */                                                               \
   void* reserved[6];                                                          \
@@ -434,10 +431,6 @@ struct uv_shutdown_s {
   /* private */                                                               \
   uv_close_cb close_cb;                                                       \
   void* handle_queue[2];                                                      \
-  union {                                                                     \
-    int fd;                                                                   \
-    void* reserved[4];                                                        \
-  } u;                                                                        \
   UV_HANDLE_PRIVATE_FIELDS                                                    \
 
 /* The abstract base class of all handles. */
@@ -455,6 +448,7 @@ UV_EXTERN void uv_handle_set_data(uv_handle_t* handle, void* data);
 UV_EXTERN size_t uv_req_size(uv_req_type type);
 UV_EXTERN void* uv_req_get_data(const uv_req_t* req);
 UV_EXTERN void uv_req_set_data(uv_req_t* req, void* data);
+UV_EXTERN uv_loop_t* uv_req_get_loop(const uv_req_t* handle);
 UV_EXTERN uv_req_type uv_req_get_type(const uv_req_t* req);
 UV_EXTERN const char* uv_req_type_name(uv_req_type type);
 
@@ -463,8 +457,8 @@ UV_EXTERN int uv_is_active(const uv_handle_t* handle);
 UV_EXTERN void uv_walk(uv_loop_t* loop, uv_walk_cb walk_cb, void* arg);
 
 /* Helpers for ad hoc debugging, no API/ABI stability guaranteed. */
-UV_EXTERN void uv_print_all_handles(uv_loop_t* loop, FILE* stream);
-UV_EXTERN void uv_print_active_handles(uv_loop_t* loop, FILE* stream);
+UV_EXTERN void uv_print_all_handles(uv_loop_t* loop, /*FILE*/void* stream);
+UV_EXTERN void uv_print_active_handles(uv_loop_t* loop, /*FILE*/void* stream);
 
 UV_EXTERN void uv_close(uv_handle_t* handle, uv_close_cb close_cb);
 
@@ -473,8 +467,74 @@ UV_EXTERN int uv_recv_buffer_size(uv_handle_t* handle, int* value);
 
 UV_EXTERN int uv_fileno(const uv_handle_t* handle, uv_os_fd_t* fd);
 
-UV_EXTERN uv_buf_t uv_buf_init(char* base, unsigned int len);
+UV_EXTERN uv_buf_t uv_buf_init(char* base, size_t len);
+
+/*
+ * The following functions are declared 'static inline' to ensure that they
+ * end up in the static linkage namespace of the caller and thus point to
+ * the correct (caller's) copy of MSVCRT for resolving the `fd` pseudo-handle
+ * to the intended kernel `HANDLE`.
+ * Thus, they are also not included when building a shared library,
+ * as their definition would not be correct when linked into that environment.
+ */
+#if !defined(BUILDING_UV_SHARED)
+#if defined(_MSC_VER)
+# define INLINE __inline
+#elif defined(__GNUC__) || defined(__MVS__)
+# define INLINE __inline__
+#else
+# define INLINE inline
+#endif
+
+static INLINE uv_os_fd_t uv_get_osfhandle(int fd) {
+#ifdef _WIN32
+  /*
+   * _get_osfhandle() raises an assert in debug builds if the FD is invalid.
+   * So if you plan on using invalid fd, you will need to install a _CrtSetReportHook handler
+   */
+  return (HANDLE) _get_osfhandle(fd);
+#else
+  return fd;
+#endif
+}
+
+
+static INLINE uv_os_fd_t uv_convert_fd_to_handle(int fd) {
+#ifdef _WIN32
+  HANDLE new_handle;
+  if (!DuplicateHandle(GetCurrentProcess(), (HANDLE) _get_osfhandle(fd),
+                       GetCurrentProcess(), &new_handle,
+                       0, FALSE, DUPLICATE_SAME_ACCESS)) {
+    return INVALID_HANDLE_VALUE;
+  }
+  _close(fd);
+  return new_handle;
+#else
+  return fd;
+#endif
+}
+
+#undef INLINE
 
+#endif /* BUILDING_UV_SHARED */
+
+
+#ifdef _WIN32
+#define UV_STDIN_FD    ((HANDLE)-10)
+#define UV_STDOUT_FD   ((HANDLE)-11)
+#define UV_STDERR_FD   ((HANDLE)-12)
+#else
+#define UV_STDIN_FD    (0)
+#define UV_STDOUT_FD   (1)
+#define UV_STDERR_FD   (2)
+#endif
+
+UV_EXTERN int uv_pipe(uv_os_fd_t fds[2], int read_flags, int write_flags);
+UV_EXTERN int uv_socketpair(int type,
+                            int protocol,
+                            uv_os_sock_t socket_vector[2],
+                            int flags0,
+                            int flags1);
 
 #define UV_STREAM_FIELDS                                                      \
   /* number of bytes queued for writing */                                    \
@@ -732,8 +792,7 @@ typedef enum {
   UV_TTY_UNSUPPORTED
 } uv_tty_vtermstate_t;
 
-
-UV_EXTERN int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd, int readable);
+UV_EXTERN int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_os_fd_t fd, int readable);
 UV_EXTERN int uv_tty_set_mode(uv_tty_t*, uv_tty_mode_t mode);
 UV_EXTERN int uv_tty_reset_mode(void);
 UV_EXTERN int uv_tty_get_winsize(uv_tty_t*, int* width, int* height);
@@ -750,7 +809,7 @@ inline int uv_tty_set_mode(uv_tty_t* handle, int mode) {
 }
 #endif
 
-UV_EXTERN uv_handle_type uv_guess_handle(uv_file file);
+UV_EXTERN uv_handle_type uv_guess_handle(uv_os_fd_t file);
 
 /*
  * uv_pipe_t is a subclass of uv_stream_t.
@@ -766,7 +825,7 @@ struct uv_pipe_s {
 };
 
 UV_EXTERN int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle, int ipc);
-UV_EXTERN int uv_pipe_open(uv_pipe_t*, uv_file file);
+UV_EXTERN int uv_pipe_open(uv_pipe_t*, uv_os_fd_t file);
 UV_EXTERN int uv_pipe_bind(uv_pipe_t* handle, const char* name);
 UV_EXTERN void uv_pipe_connect(uv_connect_t* req,
                                uv_pipe_t* handle,
@@ -797,10 +856,9 @@ enum uv_poll_event {
   UV_PRIORITIZED = 8
 };
 
-UV_EXTERN int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd);
-UV_EXTERN int uv_poll_init_socket(uv_loop_t* loop,
-                                  uv_poll_t* handle,
-                                  uv_os_sock_t socket);
+UV_EXTERN int uv_poll_init(uv_loop_t* loop,
+                           uv_poll_t* handle,
+                           uv_os_sock_t socket);
 UV_EXTERN int uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb);
 UV_EXTERN int uv_poll_stop(uv_poll_t* handle);
 
@@ -875,7 +933,6 @@ UV_EXTERN uint64_t uv_timer_get_repeat(const uv_timer_t* handle);
 struct uv_getaddrinfo_s {
   UV_REQ_FIELDS
   /* read-only */
-  uv_loop_t* loop;
   /* struct addrinfo* addrinfo is marked as private, but it really isn't. */
   UV_GETADDRINFO_PRIVATE_FIELDS
 };
@@ -898,7 +955,6 @@ UV_EXTERN void uv_freeaddrinfo(struct addrinfo* ai);
 struct uv_getnameinfo_s {
   UV_REQ_FIELDS
   /* read-only */
-  uv_loop_t* loop;
   /* host and service are marked as private, but they really aren't. */
   UV_GETNAMEINFO_PRIVATE_FIELDS
 };
@@ -926,10 +982,13 @@ typedef enum {
   UV_WRITABLE_PIPE  = 0x20,
 
   /*
-   * Open the child pipe handle in overlapped mode on Windows.
-   * On Unix it is silently ignored.
+   * When UV_CREATE_PIPE is specified, specifying UV_NONBLOCK_PIPE opens the
+   * handle in non-blocking mode in the child. This may cause loss of data,
+   * if the child is not designed to handle to encounter this mode,
+   * but can also be significantly more efficient.
    */
-  UV_OVERLAPPED_PIPE = 0x40
+  UV_NONBLOCK_PIPE  = 0x40,
+  UV_OVERLAPPED_PIPE = 0x40 /* old name, for compatibility */
 } uv_stdio_flags;
 
 typedef struct uv_stdio_container_s {
@@ -937,7 +996,7 @@ typedef struct uv_stdio_container_s {
 
   union {
     uv_stream_t* stream;
-    int fd;
+    uv_os_fd_t file;
   } data;
 } uv_stdio_container_t;
 
@@ -984,6 +1043,19 @@ typedef struct uv_process_options_s {
    */
   uv_uid_t uid;
   uv_gid_t gid;
+  /*
+    Libuv can set the child process' CPU affinity mask.  This happens when
+    `cpumask` is non-NULL.  It must point to an array of char values
+    of length `cpumask_size`, whose value must be at least that returned by
+    uv_cpumask_size().  Each byte in the mask can be either zero (false)
+    or non-zero (true) to indicate whether the corresponding processor at
+    that index is included.
+
+    If enabled on an unsupported platform, uv_spawn() will fail with
+    UV_ENOTSUP.
+   */
+  char* cpumask;
+  size_t cpumask_size;
 } uv_process_options_t;
 
 /*
@@ -1058,7 +1130,6 @@ UV_EXTERN uv_pid_t uv_process_get_pid(const uv_process_t*);
  */
 struct uv_work_s {
   UV_REQ_FIELDS
-  uv_loop_t* loop;
   uv_work_cb work_cb;
   uv_after_work_cb after_work_cb;
   UV_WORK_PRIVATE_FIELDS
@@ -1106,6 +1177,7 @@ struct uv_passwd_s {
   long gid;
   char* shell;
   char* homedir;
+  char* gecos;
 };
 
 struct uv_utsname_s {
@@ -1150,8 +1222,6 @@ UV_EXTERN int uv_get_process_title(char* buffer, size_t size);
 UV_EXTERN int uv_set_process_title(const char* title);
 UV_EXTERN int uv_resident_set_memory(size_t* rss);
 UV_EXTERN int uv_uptime(double* uptime);
-UV_EXTERN uv_os_fd_t uv_get_osfhandle(int fd);
-UV_EXTERN int uv_open_osfhandle(uv_os_fd_t os_fd);
 
 typedef struct {
   long tv_sec;
@@ -1213,6 +1283,7 @@ UV_EXTERN int uv_os_setpriority(uv_pid_t pid, int priority);
 
 UV_EXTERN int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count);
 UV_EXTERN void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count);
+UV_EXTERN int uv_cpumask_size(void);
 
 UV_EXTERN int uv_interface_addresses(uv_interface_address_t** addresses,
                                      int* count);
@@ -1277,9 +1348,9 @@ typedef enum {
   UV_FS_READLINK,
   UV_FS_CHOWN,
   UV_FS_FCHOWN,
+  UV_FS_LCHOWN,
   UV_FS_REALPATH,
   UV_FS_COPYFILE,
-  UV_FS_LCHOWN,
   UV_FS_OPENDIR,
   UV_FS_READDIR,
   UV_FS_CLOSEDIR,
@@ -1299,7 +1370,6 @@ struct uv_dir_s {
 struct uv_fs_s {
   UV_REQ_FIELDS
   uv_fs_type fs_type;
-  uv_loop_t* loop;
   uv_fs_cb cb;
   ssize_t result;
   void* ptr;
@@ -1318,7 +1388,7 @@ UV_EXTERN uv_stat_t* uv_fs_get_statbuf(uv_fs_t*);
 UV_EXTERN void uv_fs_req_cleanup(uv_fs_t* req);
 UV_EXTERN int uv_fs_close(uv_loop_t* loop,
                           uv_fs_t* req,
-                          uv_file file,
+                          uv_os_fd_t file,
                           uv_fs_cb cb);
 UV_EXTERN int uv_fs_open(uv_loop_t* loop,
                          uv_fs_t* req,
@@ -1328,7 +1398,7 @@ UV_EXTERN int uv_fs_open(uv_loop_t* loop,
                          uv_fs_cb cb);
 UV_EXTERN int uv_fs_read(uv_loop_t* loop,
                          uv_fs_t* req,
-                         uv_file file,
+                         uv_os_fd_t file,
                          const uv_buf_t bufs[],
                          unsigned int nbufs,
                          int64_t offset,
@@ -1339,7 +1409,7 @@ UV_EXTERN int uv_fs_unlink(uv_loop_t* loop,
                            uv_fs_cb cb);
 UV_EXTERN int uv_fs_write(uv_loop_t* loop,
                           uv_fs_t* req,
-                          uv_file file,
+                          uv_os_fd_t file,
                           const uv_buf_t bufs[],
                           unsigned int nbufs,
                           int64_t offset,
@@ -1410,7 +1480,7 @@ UV_EXTERN int uv_fs_stat(uv_loop_t* loop,
                          uv_fs_cb cb);
 UV_EXTERN int uv_fs_fstat(uv_loop_t* loop,
                           uv_fs_t* req,
-                          uv_file file,
+                          uv_os_fd_t file,
                           uv_fs_cb cb);
 UV_EXTERN int uv_fs_rename(uv_loop_t* loop,
                            uv_fs_t* req,
@@ -1419,21 +1489,21 @@ UV_EXTERN int uv_fs_rename(uv_loop_t* loop,
                            uv_fs_cb cb);
 UV_EXTERN int uv_fs_fsync(uv_loop_t* loop,
                           uv_fs_t* req,
-                          uv_file file,
+                          uv_os_fd_t file,
                           uv_fs_cb cb);
 UV_EXTERN int uv_fs_fdatasync(uv_loop_t* loop,
                               uv_fs_t* req,
-                              uv_file file,
+                              uv_os_fd_t file,
                               uv_fs_cb cb);
 UV_EXTERN int uv_fs_ftruncate(uv_loop_t* loop,
                               uv_fs_t* req,
-                              uv_file file,
+                              uv_os_fd_t file,
                               int64_t offset,
                               uv_fs_cb cb);
 UV_EXTERN int uv_fs_sendfile(uv_loop_t* loop,
                              uv_fs_t* req,
-                             uv_file out_fd,
-                             uv_file in_fd,
+                             uv_os_fd_t out_fd,
+                             uv_os_fd_t in_fd,
                              int64_t in_offset,
                              size_t length,
                              uv_fs_cb cb);
@@ -1453,12 +1523,26 @@ UV_EXTERN int uv_fs_utime(uv_loop_t* loop,
                           double atime,
                           double mtime,
                           uv_fs_cb cb);
+UV_EXTERN int uv_fs_utime_ex(uv_loop_t* loop,
+                             uv_fs_t* req,
+                             const char* path,
+                             double btime,
+                             double atime,
+                             double mtime,
+                             uv_fs_cb cb);
 UV_EXTERN int uv_fs_futime(uv_loop_t* loop,
                            uv_fs_t* req,
-                           uv_file file,
+                           uv_os_fd_t file,
                            double atime,
                            double mtime,
                            uv_fs_cb cb);
+UV_EXTERN int uv_fs_futime_ex(uv_loop_t* loop,
+                              uv_fs_t* req,
+                              uv_os_fd_t file,
+                              double btime,
+                              double atime,
+                              double mtime,
+                              uv_fs_cb cb);
 UV_EXTERN int uv_fs_lutime(uv_loop_t* loop,
                            uv_fs_t* req,
                            const char* path,
@@ -1503,7 +1587,7 @@ UV_EXTERN int uv_fs_realpath(uv_loop_t* loop,
                              uv_fs_cb cb);
 UV_EXTERN int uv_fs_fchmod(uv_loop_t* loop,
                            uv_fs_t* req,
-                           uv_file file,
+                           uv_os_fd_t file,
                            int mode,
                            uv_fs_cb cb);
 UV_EXTERN int uv_fs_chown(uv_loop_t* loop,
@@ -1514,7 +1598,7 @@ UV_EXTERN int uv_fs_chown(uv_loop_t* loop,
                           uv_fs_cb cb);
 UV_EXTERN int uv_fs_fchown(uv_loop_t* loop,
                            uv_fs_t* req,
-                           uv_file file,
+                           uv_os_fd_t file,
                            uv_uid_t uid,
                            uv_gid_t gid,
                            uv_fs_cb cb);
@@ -1636,8 +1720,6 @@ UV_EXTERN int uv_inet_pton(int af, const char* src, void* dst);
 
 struct uv_random_s {
   UV_REQ_FIELDS
-  /* read-only */
-  uv_loop_t* loop;
   /* private */
   int status;
   void* buf;
@@ -1754,8 +1836,16 @@ UV_EXTERN int uv_thread_create_ex(uv_thread_t* tid,
                                   const uv_thread_options_t* params,
                                   uv_thread_cb entry,
                                   void* arg);
+UV_EXTERN int uv_thread_setaffinity(uv_thread_t* tid,
+                                    char* cpumask,
+                                    char* oldmask,
+                                    size_t mask_size);
+UV_EXTERN int uv_thread_getaffinity(uv_thread_t* tid,
+                                    char* cpumask,
+                                    size_t mask_size);
+UV_EXTERN int uv_thread_detach(uv_thread_t* tid);
+UV_EXTERN int uv_thread_join(uv_thread_t* tid);
 UV_EXTERN uv_thread_t uv_thread_self(void);
-UV_EXTERN int uv_thread_join(uv_thread_t *tid);
 UV_EXTERN int uv_thread_equal(const uv_thread_t* t1, const uv_thread_t* t2);
 
 /* The presence of these unions force similar struct layout. */
@@ -1784,6 +1874,7 @@ struct uv_loop_s {
   void* internal_fields;
   /* Internal flag to signal loop stop. */
   unsigned int stop_flag;
+  void* reserved[4];
   UV_LOOP_PRIVATE_FIELDS
 };
 
diff --git a/include/uv/stdint-msvc2008.h b/include/uv/stdint-msvc2008.h
deleted file mode 100644
index d02608a5..00000000
--- a/include/uv/stdint-msvc2008.h
+++ /dev/null
@@ -1,247 +0,0 @@
-// ISO C9x  compliant stdint.h for Microsoft Visual Studio
-// Based on ISO/IEC 9899:TC2 Committee draft (May 6, 2005) WG14/N1124 
-// 
-//  Copyright (c) 2006-2008 Alexander Chemeris
-// 
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are met:
-// 
-//   1. Redistributions of source code must retain the above copyright notice,
-//      this list of conditions and the following disclaimer.
-// 
-//   2. Redistributions in binary form must reproduce the above copyright
-//      notice, this list of conditions and the following disclaimer in the
-//      documentation and/or other materials provided with the distribution.
-// 
-//   3. The name of the author may be used to endorse or promote products
-//      derived from this software without specific prior written permission.
-// 
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
-// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
-// EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
-// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-// 
-///////////////////////////////////////////////////////////////////////////////
-
-#ifndef _MSC_VER // [
-#error "Use this header only with Microsoft Visual C++ compilers!"
-#endif // _MSC_VER ]
-
-#ifndef _MSC_STDINT_H_ // [
-#define _MSC_STDINT_H_
-
-#if _MSC_VER > 1000
-#pragma once
-#endif
-
-#include <limits.h>
-
-// For Visual Studio 6 in C++ mode and for many Visual Studio versions when
-// compiling for ARM we should wrap <wchar.h> include with 'extern "C++" {}'
-// or compiler give many errors like this:
-//   error C2733: second C linkage of overloaded function 'wmemchr' not allowed
-#ifdef __cplusplus
-extern "C" {
-#endif
-#  include <wchar.h>
-#ifdef __cplusplus
-}
-#endif
-
-// Define _W64 macros to mark types changing their size, like intptr_t.
-#ifndef _W64
-#  if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
-#     define _W64 __w64
-#  else
-#     define _W64
-#  endif
-#endif
-
-
-// 7.18.1 Integer types
-
-// 7.18.1.1 Exact-width integer types
-
-// Visual Studio 6 and Embedded Visual C++ 4 doesn't
-// realize that, e.g. char has the same size as __int8
-// so we give up on __intX for them.
-#if (_MSC_VER < 1300)
-   typedef signed char       int8_t;
-   typedef signed short      int16_t;
-   typedef signed int        int32_t;
-   typedef unsigned char     uint8_t;
-   typedef unsigned short    uint16_t;
-   typedef unsigned int      uint32_t;
-#else
-   typedef signed __int8     int8_t;
-   typedef signed __int16    int16_t;
-   typedef signed __int32    int32_t;
-   typedef unsigned __int8   uint8_t;
-   typedef unsigned __int16  uint16_t;
-   typedef unsigned __int32  uint32_t;
-#endif
-typedef signed __int64       int64_t;
-typedef unsigned __int64     uint64_t;
-
-
-// 7.18.1.2 Minimum-width integer types
-typedef int8_t    int_least8_t;
-typedef int16_t   int_least16_t;
-typedef int32_t   int_least32_t;
-typedef int64_t   int_least64_t;
-typedef uint8_t   uint_least8_t;
-typedef uint16_t  uint_least16_t;
-typedef uint32_t  uint_least32_t;
-typedef uint64_t  uint_least64_t;
-
-// 7.18.1.3 Fastest minimum-width integer types
-typedef int8_t    int_fast8_t;
-typedef int16_t   int_fast16_t;
-typedef int32_t   int_fast32_t;
-typedef int64_t   int_fast64_t;
-typedef uint8_t   uint_fast8_t;
-typedef uint16_t  uint_fast16_t;
-typedef uint32_t  uint_fast32_t;
-typedef uint64_t  uint_fast64_t;
-
-// 7.18.1.4 Integer types capable of holding object pointers
-#ifdef _WIN64 // [
-   typedef signed __int64    intptr_t;
-   typedef unsigned __int64  uintptr_t;
-#else // _WIN64 ][
-   typedef _W64 signed int   intptr_t;
-   typedef _W64 unsigned int uintptr_t;
-#endif // _WIN64 ]
-
-// 7.18.1.5 Greatest-width integer types
-typedef int64_t   intmax_t;
-typedef uint64_t  uintmax_t;
-
-
-// 7.18.2 Limits of specified-width integer types
-
-#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) // [   See footnote 220 at page 257 and footnote 221 at page 259
-
-// 7.18.2.1 Limits of exact-width integer types
-#define INT8_MIN     ((int8_t)_I8_MIN)
-#define INT8_MAX     _I8_MAX
-#define INT16_MIN    ((int16_t)_I16_MIN)
-#define INT16_MAX    _I16_MAX
-#define INT32_MIN    ((int32_t)_I32_MIN)
-#define INT32_MAX    _I32_MAX
-#define INT64_MIN    ((int64_t)_I64_MIN)
-#define INT64_MAX    _I64_MAX
-#define UINT8_MAX    _UI8_MAX
-#define UINT16_MAX   _UI16_MAX
-#define UINT32_MAX   _UI32_MAX
-#define UINT64_MAX   _UI64_MAX
-
-// 7.18.2.2 Limits of minimum-width integer types
-#define INT_LEAST8_MIN    INT8_MIN
-#define INT_LEAST8_MAX    INT8_MAX
-#define INT_LEAST16_MIN   INT16_MIN
-#define INT_LEAST16_MAX   INT16_MAX
-#define INT_LEAST32_MIN   INT32_MIN
-#define INT_LEAST32_MAX   INT32_MAX
-#define INT_LEAST64_MIN   INT64_MIN
-#define INT_LEAST64_MAX   INT64_MAX
-#define UINT_LEAST8_MAX   UINT8_MAX
-#define UINT_LEAST16_MAX  UINT16_MAX
-#define UINT_LEAST32_MAX  UINT32_MAX
-#define UINT_LEAST64_MAX  UINT64_MAX
-
-// 7.18.2.3 Limits of fastest minimum-width integer types
-#define INT_FAST8_MIN    INT8_MIN
-#define INT_FAST8_MAX    INT8_MAX
-#define INT_FAST16_MIN   INT16_MIN
-#define INT_FAST16_MAX   INT16_MAX
-#define INT_FAST32_MIN   INT32_MIN
-#define INT_FAST32_MAX   INT32_MAX
-#define INT_FAST64_MIN   INT64_MIN
-#define INT_FAST64_MAX   INT64_MAX
-#define UINT_FAST8_MAX   UINT8_MAX
-#define UINT_FAST16_MAX  UINT16_MAX
-#define UINT_FAST32_MAX  UINT32_MAX
-#define UINT_FAST64_MAX  UINT64_MAX
-
-// 7.18.2.4 Limits of integer types capable of holding object pointers
-#ifdef _WIN64 // [
-#  define INTPTR_MIN   INT64_MIN
-#  define INTPTR_MAX   INT64_MAX
-#  define UINTPTR_MAX  UINT64_MAX
-#else // _WIN64 ][
-#  define INTPTR_MIN   INT32_MIN
-#  define INTPTR_MAX   INT32_MAX
-#  define UINTPTR_MAX  UINT32_MAX
-#endif // _WIN64 ]
-
-// 7.18.2.5 Limits of greatest-width integer types
-#define INTMAX_MIN   INT64_MIN
-#define INTMAX_MAX   INT64_MAX
-#define UINTMAX_MAX  UINT64_MAX
-
-// 7.18.3 Limits of other integer types
-
-#ifdef _WIN64 // [
-#  define PTRDIFF_MIN  _I64_MIN
-#  define PTRDIFF_MAX  _I64_MAX
-#else  // _WIN64 ][
-#  define PTRDIFF_MIN  _I32_MIN
-#  define PTRDIFF_MAX  _I32_MAX
-#endif  // _WIN64 ]
-
-#define SIG_ATOMIC_MIN  INT_MIN
-#define SIG_ATOMIC_MAX  INT_MAX
-
-#ifndef SIZE_MAX // [
-#  ifdef _WIN64 // [
-#     define SIZE_MAX  _UI64_MAX
-#  else // _WIN64 ][
-#     define SIZE_MAX  _UI32_MAX
-#  endif // _WIN64 ]
-#endif // SIZE_MAX ]
-
-// WCHAR_MIN and WCHAR_MAX are also defined in <wchar.h>
-#ifndef WCHAR_MIN // [
-#  define WCHAR_MIN  0
-#endif  // WCHAR_MIN ]
-#ifndef WCHAR_MAX // [
-#  define WCHAR_MAX  _UI16_MAX
-#endif  // WCHAR_MAX ]
-
-#define WINT_MIN  0
-#define WINT_MAX  _UI16_MAX
-
-#endif // __STDC_LIMIT_MACROS ]
-
-
-// 7.18.4 Limits of other integer types
-
-#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS) // [   See footnote 224 at page 260
-
-// 7.18.4.1 Macros for minimum-width integer constants
-
-#define INT8_C(val)  val##i8
-#define INT16_C(val) val##i16
-#define INT32_C(val) val##i32
-#define INT64_C(val) val##i64
-
-#define UINT8_C(val)  val##ui8
-#define UINT16_C(val) val##ui16
-#define UINT32_C(val) val##ui32
-#define UINT64_C(val) val##ui64
-
-// 7.18.4.2 Macros for greatest-width integer constants
-#define INTMAX_C   INT64_C
-#define UINTMAX_C  UINT64_C
-
-#endif // __STDC_CONSTANT_MACROS ]
-
-
-#endif // _MSC_STDINT_H_ ]
diff --git a/include/uv/unix.h b/include/uv/unix.h
index 3a131638..2433f681 100644
--- a/include/uv/unix.h
+++ b/include/uv/unix.h
@@ -123,7 +123,6 @@ typedef struct uv_buf_t {
   size_t len;
 } uv_buf_t;
 
-typedef int uv_file;
 typedef int uv_os_sock_t;
 typedef int uv_os_fd_t;
 typedef pid_t uv_pid_t;
@@ -142,21 +141,12 @@ typedef pthread_key_t uv_key_t;
 #if defined(_AIX) || \
     defined(__OpenBSD__) || \
     !defined(PTHREAD_BARRIER_SERIAL_THREAD)
-/* TODO(bnoordhuis) Merge into uv_barrier_t in v2. */
-struct _uv_barrier {
+typedef struct {
   uv_mutex_t mutex;
   uv_cond_t cond;
   unsigned threshold;
   unsigned in;
   unsigned out;
-};
-
-typedef struct {
-  struct _uv_barrier* b;
-# if defined(PTHREAD_BARRIER_SERIAL_THREAD)
-  /* TODO(bnoordhuis) Remove padding in v2. */
-  char pad[sizeof(pthread_barrier_t) - sizeof(struct _uv_barrier*)];
-# endif
 } uv_barrier_t;
 #else
 typedef pthread_barrier_t uv_barrier_t;
@@ -358,7 +348,7 @@ typedef struct {
 
 #define UV_FS_PRIVATE_FIELDS                                                  \
   const char *new_path;                                                       \
-  uv_file file;                                                               \
+  uv_os_fd_t file;                                                            \
   int flags;                                                                  \
   mode_t mode;                                                                \
   unsigned int nbufs;                                                         \
@@ -366,6 +356,7 @@ typedef struct {
   off_t off;                                                                  \
   uv_uid_t uid;                                                               \
   uv_gid_t gid;                                                               \
+  double btime;                                                               \
   double atime;                                                               \
   double mtime;                                                               \
   struct uv__work work_req;                                                   \
diff --git a/include/uv/version.h b/include/uv/version.h
index 3219e963..e5e1cb45 100644
--- a/include/uv/version.h
+++ b/include/uv/version.h
@@ -30,11 +30,11 @@
  * not UV_VERSION_PATCH.)
  */
 
-#define UV_VERSION_MAJOR 1
-#define UV_VERSION_MINOR 39
+#define UV_VERSION_MAJOR 2
+#define UV_VERSION_MINOR 0
 #define UV_VERSION_PATCH 0
-#define UV_VERSION_IS_RELEASE 1
-#define UV_VERSION_SUFFIX ""
+#define UV_VERSION_IS_RELEASE 0
+#define UV_VERSION_SUFFIX "dev"
 
 #define UV_VERSION_HEX  ((UV_VERSION_MAJOR << 16) | \
                          (UV_VERSION_MINOR <<  8) | \
diff --git a/include/uv/win.h b/include/uv/win.h
index f5f1d3a3..8a9ac7a5 100644
--- a/include/uv/win.h
+++ b/include/uv/win.h
@@ -19,10 +19,6 @@
  * IN THE SOFTWARE.
  */
 
-#ifndef _WIN32_WINNT
-# define _WIN32_WINNT   0x0600
-#endif
-
 #if !defined(_SSIZE_T_) && !defined(_SSIZE_T_DEFINED)
 typedef intptr_t ssize_t;
 # define SSIZE_MAX INTPTR_MAX
@@ -32,14 +28,6 @@ typedef intptr_t ssize_t;
 
 #include <winsock2.h>
 
-#if defined(__MINGW32__) && !defined(__MINGW64_VERSION_MAJOR)
-typedef struct pollfd {
-  SOCKET fd;
-  short  events;
-  short  revents;
-} WSAPOLLFD, *PWSAPOLLFD, *LPWSAPOLLFD;
-#endif
-
 #ifndef LOCALE_INVARIANT
 # define LOCALE_INVARIANT 0x007f
 #endif
@@ -48,16 +36,7 @@ typedef struct pollfd {
 #include <ws2tcpip.h>
 #include <windows.h>
 
-#include <process.h>
-#include <signal.h>
-#include <fcntl.h>
-#include <sys/stat.h>
-
-#if defined(_MSC_VER) && _MSC_VER < 1600
-# include "uv/stdint-msvc2008.h"
-#else
-# include <stdint.h>
-#endif
+#include <stdint.h>
 
 #include "uv/tree.h"
 #include "uv/threadpool.h"
@@ -68,23 +47,17 @@ typedef struct pollfd {
 # define S_IFLNK 0xA000
 #endif
 
-/* Additional signals supported by uv_signal and or uv_kill. The CRT defines
- * the following signals already:
- *
- *   #define SIGINT           2
- *   #define SIGILL           4
- *   #define SIGABRT_COMPAT   6
- *   #define SIGFPE           8
- *   #define SIGSEGV         11
- *   #define SIGTERM         15
- *   #define SIGBREAK        21
- *   #define SIGABRT         22
- *
- * The additional signals have values that are common on other Unix
- * variants (Linux and Darwin)
- */
+/* Signals supported by uv_signal and or uv_kill */
 #define SIGHUP                1
+#define SIGINT                2
+#define SIGILL                4
+#define SIGABRT_COMPAT        6
+#define SIGFPE                8
 #define SIGKILL               9
+#define SIGSEGV              11
+#define SIGTERM              15
+#define SIGBREAK             21
+#define SIGABRT              22
 #define SIGWINCH             28
 
 /* Redefine NSIG to take SIGWINCH into consideration */
@@ -95,85 +68,6 @@ typedef struct pollfd {
 # define NSIG SIGWINCH + 1
 #endif
 
-/* The CRT defines SIGABRT_COMPAT as 6, which equals SIGABRT on many unix-like
- * platforms. However MinGW doesn't define it, so we do. */
-#ifndef SIGABRT_COMPAT
-# define SIGABRT_COMPAT       6
-#endif
-
-/*
- * Guids and typedefs for winsock extension functions
- * Mingw32 doesn't have these :-(
- */
-#ifndef WSAID_ACCEPTEX
-# define WSAID_ACCEPTEX                                                       \
-         {0xb5367df1, 0xcbac, 0x11cf,                                         \
-         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}
-
-# define WSAID_CONNECTEX                                                      \
-         {0x25a207b9, 0xddf3, 0x4660,                                         \
-         {0x8e, 0xe9, 0x76, 0xe5, 0x8c, 0x74, 0x06, 0x3e}}
-
-# define WSAID_GETACCEPTEXSOCKADDRS                                           \
-         {0xb5367df2, 0xcbac, 0x11cf,                                         \
-         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}
-
-# define WSAID_DISCONNECTEX                                                   \
-         {0x7fda2e11, 0x8630, 0x436f,                                         \
-         {0xa0, 0x31, 0xf5, 0x36, 0xa6, 0xee, 0xc1, 0x57}}
-
-# define WSAID_TRANSMITFILE                                                   \
-         {0xb5367df0, 0xcbac, 0x11cf,                                         \
-         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}
-
-  typedef BOOL (PASCAL *LPFN_ACCEPTEX)
-                      (SOCKET sListenSocket,
-                       SOCKET sAcceptSocket,
-                       PVOID lpOutputBuffer,
-                       DWORD dwReceiveDataLength,
-                       DWORD dwLocalAddressLength,
-                       DWORD dwRemoteAddressLength,
-                       LPDWORD lpdwBytesReceived,
-                       LPOVERLAPPED lpOverlapped);
-
-  typedef BOOL (PASCAL *LPFN_CONNECTEX)
-                      (SOCKET s,
-                       const struct sockaddr* name,
-                       int namelen,
-                       PVOID lpSendBuffer,
-                       DWORD dwSendDataLength,
-                       LPDWORD lpdwBytesSent,
-                       LPOVERLAPPED lpOverlapped);
-
-  typedef void (PASCAL *LPFN_GETACCEPTEXSOCKADDRS)
-                      (PVOID lpOutputBuffer,
-                       DWORD dwReceiveDataLength,
-                       DWORD dwLocalAddressLength,
-                       DWORD dwRemoteAddressLength,
-                       LPSOCKADDR* LocalSockaddr,
-                       LPINT LocalSockaddrLength,
-                       LPSOCKADDR* RemoteSockaddr,
-                       LPINT RemoteSockaddrLength);
-
-  typedef BOOL (PASCAL *LPFN_DISCONNECTEX)
-                      (SOCKET hSocket,
-                       LPOVERLAPPED lpOverlapped,
-                       DWORD dwFlags,
-                       DWORD reserved);
-
-  typedef BOOL (PASCAL *LPFN_TRANSMITFILE)
-                      (SOCKET hSocket,
-                       HANDLE hFile,
-                       DWORD nNumberOfBytesToWrite,
-                       DWORD nNumberOfBytesPerSend,
-                       LPOVERLAPPED lpOverlapped,
-                       LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
-                       DWORD dwFlags);
-
-  typedef PVOID RTL_SRWLOCK;
-  typedef RTL_SRWLOCK SRWLOCK, *PSRWLOCK;
-#endif
-
 typedef int (WSAAPI* LPFN_WSARECV)
             (SOCKET socket,
              LPWSABUF buffers,
@@ -228,7 +122,6 @@ typedef struct uv_buf_t {
   char* base;
 } uv_buf_t;
 
-typedef int uv_file;
 typedef SOCKET uv_os_sock_t;
 typedef HANDLE uv_os_fd_t;
 typedef int uv_pid_t;
@@ -239,38 +132,12 @@ typedef HANDLE uv_sem_t;
 
 typedef CRITICAL_SECTION uv_mutex_t;
 
-/* This condition variable implementation is based on the SetEvent solution
- * (section 3.2) at http://www.cs.wustl.edu/~schmidt/win32-cv-1.html
- * We could not use the SignalObjectAndWait solution (section 3.4) because
- * it want the 2nd argument (type uv_mutex_t) of uv_cond_wait() and
- * uv_cond_timedwait() to be HANDLEs, but we use CRITICAL_SECTIONs.
- */
+typedef CONDITION_VARIABLE uv_cond_t;
 
-typedef union {
-  CONDITION_VARIABLE cond_var;
-  struct {
-    unsigned int waiters_count;
-    CRITICAL_SECTION waiters_count_lock;
-    HANDLE signal_event;
-    HANDLE broadcast_event;
-  } unused_; /* TODO: retained for ABI compatibility; remove me in v2.x. */
-} uv_cond_t;
-
-typedef union {
-  struct {
-    unsigned int num_readers_;
-    CRITICAL_SECTION num_readers_lock_;
-    HANDLE write_semaphore_;
-  } state_;
-  /* TODO: remove me in v2.x. */
-  struct {
-    SRWLOCK unused_;
-  } unused1_;
-  /* TODO: remove me in v2.x. */
-  struct {
-    uv_mutex_t unused1_;
-    uv_mutex_t unused2_;
-  } unused2_;
+typedef struct {
+  unsigned int num_readers_;
+  CRITICAL_SECTION num_readers_lock_;
+  HANDLE write_semaphore_;
 } uv_rwlock_t;
 
 typedef struct {
@@ -333,31 +200,27 @@ typedef struct {
   uv_req_t* pending_reqs_tail;                                                \
   /* Head of a single-linked list of closed handles */                        \
   uv_handle_t* endgame_handles;                                               \
-  /* TODO(bnoordhuis) Stop heap-allocating |timer_heap| in libuv v2.x. */     \
-  void* timer_heap;                                                           \
-    /* Lists of active loop (prepare / check / idle) watchers */              \
-  uv_prepare_t* prepare_handles;                                              \
-  uv_check_t* check_handles;                                                  \
-  uv_idle_t* idle_handles;                                                    \
-  /* This pointer will refer to the prepare/check/idle handle whose */        \
-  /* callback is scheduled to be called next. This is needed to allow */      \
-  /* safe removal from one of the lists above while that list being */        \
-  /* iterated over. */                                                        \
-  uv_prepare_t* next_prepare_handle;                                          \
-  uv_check_t* next_check_handle;                                              \
-  uv_idle_t* next_idle_handle;                                                \
+  /* Timers */                                                                \
+  struct {                                                                    \
+    void* min;                                                                \
+    unsigned int nelts;                                                       \
+  } timer_heap;                                                               \
+  uint64_t timer_counter;                                                     \
+  /* Lists of active loop (prepare / check / idle) watchers */                \
+  void* prepare_handles[2];                                                   \
+  void* check_handles[2];                                                     \
+  void* idle_handles[2];                                                      \
   /* This handle holds the peer sockets for the fast variant of uv_poll_t */  \
   SOCKET poll_peer_sockets[UV_MSAFD_PROVIDER_COUNT];                          \
-  /* Counter to keep track of active tcp streams */                           \
-  unsigned int active_tcp_streams;                                            \
-  /* Counter to keep track of active udp streams */                           \
-  unsigned int active_udp_streams;                                            \
-  /* Counter to started timer */                                              \
-  uint64_t timer_counter;                                                     \
   /* Threadpool */                                                            \
   void* wq[2];                                                                \
   uv_mutex_t wq_mutex;                                                        \
-  uv_async_t wq_async;
+  uv_async_t wq_async;                                                        \
+  /* Async handle */                                                          \
+  struct uv_req_s async_req;                                                  \
+  void* async_handles[2];                                                     \
+  /* Global queue of loops */                                                 \
+  void* loops_queue[2];
 
 #define UV_REQ_TYPE_PRIVATE                                                   \
   /* TODO: remove the req suffix */                                           \
@@ -440,7 +303,8 @@ typedef struct {
   LPFN_ACCEPTEX func_acceptex;
 
 #define uv_tcp_connection_fields                                              \
-  uv_buf_t read_buffer;                                                       \
+  uv_tcp_accept_t* dummy1; /* Mirror of union field, keep as NULL */          \
+  unsigned int dummy2; /* Mirror of union field, keep as 0 */                 \
   LPFN_CONNECTEX func_connectex;
 
 #define UV_TCP_PRIVATE_FIELDS                                                 \
@@ -456,7 +320,6 @@ typedef struct {
   unsigned int reqs_pending;                                                  \
   int activecnt;                                                              \
   uv_req_t recv_req;                                                          \
-  uv_buf_t recv_buffer;                                                       \
   struct sockaddr_storage recv_from;                                          \
   int recv_from_len;                                                          \
   uv_udp_recv_cb recv_cb;                                                     \
@@ -471,11 +334,9 @@ typedef struct {
 
 #define uv_pipe_connection_fields                                             \
   uv_timer_t* eof_timer;                                                      \
-  uv_write_t dummy; /* TODO: retained for ABI compat; remove this in v2.x. */ \
   DWORD ipc_remote_pid;                                                       \
-  union {                                                                     \
+  struct {                                                                    \
     uint32_t payload_remaining;                                               \
-    uint64_t dummy; /* TODO: retained for ABI compat; remove this in v2.x. */ \
   } ipc_data_frame;                                                           \
   void* ipc_xfer_queue[2];                                                    \
   int ipc_xfer_queue_length;                                                  \
@@ -498,8 +359,6 @@ typedef struct {
   union {                                                                     \
     struct {                                                                  \
       /* Used for readable TTY handles */                                     \
-      /* TODO: remove me in v2.x. */                                          \
-      HANDLE unused_;                                                         \
       uv_buf_t read_line_buffer;                                              \
       HANDLE read_raw_wait;                                                   \
       /* Fields used for translating win keystrokes into vt100 characters */  \
@@ -541,32 +400,27 @@ typedef struct {
   unsigned char events;
 
 #define UV_TIMER_PRIVATE_FIELDS                                               \
+  uv_timer_cb timer_cb;                                                       \
   void* heap_node[3];                                                         \
-  int unused;                                                                 \
   uint64_t timeout;                                                           \
   uint64_t repeat;                                                            \
-  uint64_t start_id;                                                          \
-  uv_timer_cb timer_cb;
+  uint64_t start_id;
 
 #define UV_ASYNC_PRIVATE_FIELDS                                               \
-  struct uv_req_s async_req;                                                  \
+  void* queue[2];                                                             \
   uv_async_cb async_cb;                                                       \
-  /* char to avoid alignment issues */                                        \
-  char volatile async_sent;
+  LONG volatile async_sent;
 
 #define UV_PREPARE_PRIVATE_FIELDS                                             \
-  uv_prepare_t* prepare_prev;                                                 \
-  uv_prepare_t* prepare_next;                                                 \
+  void* queue[2];                                                             \
   uv_prepare_cb prepare_cb;
 
 #define UV_CHECK_PRIVATE_FIELDS                                               \
-  uv_check_t* check_prev;                                                     \
-  uv_check_t* check_next;                                                     \
+  void* queue[2];                                                             \
   uv_check_cb check_cb;
 
 #define UV_IDLE_PRIVATE_FIELDS                                                \
-  uv_idle_t* idle_prev;                                                       \
-  uv_idle_t* idle_next;                                                       \
+  void* queue[2];                                                             \
   uv_idle_cb idle_cb;
 
 #define UV_HANDLE_PRIVATE_FIELDS                                              \
@@ -612,20 +466,21 @@ typedef struct {
   union {                                                                     \
     /* TODO: remove me in 0.9. */                                             \
     WCHAR* pathw;                                                             \
-    int fd;                                                                   \
+    HANDLE hFile;                                                             \
   } file;                                                                     \
   union {                                                                     \
     struct {                                                                  \
       int mode;                                                               \
       WCHAR* new_pathw;                                                       \
       int file_flags;                                                         \
-      int fd_out;                                                             \
+      HANDLE hFile_out;                                                       \
       unsigned int nbufs;                                                     \
       uv_buf_t* bufs;                                                         \
       int64_t offset;                                                         \
       uv_buf_t bufsml[4];                                                     \
     } info;                                                                   \
     struct {                                                                  \
+      double btime;                                                           \
       double atime;                                                           \
       double mtime;                                                           \
     } time;                                                                   \
@@ -665,18 +520,18 @@ typedef struct {
 #endif
 
 /* fs open() flags supported on this platform: */
-#define UV_FS_O_APPEND       _O_APPEND
-#define UV_FS_O_CREAT        _O_CREAT
-#define UV_FS_O_EXCL         _O_EXCL
+#define UV_FS_O_APPEND       0x0008
+#define UV_FS_O_CREAT        0x0100
+#define UV_FS_O_EXCL         0x0400
 #define UV_FS_O_FILEMAP      0x20000000
-#define UV_FS_O_RANDOM       _O_RANDOM
-#define UV_FS_O_RDONLY       _O_RDONLY
-#define UV_FS_O_RDWR         _O_RDWR
-#define UV_FS_O_SEQUENTIAL   _O_SEQUENTIAL
-#define UV_FS_O_SHORT_LIVED  _O_SHORT_LIVED
-#define UV_FS_O_TEMPORARY    _O_TEMPORARY
-#define UV_FS_O_TRUNC        _O_TRUNC
-#define UV_FS_O_WRONLY       _O_WRONLY
+#define UV_FS_O_RANDOM       0x0010
+#define UV_FS_O_RDONLY       0x0000
+#define UV_FS_O_RDWR         0x0002
+#define UV_FS_O_SEQUENTIAL   0x0020
+#define UV_FS_O_SHORT_LIVED  0x1000
+#define UV_FS_O_TEMPORARY    0x0040
+#define UV_FS_O_TRUNC        0x0200
+#define UV_FS_O_WRONLY       0x0001
 
 /* fs open() flags supported on other platforms (or mapped on this platform): */
 #define UV_FS_O_DIRECT       0x02000000 /* FILE_FLAG_NO_BUFFERING */
diff --git a/src/inet.c b/src/inet.c
index 698ab232..1ed96d99 100644
--- a/src/inet.c
+++ b/src/inet.c
@@ -17,12 +17,7 @@
 
 #include <stdio.h>
 #include <string.h>
-
-#if defined(_MSC_VER) && _MSC_VER < 1600
-# include "uv/stdint-msvc2008.h"
-#else
-# include <stdint.h>
-#endif
+#include <stdint.h>
 
 #include "uv.h"
 #include "uv-common.h"
diff --git a/src/unix/loop-watcher.c b/src/loop-watcher.c
similarity index 99%
rename from src/unix/loop-watcher.c
rename to src/loop-watcher.c
index b8c1c2a7..a3d9cc09 100644
--- a/src/unix/loop-watcher.c
+++ b/src/loop-watcher.c
@@ -20,7 +20,7 @@
  */
 
 #include "uv.h"
-#include "internal.h"
+#include "uv-common.h"
 
 #define UV_LOOP_WATCHER_DEFINE(name, type)                                    \
   int uv_##name##_init(uv_loop_t* loop, uv_##name##_t* handle) {              \
diff --git a/src/random.c b/src/random.c
index 491bf703..d972abec 100644
--- a/src/random.c
+++ b/src/random.c
@@ -107,7 +107,6 @@ int uv_random(uv_loop_t* loop,
     return uv__random(buf, buflen);
 
   uv__req_init(loop, req, UV_RANDOM);
-  req->loop = loop;
   req->status = 0;
   req->cb = cb;
   req->buf = buf;
diff --git a/src/threadpool.c b/src/threadpool.c
index 0998938f..9aadcdd4 100644
--- a/src/threadpool.c
+++ b/src/threadpool.c
@@ -185,7 +185,7 @@ void uv__threadpool_cleanup(void) {
 }
 
 
-static void init_threads(void) {
+static void init_once(void) {
   unsigned int i;
   const char* val;
   uv_sem_t sem;
@@ -232,27 +232,6 @@ static void init_threads(void) {
 }
 
 
-#ifndef _WIN32
-static void reset_once(void) {
-  uv_once_t child_once = UV_ONCE_INIT;
-  memcpy(&once, &child_once, sizeof(child_once));
-}
-#endif
-
-
-static void init_once(void) {
-#ifndef _WIN32
-  /* Re-initialize the threadpool after fork.
-   * Note that this discards the global mutex and condition as well
-   * as the work queue.
-   */
-  if (pthread_atfork(NULL, NULL, &reset_once))
-    abort();
-#endif
-  init_threads();
-}
-
-
 void uv__work_submit(uv_loop_t* loop,
                      struct uv__work* w,
                      enum uv__work_kind kind,
@@ -343,7 +322,6 @@ int uv_queue_work(uv_loop_t* loop,
     return UV_EINVAL;
 
   uv__req_init(loop, req, UV_WORK);
-  req->loop = loop;
   req->work_cb = work_cb;
   req->after_work_cb = after_work_cb;
   uv__work_submit(loop,
diff --git a/src/timer.c b/src/timer.c
index 4cf4ed42..b69dc171 100644
--- a/src/timer.c
+++ b/src/timer.c
@@ -26,15 +26,6 @@
 #include <limits.h>
 
 
-static struct heap *timer_heap(const uv_loop_t* loop) {
-#ifdef _WIN32
-  return (struct heap*) loop->timer_heap;
-#else
-  return (struct heap*) &loop->timer_heap;
-#endif
-}
-
-
 static int timer_less_than(const struct heap_node* ha,
                            const struct heap_node* hb) {
   const uv_timer_t* a;
@@ -85,7 +76,7 @@ int uv_timer_start(uv_timer_t* handle,
   /* start_id is the second index to be compared in timer_less_than() */
   handle->start_id = handle->loop->timer_counter++;
 
-  heap_insert(timer_heap(handle->loop),
+  heap_insert((struct heap*) &handle->loop->timer_heap,
               (struct heap_node*) &handle->heap_node,
               timer_less_than);
   uv__handle_start(handle);
@@ -98,7 +89,7 @@ int uv_timer_stop(uv_timer_t* handle) {
   if (!uv__is_active(handle))
     return 0;
 
-  heap_remove(timer_heap(handle->loop),
+  heap_remove((struct heap*) &handle->loop->timer_heap,
               (struct heap_node*) &handle->heap_node,
               timer_less_than);
   uv__handle_stop(handle);
@@ -108,13 +99,10 @@ int uv_timer_stop(uv_timer_t* handle) {
 
 
 int uv_timer_again(uv_timer_t* handle) {
-  if (handle->timer_cb == NULL)
+  if (handle->timer_cb == NULL || handle->repeat == 0)
     return UV_EINVAL;
 
-  if (handle->repeat) {
-    uv_timer_stop(handle);
-    uv_timer_start(handle, handle->timer_cb, handle->repeat, handle->repeat);
-  }
+  uv_timer_start(handle, handle->timer_cb, handle->repeat, handle->repeat);
 
   return 0;
 }
@@ -135,7 +123,7 @@ int uv__next_timeout(const uv_loop_t* loop) {
   const uv_timer_t* handle;
   uint64_t diff;
 
-  heap_node = heap_min(timer_heap(loop));
+  heap_node = heap_min((const struct heap*) &loop->timer_heap);
   if (heap_node == NULL)
     return -1; /* block indefinitely */
 
@@ -156,7 +144,7 @@ void uv__run_timers(uv_loop_t* loop) {
   uv_timer_t* handle;
 
   for (;;) {
-    heap_node = heap_min(timer_heap(loop));
+    heap_node = heap_min((struct heap*) &loop->timer_heap);
     if (heap_node == NULL)
       break;
 
diff --git a/src/unix/aix.c b/src/unix/aix.c
index 6a013d43..976e7981 100644
--- a/src/unix/aix.c
+++ b/src/unix/aix.c
@@ -105,13 +105,6 @@ void uv__platform_loop_delete(uv_loop_t* loop) {
 }
 
 
-int uv__io_fork(uv_loop_t* loop) {
-  uv__platform_loop_delete(loop);
-
-  return uv__platform_loop_init(loop);
-}
-
-
 int uv__io_check_fd(uv_loop_t* loop, int fd) {
   struct poll_ctl pc;
 
diff --git a/src/unix/async.c b/src/unix/async.c
index 5f58fb88..2b1e0e8e 100644
--- a/src/unix/async.c
+++ b/src/unix/async.c
@@ -214,7 +214,7 @@ static int uv__async_start(uv_loop_t* loop) {
   pipefd[0] = err;
   pipefd[1] = -1;
 #else
-  err = uv__make_pipe(pipefd, UV__F_NONBLOCK);
+  err = uv__make_pipe(pipefd, UV_NONBLOCK_PIPE);
   if (err < 0)
     return err;
 #endif
@@ -227,16 +227,6 @@ static int uv__async_start(uv_loop_t* loop) {
 }
 
 
-int uv__async_fork(uv_loop_t* loop) {
-  if (loop->async_io_watcher.fd == -1) /* never started */
-    return 0;
-
-  uv__async_stop(loop);
-
-  return uv__async_start(loop);
-}
-
-
 void uv__async_stop(uv_loop_t* loop) {
   if (loop->async_io_watcher.fd == -1)
     return;
diff --git a/src/unix/core.c b/src/unix/core.c
index 1597828c..48b23111 100644
--- a/src/unix/core.c
+++ b/src/unix/core.c
@@ -40,6 +40,7 @@
 #include <sys/uio.h> /* writev */
 #include <sys/resource.h> /* getrusage */
 #include <pwd.h>
+#include <sched.h>
 #include <sys/utsname.h>
 #include <sys/time.h>
 
@@ -71,6 +72,8 @@ extern char** environ;
 # include <sys/sysctl.h>
 # include <sys/filio.h>
 # include <sys/wait.h>
+# include <sys/param.h>
+# include <sys/cpuset.h>
 # if defined(__FreeBSD__)
 #  define uv__accept4 accept4
 # endif
@@ -90,15 +93,6 @@ extern char** environ;
 
 static int uv__run_pending(uv_loop_t* loop);
 
-/* Verify that uv_buf_t is ABI-compatible with struct iovec. */
-STATIC_ASSERT(sizeof(uv_buf_t) == sizeof(struct iovec));
-STATIC_ASSERT(sizeof(&((uv_buf_t*) 0)->base) ==
-              sizeof(((struct iovec*) 0)->iov_base));
-STATIC_ASSERT(sizeof(&((uv_buf_t*) 0)->len) ==
-              sizeof(((struct iovec*) 0)->iov_len));
-STATIC_ASSERT(offsetof(uv_buf_t, base) == offsetof(struct iovec, iov_base));
-STATIC_ASSERT(offsetof(uv_buf_t, len) == offsetof(struct iovec, iov_len));
-
 
 uint64_t uv_hrtime(void) {
   return uv__hrtime(UV_CLOCK_PRECISE);
@@ -325,7 +319,7 @@ int uv_is_closing(const uv_handle_t* handle) {
 }
 
 
-int uv_backend_fd(const uv_loop_t* loop) {
+uv_os_fd_t uv_backend_fd(const uv_loop_t* loop) {
   return loop->backend_fd;
 }
 
@@ -1152,6 +1146,7 @@ int uv__getpwuid_r(uv_passwd_t* pwd) {
   size_t name_size;
   size_t homedir_size;
   size_t shell_size;
+  size_t gecos_size;
   long initsize;
   int r;
 
@@ -1193,11 +1188,24 @@ int uv__getpwuid_r(uv_passwd_t* pwd) {
     return UV_ENOENT;
   }
 
-  /* Allocate memory for the username, shell, and home directory */
+  /* Allocate memory for the username, gecos, shell, and home directory. */
   name_size = strlen(pw.pw_name) + 1;
   homedir_size = strlen(pw.pw_dir) + 1;
   shell_size = strlen(pw.pw_shell) + 1;
-  pwd->username = uv__malloc(name_size + homedir_size + shell_size);
+
+#ifdef __MVS__
+  gecos_size = 0; /* pw_gecos does not exist on zOS. */
+#else
+  if (pw.pw_gecos != NULL)
+    gecos_size = strlen(pw.pw_gecos) + 1;
+  else
+    gecos_size = 0;
+#endif
+
+  pwd->username = uv__malloc(name_size +
+                             homedir_size +
+                             shell_size +
+                             gecos_size);
 
   if (pwd->username == NULL) {
     uv__free(buf);
@@ -1215,6 +1223,18 @@ int uv__getpwuid_r(uv_passwd_t* pwd) {
   pwd->shell = pwd->homedir + homedir_size;
   memcpy(pwd->shell, pw.pw_shell, shell_size);
 
+  /* Copy the gecos field */
+#ifdef __MVS__
+  pwd->gecos = NULL;  /* pw_gecos does not exist on zOS. */
+#else
+  if (pw.pw_gecos == NULL) {
+    pwd->gecos = NULL;
+  } else {
+    pwd->gecos = pwd->shell + shell_size;
+    memcpy(pwd->gecos, pw.pw_gecos, gecos_size);
+  }
+#endif
+
   /* Copy the uid and gid */
   pwd->uid = pw.pw_uid;
   pwd->gid = pw.pw_gid;
@@ -1230,7 +1250,7 @@ void uv_os_free_passwd(uv_passwd_t* pwd) {
     return;
 
   /*
-    The memory for name, shell, and homedir are allocated in a single
+    The memory for name, shell, homedir, and gecos are allocated in a single
     uv__malloc() call. The base of the pointer is stored in pwd->username, so
     that is the field that needs to be freed.
   */
@@ -1238,6 +1258,7 @@ void uv_os_free_passwd(uv_passwd_t* pwd) {
   pwd->username = NULL;
   pwd->shell = NULL;
   pwd->homedir = NULL;
+  pwd->gecos = NULL;
 }
 
 
@@ -1386,14 +1407,6 @@ int uv_os_gethostname(char* buffer, size_t* size) {
 }
 
 
-uv_os_fd_t uv_get_osfhandle(int fd) {
-  return fd;
-}
-
-int uv_open_osfhandle(uv_os_fd_t os_fd) {
-  return os_fd;
-}
-
 uv_pid_t uv_os_getpid(void) {
   return getpid();
 }
@@ -1403,6 +1416,13 @@ uv_pid_t uv_os_getppid(void) {
   return getppid();
 }
 
+int uv_cpumask_size(void) {
+#if defined(__linux__) || defined(__FreeBSD__)
+  return CPU_SETSIZE;
+#else
+  return UV_ENOTSUP;
+#endif
+}
 
 int uv_os_getpriority(uv_pid_t pid, int* priority) {
   int r;
diff --git a/src/unix/fs.c b/src/unix/fs.c
index 87cb8b81..cd3c5fc6 100644
--- a/src/unix/fs.c
+++ b/src/unix/fs.c
@@ -30,6 +30,7 @@
 #include "internal.h"
 
 #include <errno.h>
+#include <math.h>
 #include <dlfcn.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -61,7 +62,49 @@
 #endif
 
 #if defined(__APPLE__)
-# include <sys/sysctl.h>
+# include <sys/attr.h>
+
+static void uv__prepare_setattrlist_args(uv_fs_t* req,
+                                         struct attrlist* attr_list,
+                                         struct timespec (*times)[3],
+                                         unsigned int* size) {
+  memset(attr_list, 0, sizeof(*attr_list));
+  memset(times, 0, sizeof(*times));
+
+  attr_list->bitmapcount = ATTR_BIT_MAP_COUNT;
+
+  *size = 0;
+
+  if (!isnan(req->btime)) {
+    attr_list->commonattr |= ATTR_CMN_CRTIME;
+
+    (*times)[*size].tv_sec = req->btime;
+    (*times)[*size].tv_nsec =
+      (unsigned long)(req->btime * 1000000) % 1000000 * 1000;
+
+    ++*size;
+  }
+
+  if (!isnan(req->mtime)) {
+    attr_list->commonattr |= ATTR_CMN_MODTIME;
+
+    (*times)[*size].tv_sec = req->mtime;
+    (*times)[*size].tv_nsec =
+      (unsigned long)(req->mtime * 1000000) % 1000000 * 1000;
+
+    ++*size;
+  }
+
+  if (!isnan(req->atime)) {
+    attr_list->commonattr |= ATTR_CMN_ACCTIME;
+
+    (*times)[*size].tv_sec = req->atime;
+    (*times)[*size].tv_nsec =
+      (unsigned long)(req->atime * 1000000) % 1000000 * 1000;
+
+    ++*size;
+  }
+}
 #elif defined(__linux__) && !defined(FICLONE)
 # include <sys/ioctl.h>
 # define FICLONE _IOW(0x94, 9, int)
@@ -93,11 +136,10 @@ extern char *mkdtemp(char *template); /* See issue #740 on AIX < 7 */
   do {                                                                        \
     if (req == NULL)                                                          \
       return UV_EINVAL;                                                       \
-    UV_REQ_INIT(req, UV_FS);                                                  \
+    UV_REQ_INIT(loop, req, UV_FS);                                            \
     req->fs_type = UV_FS_ ## subtype;                                         \
     req->result = 0;                                                          \
     req->ptr = NULL;                                                          \
-    req->loop = loop;                                                         \
     req->path = NULL;                                                         \
     req->new_path = NULL;                                                     \
     req->bufs = NULL;                                                         \
@@ -156,6 +198,26 @@ extern char *mkdtemp(char *template); /* See issue #740 on AIX < 7 */
   }                                                                           \
   while (0)
 
+#define POST0                                                                 \
+  do {                                                                        \
+    if (cb != NULL) {                                                         \
+      uv__req_register(loop, req);                                            \
+      uv__work_submit(loop,                                                   \
+                      &req->work_req,                                         \
+                      UV__WORK_FAST_IO,                                       \
+                      uv__fs_work,                                            \
+                      uv__fs_done);                                           \
+      return 0;                                                               \
+    }                                                                         \
+    else {                                                                    \
+      uv__fs_work(&req->work_req);                                            \
+      if (req->result < 0)                                                    \
+        return req->result;                                                   \
+      return 0;                                                               \
+    }                                                                         \
+  }                                                                           \
+  while (0)
+
 
 static int uv__fs_close(int fd) {
   int rc;
@@ -230,8 +292,15 @@ static ssize_t uv__fs_futime(uv_fs_t* req) {
   ts[0] = uv__fs_to_timespec(req->atime);
   ts[1] = uv__fs_to_timespec(req->mtime);
   return futimens(req->file, ts);
-#elif defined(__APPLE__)                                                      \
-    || defined(__DragonFly__)                                                 \
+#elif defined(__APPLE__)
+  struct attrlist attr_list;
+  unsigned i;
+  struct timespec times[3];
+
+  uv__prepare_setattrlist_args(req, &attr_list, &times, &i);
+
+  return fsetattrlist(req->file, &attr_list, &times, i * sizeof(times[0]), 0);
+#elif defined(__DragonFly__)                                                  \
     || defined(__FreeBSD__)                                                   \
     || defined(__FreeBSD_kernel__)                                            \
     || defined(__NetBSD__)                                                    \
@@ -385,7 +454,7 @@ static ssize_t uv__fs_open(uv_fs_t* req) {
 
 
 #if !HAVE_PREADV
-static ssize_t uv__fs_preadv(uv_file fd,
+static ssize_t uv__fs_preadv(uv_os_fd_t fd,
                              uv_buf_t* bufs,
                              unsigned int nbufs,
                              off_t off) {
@@ -504,19 +573,12 @@ done:
 }
 
 
-#if defined(__APPLE__) && !defined(MAC_OS_X_VERSION_10_8)
-#define UV_CONST_DIRENT uv__dirent_t
-#else
-#define UV_CONST_DIRENT const uv__dirent_t
-#endif
-
-
-static int uv__fs_scandir_filter(UV_CONST_DIRENT* dent) {
+static int uv__fs_scandir_filter(const uv__dirent_t* dent) {
   return strcmp(dent->d_name, ".") != 0 && strcmp(dent->d_name, "..") != 0;
 }
 
 
-static int uv__fs_scandir_sort(UV_CONST_DIRENT** a, UV_CONST_DIRENT** b) {
+static int uv__fs_scandir_sort(const uv__dirent_t** a, const uv__dirent_t** b) {
   return strcmp((*a)->d_name, (*b)->d_name);
 }
 
@@ -1004,8 +1066,15 @@ static ssize_t uv__fs_utime(uv_fs_t* req) {
   ts[0] = uv__fs_to_timespec(req->atime);
   ts[1] = uv__fs_to_timespec(req->mtime);
   return utimensat(AT_FDCWD, req->path, ts, 0);
-#elif defined(__APPLE__)                                                      \
-    || defined(__DragonFly__)                                                 \
+#elif defined(__APPLE__)
+  struct attrlist attr_list;
+  unsigned i;
+  struct timespec times[3];
+
+  uv__prepare_setattrlist_args(req, &attr_list, &times, &i);
+
+  return setattrlist(req->path, &attr_list, &times, i * sizeof(times[0]), 0);
+#elif defined(__DragonFly__)                                                 \
     || defined(__FreeBSD__)                                                   \
     || defined(__FreeBSD_kernel__)                                            \
     || defined(__NetBSD__)                                                    \
@@ -1122,8 +1191,8 @@ done:
 
 static ssize_t uv__fs_copyfile(uv_fs_t* req) {
   uv_fs_t fs_req;
-  uv_file srcfd;
-  uv_file dstfd;
+  uv_os_fd_t srcfd;
+  uv_os_fd_t dstfd;
   struct stat src_statsbuf;
   struct stat dst_statsbuf;
   int dst_flags;
@@ -1135,14 +1204,15 @@ static ssize_t uv__fs_copyfile(uv_fs_t* req) {
   size_t bytes_chunk;
 
   dstfd = -1;
-  err = 0;
 
   /* Open the source file. */
-  srcfd = uv_fs_open(NULL, &fs_req, req->path, O_RDONLY, 0, NULL);
+  err = uv_fs_open(NULL, &fs_req, req->path, O_RDONLY, 0, NULL);
   uv_fs_req_cleanup(&fs_req);
 
-  if (srcfd < 0)
-    return srcfd;
+  if (err < 0)
+    return err;
+
+  srcfd = fs_req.result;
 
   /* Get the source file's mode. */
   if (fstat(srcfd, &src_statsbuf)) {
@@ -1156,7 +1226,7 @@ static ssize_t uv__fs_copyfile(uv_fs_t* req) {
     dst_flags |= O_EXCL;
 
   /* Open the destination file. */
-  dstfd = uv_fs_open(NULL,
+  err = uv_fs_open(NULL,
                      &fs_req,
                      req->new_path,
                      dst_flags,
@@ -1164,11 +1234,12 @@ static ssize_t uv__fs_copyfile(uv_fs_t* req) {
                      NULL);
   uv_fs_req_cleanup(&fs_req);
 
-  if (dstfd < 0) {
-    err = dstfd;
+  if (err < 0) {
     goto out;
   }
 
+  dstfd = fs_req.result;
+
   /* If the file is not being opened exclusively, verify that the source and
      destination are not the same file. If they are the same, bail out early. */
   if ((req->flags & UV_FS_COPYFILE_EXCL) == 0) {
@@ -1681,7 +1752,7 @@ int uv_fs_chown(uv_loop_t* loop,
 }
 
 
-int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {
+int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t file, uv_fs_cb cb) {
   INIT(CLOSE);
   req->file = file;
   POST;
@@ -1690,7 +1761,7 @@ int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {
 
 int uv_fs_fchmod(uv_loop_t* loop,
                  uv_fs_t* req,
-                 uv_file file,
+                 uv_os_fd_t file,
                  int mode,
                  uv_fs_cb cb) {
   INIT(FCHMOD);
@@ -1702,7 +1773,7 @@ int uv_fs_fchmod(uv_loop_t* loop,
 
 int uv_fs_fchown(uv_loop_t* loop,
                  uv_fs_t* req,
-                 uv_file file,
+                 uv_os_fd_t file,
                  uv_uid_t uid,
                  uv_gid_t gid,
                  uv_fs_cb cb) {
@@ -1728,21 +1799,21 @@ int uv_fs_lchown(uv_loop_t* loop,
 }
 
 
-int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {
+int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t file, uv_fs_cb cb) {
   INIT(FDATASYNC);
   req->file = file;
   POST;
 }
 
 
-int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {
+int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t file, uv_fs_cb cb) {
   INIT(FSTAT);
   req->file = file;
   POST;
 }
 
 
-int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {
+int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t file, uv_fs_cb cb) {
   INIT(FSYNC);
   req->file = file;
   POST;
@@ -1751,7 +1822,7 @@ int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {
 
 int uv_fs_ftruncate(uv_loop_t* loop,
                     uv_fs_t* req,
-                    uv_file file,
+                    uv_os_fd_t file,
                     int64_t off,
                     uv_fs_cb cb) {
   INIT(FTRUNCATE);
@@ -1763,12 +1834,24 @@ int uv_fs_ftruncate(uv_loop_t* loop,
 
 int uv_fs_futime(uv_loop_t* loop,
                  uv_fs_t* req,
-                 uv_file file,
+                 uv_os_fd_t file,
                  double atime,
                  double mtime,
                  uv_fs_cb cb) {
+  return uv_fs_futime_ex(loop, req, file, NAN, atime, mtime, cb);
+}
+
+
+int uv_fs_futime_ex(uv_loop_t* loop,
+                    uv_fs_t* req,
+                    uv_os_fd_t file,
+                    double btime,
+                    double atime,
+                    double mtime,
+                    uv_fs_cb cb) {
   INIT(FUTIME);
   req->file = file;
+  req->btime = btime;
   req->atime = atime;
   req->mtime = mtime;
   POST;
@@ -1838,7 +1921,7 @@ int uv_fs_mkstemp(uv_loop_t* loop,
   req->path = uv__strdup(tpl);
   if (req->path == NULL)
     return UV_ENOMEM;
-  POST;
+  POST0;
 }
 
 
@@ -1852,12 +1935,12 @@ int uv_fs_open(uv_loop_t* loop,
   PATH;
   req->flags = flags;
   req->mode = mode;
-  POST;
+  POST0;
 }
 
 
 int uv_fs_read(uv_loop_t* loop, uv_fs_t* req,
-               uv_file file,
+               uv_os_fd_t file,
                const uv_buf_t bufs[],
                unsigned int nbufs,
                int64_t off,
@@ -1970,8 +2053,8 @@ int uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {
 
 int uv_fs_sendfile(uv_loop_t* loop,
                    uv_fs_t* req,
-                   uv_file out_fd,
-                   uv_file in_fd,
+                   uv_os_fd_t out_fd,
+                   uv_os_fd_t in_fd,
                    int64_t off,
                    size_t len,
                    uv_fs_cb cb) {
@@ -2017,8 +2100,20 @@ int uv_fs_utime(uv_loop_t* loop,
                 double atime,
                 double mtime,
                 uv_fs_cb cb) {
+  return uv_fs_utime_ex(loop, req, path, NAN, atime, mtime, cb);
+}
+
+
+int uv_fs_utime_ex(uv_loop_t* loop,
+                   uv_fs_t* req,
+                   const char* path,
+                   double btime,
+                   double atime,
+                   double mtime,
+                   uv_fs_cb cb) {
   INIT(UTIME);
   PATH;
+  req->btime = btime;
   req->atime = atime;
   req->mtime = mtime;
   POST;
@@ -2027,7 +2122,7 @@ int uv_fs_utime(uv_loop_t* loop,
 
 int uv_fs_write(uv_loop_t* loop,
                 uv_fs_t* req,
-                uv_file file,
+                uv_os_fd_t file,
                 const uv_buf_t bufs[],
                 unsigned int nbufs,
                 int64_t off,
diff --git a/src/unix/getaddrinfo.c b/src/unix/getaddrinfo.c
index d7ca7d1a..123b1409 100644
--- a/src/unix/getaddrinfo.c
+++ b/src/unix/getaddrinfo.c
@@ -181,7 +181,6 @@ int uv_getaddrinfo(uv_loop_t* loop,
     return UV_ENOMEM;
 
   uv__req_init(loop, req, UV_GETADDRINFO);
-  req->loop = loop;
   req->cb = cb;
   req->addrinfo = NULL;
   req->hints = NULL;
diff --git a/src/unix/getnameinfo.c b/src/unix/getnameinfo.c
index 991002a6..f6a591ee 100644
--- a/src/unix/getnameinfo.c
+++ b/src/unix/getnameinfo.c
@@ -103,7 +103,6 @@ int uv_getnameinfo(uv_loop_t* loop,
   req->getnameinfo_cb = getnameinfo_cb;
   req->flags = flags;
   req->type = UV_GETNAMEINFO;
-  req->loop = loop;
   req->retcode = 0;
 
   if (getnameinfo_cb) {
diff --git a/src/unix/internal.h b/src/unix/internal.h
index 9d3c2297..73b79f80 100644
--- a/src/unix/internal.h
+++ b/src/unix/internal.h
@@ -33,10 +33,6 @@
 #include <errno.h>
 #include <sys/socket.h>
 
-#if defined(__STRICT_ANSI__)
-# define inline __inline
-#endif
-
 #if defined(__linux__)
 # include "linux-syscalls.h"
 #endif /* __linux__ */
@@ -203,13 +199,10 @@ void uv__io_feed(uv_loop_t* loop, uv__io_t* w);
 int uv__io_active(const uv__io_t* w, unsigned int events);
 int uv__io_check_fd(uv_loop_t* loop, int fd);
 void uv__io_poll(uv_loop_t* loop, int timeout); /* in milliseconds or -1 */
-int uv__io_fork(uv_loop_t* loop);
 int uv__fd_exists(uv_loop_t* loop, int fd);
 
 /* async */
 void uv__async_stop(uv_loop_t* loop);
-int uv__async_fork(uv_loop_t* loop);
-
 
 /* loop */
 void uv__run_idle(uv_loop_t* loop);
@@ -241,7 +234,6 @@ int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb);
 void uv__signal_close(uv_signal_t* handle);
 void uv__signal_global_once_init(void);
 void uv__signal_loop_cleanup(uv_loop_t* loop);
-int uv__signal_loop_fork(uv_loop_t* loop);
 
 /* platform specific */
 uint64_t uv__hrtime(uv_clocktype_t type);
@@ -252,12 +244,9 @@ void uv__platform_invalidate_fd(uv_loop_t* loop, int fd);
 
 /* various */
 void uv__async_close(uv_async_t* handle);
-void uv__check_close(uv_check_t* handle);
 void uv__fs_event_close(uv_fs_event_t* handle);
-void uv__idle_close(uv_idle_t* handle);
 void uv__pipe_close(uv_pipe_t* handle);
 void uv__poll_close(uv_poll_t* handle);
-void uv__prepare_close(uv_prepare_t* handle);
 void uv__process_close(uv_process_t* handle);
 void uv__stream_close(uv_stream_t* handle);
 void uv__tcp_close(uv_tcp_t* handle);
@@ -282,12 +271,6 @@ int uv___stream_fd(const uv_stream_t* handle);
 #define uv__stream_fd(handle) ((handle)->io_watcher.fd)
 #endif /* defined(__APPLE__) */
 
-#ifdef O_NONBLOCK
-# define UV__F_NONBLOCK O_NONBLOCK
-#else
-# define UV__F_NONBLOCK 1
-#endif
-
 int uv__make_pipe(int fds[2], int flags);
 
 #if defined(__APPLE__)
@@ -314,10 +297,6 @@ UV_UNUSED(static char* uv__basename_r(const char* path)) {
   return s + 1;
 }
 
-#if defined(__linux__)
-int uv__inotify_fork(uv_loop_t* loop, void* old_watchers);
-#endif
-
 typedef int (*uv__peersockfunc)(int, struct sockaddr*, socklen_t*);
 
 int uv__getsockpeername(const uv_handle_t* handle,
diff --git a/src/unix/kqueue.c b/src/unix/kqueue.c
index bf183d5f..98ef8e5e 100644
--- a/src/unix/kqueue.c
+++ b/src/unix/kqueue.c
@@ -59,38 +59,6 @@ int uv__kqueue_init(uv_loop_t* loop) {
 }
 
 
-#if defined(__APPLE__) && MAC_OS_X_VERSION_MAX_ALLOWED >= 1070
-static int uv__has_forked_with_cfrunloop;
-#endif
-
-int uv__io_fork(uv_loop_t* loop) {
-  int err;
-  loop->backend_fd = -1;
-  err = uv__kqueue_init(loop);
-  if (err)
-    return err;
-
-#if defined(__APPLE__) && MAC_OS_X_VERSION_MAX_ALLOWED >= 1070
-  if (loop->cf_state != NULL) {
-    /* We cannot start another CFRunloop and/or thread in the child
-       process; CF aborts if you try or if you try to touch the thread
-       at all to kill it. So the best we can do is ignore it from now
-       on. This means we can't watch directories in the same way
-       anymore (like other BSDs). It also means we cannot properly
-       clean up the allocated resources; calling
-       uv__fsevents_loop_delete from uv_loop_close will crash the
-       process. So we sidestep the issue by pretending like we never
-       started it in the first place.
-    */
-    uv__store_relaxed(&uv__has_forked_with_cfrunloop, 1);
-    uv__free(loop->cf_state);
-    loop->cf_state = NULL;
-  }
-#endif /* #if defined(__APPLE__) && MAC_OS_X_VERSION_MAX_ALLOWED >= 1070 */
-  return err;
-}
-
-
 int uv__io_check_fd(uv_loop_t* loop, int fd) {
   struct kevent ev;
   int rc;
@@ -527,7 +495,7 @@ int uv_fs_event_start(uv_fs_event_t* handle,
   if (!(statbuf.st_mode & S_IFDIR))
     goto fallback;
 
-  if (0 == uv__load_relaxed(&uv__has_forked_with_cfrunloop)) {
+  {
     int r;
     /* The fallback fd is no longer needed */
     uv__close_nocheckstdio(fd);
@@ -562,11 +530,13 @@ int uv_fs_event_stop(uv_fs_event_t* handle) {
   uv__handle_stop(handle);
 
 #if defined(__APPLE__) && MAC_OS_X_VERSION_MAX_ALLOWED >= 1070
-  if (0 == uv__load_relaxed(&uv__has_forked_with_cfrunloop))
-    if (handle->cf_cb != NULL)
-      r = uv__fsevents_close(handle);
+  if (handle->cf_cb != NULL)
+    r = uv__fsevents_close(handle);
 #endif
 
+  uv__free(handle->path);
+  handle->path = NULL;
+
   if (handle->event_watcher.fd != -1) {
     uv__io_close(handle->loop, &handle->event_watcher);
     uv__close(handle->event_watcher.fd);
diff --git a/src/unix/linux-core.c b/src/unix/linux-core.c
index 14d5f0c0..2ef25e04 100644
--- a/src/unix/linux-core.c
+++ b/src/unix/linux-core.c
@@ -108,24 +108,6 @@ int uv__platform_loop_init(uv_loop_t* loop) {
 }
 
 
-int uv__io_fork(uv_loop_t* loop) {
-  int err;
-  void* old_watchers;
-
-  old_watchers = loop->inotify_watchers;
-
-  uv__close(loop->backend_fd);
-  loop->backend_fd = -1;
-  uv__platform_loop_delete(loop);
-
-  err = uv__platform_loop_init(loop);
-  if (err)
-    return err;
-
-  return uv__inotify_fork(loop, old_watchers);
-}
-
-
 void uv__platform_loop_delete(uv_loop_t* loop) {
   if (loop->inotify_fd == -1) return;
   uv__io_stop(loop, &loop->inotify_read_watcher, POLLIN);
@@ -250,14 +232,18 @@ void uv__io_poll(uv_loop_t* loop, int timeout) {
      * events, skip the syscall and squelch the events after epoll_wait().
      */
     if (epoll_ctl(loop->backend_fd, op, w->fd, &e)) {
-      if (errno != EEXIST)
+      if (errno == EPERM) { /* fd is probably a file, which is always ready */
+        w->cb(loop, w, POLLIN | POLLOUT);
+        timeout = 0; /* fd is now likely closed and needs to return to the uv_run loop for cleanup */
+      } else if (errno != EEXIST) {
         abort();
+      } else {
+        assert(op == EPOLL_CTL_ADD);
 
-      assert(op == EPOLL_CTL_ADD);
-
-      /* We've reactivated a file descriptor that's been watched before. */
-      if (epoll_ctl(loop->backend_fd, EPOLL_CTL_MOD, w->fd, &e))
-        abort();
+        /* We've reactivated a file descriptor that's been watched before. */
+        if (epoll_ctl(loop->backend_fd, EPOLL_CTL_MOD, w->fd, &e))
+          abort();
+      }
     }
 
     w->events = w->pevents;
diff --git a/src/unix/linux-inotify.c b/src/unix/linux-inotify.c
index 42b601ad..c4a91063 100644
--- a/src/unix/linux-inotify.c
+++ b/src/unix/linux-inotify.c
@@ -62,8 +62,6 @@ static void uv__inotify_read(uv_loop_t* loop,
                              uv__io_t* w,
                              unsigned int revents);
 
-static void maybe_free_watcher_list(struct watcher_list* w,
-                                    uv_loop_t* loop);
 
 static int init_inotify(uv_loop_t* loop) {
   int fd;
@@ -83,71 +81,6 @@ static int init_inotify(uv_loop_t* loop) {
 }
 
 
-int uv__inotify_fork(uv_loop_t* loop, void* old_watchers) {
-  /* Open the inotify_fd, and re-arm all the inotify watchers. */
-  int err;
-  struct watcher_list* tmp_watcher_list_iter;
-  struct watcher_list* watcher_list;
-  struct watcher_list tmp_watcher_list;
-  QUEUE queue;
-  QUEUE* q;
-  uv_fs_event_t* handle;
-  char* tmp_path;
-
-  if (old_watchers != NULL) {
-    /* We must restore the old watcher list to be able to close items
-     * out of it.
-     */
-    loop->inotify_watchers = old_watchers;
-
-    QUEUE_INIT(&tmp_watcher_list.watchers);
-    /* Note that the queue we use is shared with the start and stop()
-     * functions, making QUEUE_FOREACH unsafe to use. So we use the
-     * QUEUE_MOVE trick to safely iterate. Also don't free the watcher
-     * list until we're done iterating. c.f. uv__inotify_read.
-     */
-    RB_FOREACH_SAFE(watcher_list, watcher_root,
-                    CAST(&old_watchers), tmp_watcher_list_iter) {
-      watcher_list->iterating = 1;
-      QUEUE_MOVE(&watcher_list->watchers, &queue);
-      while (!QUEUE_EMPTY(&queue)) {
-        q = QUEUE_HEAD(&queue);
-        handle = QUEUE_DATA(q, uv_fs_event_t, watchers);
-        /* It's critical to keep a copy of path here, because it
-         * will be set to NULL by stop() and then deallocated by
-         * maybe_free_watcher_list
-         */
-        tmp_path = uv__strdup(handle->path);
-        assert(tmp_path != NULL);
-        QUEUE_REMOVE(q);
-        QUEUE_INSERT_TAIL(&watcher_list->watchers, q);
-        uv_fs_event_stop(handle);
-
-        QUEUE_INSERT_TAIL(&tmp_watcher_list.watchers, &handle->watchers);
-        handle->path = tmp_path;
-      }
-      watcher_list->iterating = 0;
-      maybe_free_watcher_list(watcher_list, loop);
-    }
-
-    QUEUE_MOVE(&tmp_watcher_list.watchers, &queue);
-    while (!QUEUE_EMPTY(&queue)) {
-        q = QUEUE_HEAD(&queue);
-        QUEUE_REMOVE(q);
-        handle = QUEUE_DATA(q, uv_fs_event_t, watchers);
-        tmp_path = handle->path;
-        handle->path = NULL;
-        err = uv_fs_event_start(handle, handle->cb, tmp_path, 0);
-        uv__free(tmp_path);
-        if (err)
-          return err;
-    }
-  }
-
-  return 0;
-}
-
-
 static struct watcher_list* find_watcher(uv_loop_t* loop, int wd) {
   struct watcher_list w;
   w.wd = wd;
diff --git a/src/unix/loop.c b/src/unix/loop.c
index a88e71c3..b1f84301 100644
--- a/src/unix/loop.c
+++ b/src/unix/loop.c
@@ -129,39 +129,6 @@ fail_metrics_mutex_init:
 }
 
 
-int uv_loop_fork(uv_loop_t* loop) {
-  int err;
-  unsigned int i;
-  uv__io_t* w;
-
-  err = uv__io_fork(loop);
-  if (err)
-    return err;
-
-  err = uv__async_fork(loop);
-  if (err)
-    return err;
-
-  err = uv__signal_loop_fork(loop);
-  if (err)
-    return err;
-
-  /* Rearm all the watchers that aren't re-queued by the above. */
-  for (i = 0; i < loop->nwatchers; i++) {
-    w = loop->watchers[i];
-    if (w == NULL)
-      continue;
-
-    if (w->pevents != 0 && QUEUE_EMPTY(&w->watcher_queue)) {
-      w->events = 0; /* Force re-registration in uv__io_poll. */
-      QUEUE_INSERT_TAIL(&loop->watcher_queue, &w->watcher_queue);
-    }
-  }
-
-  return 0;
-}
-
-
 void uv__loop_close(uv_loop_t* loop) {
   uv__loop_internal_fields_t* lfields;
 
diff --git a/src/unix/pipe.c b/src/unix/pipe.c
index 040d5781..5235a630 100644
--- a/src/unix/pipe.c
+++ b/src/unix/pipe.c
@@ -45,8 +45,14 @@ int uv_pipe_bind(uv_pipe_t* handle, const char* name) {
   const char* pipe_fname;
   int sockfd;
   int err;
+  size_t name_len;
 
   pipe_fname = NULL;
+  sockfd = -1;
+  name_len = strlen(name);
+
+  if (name_len > sizeof(saddr.sun_path) - 1)
+    return -ENAMETOOLONG;
 
   /* Already bound? */
   if (uv__stream_fd(handle) >= 0)
@@ -66,7 +72,7 @@ int uv_pipe_bind(uv_pipe_t* handle, const char* name) {
   sockfd = err;
 
   memset(&saddr, 0, sizeof saddr);
-  uv__strscpy(saddr.sun_path, pipe_fname, sizeof(saddr.sun_path));
+  memcpy(saddr.sun_path, pipe_fname, name_len);
   saddr.sun_family = AF_UNIX;
 
   if (bind(sockfd, (struct sockaddr*)&saddr, sizeof saddr)) {
@@ -134,7 +140,7 @@ void uv__pipe_close(uv_pipe_t* handle) {
 }
 
 
-int uv_pipe_open(uv_pipe_t* handle, uv_file fd) {
+int uv_pipe_open(uv_pipe_t* handle, uv_os_fd_t fd) {
   int flags;
   int mode;
   int err;
@@ -178,6 +184,14 @@ void uv_pipe_connect(uv_connect_t* req,
   int new_sock;
   int err;
   int r;
+  size_t name_len;
+
+  name_len = strlen(name);
+  
+  if (name_len > sizeof(saddr.sun_path) - 1) {
+    err = -ENAMETOOLONG;
+    goto out;
+  }
 
   new_sock = (uv__stream_fd(handle) == -1);
 
@@ -189,7 +203,7 @@ void uv_pipe_connect(uv_connect_t* req,
   }
 
   memset(&saddr, 0, sizeof saddr);
-  uv__strscpy(saddr.sun_path, name, sizeof(saddr.sun_path));
+  memcpy(saddr.sun_path, name, name_len);
   saddr.sun_family = AF_UNIX;
 
   do {
@@ -379,3 +393,57 @@ int uv_pipe_chmod(uv_pipe_t* handle, int mode) {
 
   return r != -1 ? 0 : UV__ERR(errno);
 }
+
+
+int uv_pipe(uv_os_fd_t fds[2], int read_flags, int write_flags) {
+  uv_os_fd_t temp[2];
+  int err;
+#if defined(__FreeBSD__) || defined(__linux__)
+  int flags = O_CLOEXEC;
+
+  if ((read_flags & UV_NONBLOCK_PIPE) && (write_flags & UV_NONBLOCK_PIPE))
+    flags |= UV_FS_O_NONBLOCK;
+
+  if (pipe2(temp, flags))
+    return UV__ERR(errno);
+
+  if (flags & UV_FS_O_NONBLOCK) {
+    fds[0] = temp[0];
+    fds[1] = temp[1];
+    return 0;
+  }
+#else
+  if (pipe(temp))
+    return UV__ERR(errno);
+
+  if ((err = uv__cloexec(temp[0], 1)))
+    goto fail;
+
+  if ((err = uv__cloexec(temp[1], 1)))
+    goto fail;
+#endif
+
+  if (read_flags & UV_NONBLOCK_PIPE)
+    if ((err = uv__nonblock(temp[0], 1)))
+      goto fail;
+
+  if (write_flags & UV_NONBLOCK_PIPE)
+    if ((err = uv__nonblock(temp[1], 1)))
+      goto fail;
+
+  fds[0] = temp[0];
+  fds[1] = temp[1];
+  return 0;
+
+fail:
+  uv__close(temp[0]);
+  uv__close(temp[1]);
+  return err;
+}
+
+
+int uv__make_pipe(int fds[2], int flags) {
+  return uv_pipe(fds,
+                 flags & UV_NONBLOCK_PIPE,
+                 flags & UV_NONBLOCK_PIPE);
+}
diff --git a/src/unix/poll.c b/src/unix/poll.c
index 3d5022b2..b44f5f6a 100644
--- a/src/unix/poll.c
+++ b/src/unix/poll.c
@@ -93,12 +93,6 @@ int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd) {
 }
 
 
-int uv_poll_init_socket(uv_loop_t* loop, uv_poll_t* handle,
-    uv_os_sock_t socket) {
-  return uv_poll_init(loop, handle, socket);
-}
-
-
 static void uv__poll_stop(uv_poll_t* handle) {
   uv__io_stop(handle->loop,
               &handle->io_watcher,
diff --git a/src/unix/process.c b/src/unix/process.c
index b021aaeb..840c5288 100644
--- a/src/unix/process.c
+++ b/src/unix/process.c
@@ -32,6 +32,8 @@
 #include <unistd.h>
 #include <fcntl.h>
 #include <poll.h>
+#include <sched.h>
+#include <signal.h>
 
 #if defined(__APPLE__) && !TARGET_OS_IPHONE
 # include <crt_externs.h>
@@ -42,8 +44,56 @@ extern char **environ;
 
 #if defined(__linux__) || defined(__GLIBC__)
 # include <grp.h>
+# ifdef __GLIBC_PREREQ
+#  if ! (__GLIBC_PREREQ(2,11))
+int execvpe(const char *file, char *const argv[], char *const envp[])
+{
+	const char *p, *z, *path = getenv("PATH");
+	size_t l, k;
+
+	errno = ENOENT;
+	if (!*file) return -1;
+
+	if (strchr(file, '/'))
+		return execve(file, argv, envp);
+
+	if (!path) path = "/usr/local/bin:/bin:/usr/bin";
+	k = strnlen(file, NAME_MAX+1);
+	if (k > NAME_MAX) {
+		errno = ENAMETOOLONG;
+		return -1;
+	}
+	l = strnlen(path, PATH_MAX-1)+1;
+
+	for(p=path; ; p=z) {
+		char b[l+k+1];
+		z = strchr(p, ':');
+		if (!z) z = p+strlen(p);
+		if (z-p >= l) {
+			if (!*z++) break;
+			continue;
+		}
+		memcpy(b, p, z-p);
+		b[z-p] = '/';
+		memcpy(b+(z-p)+(z>p), file, k+1);
+		execve(b, argv, envp);
+		if (errno != ENOENT) return -1;
+		if (!*z++) break;
+	}
+	return -1;
+}
+#  endif
+# endif
 #endif
 
+#if defined(__linux__)
+# define uv__cpu_set_t cpu_set_t
+#elif defined(__FreeBSD__)
+# include <sys/param.h>
+# include <sys/cpuset.h>
+# include <pthread_np.h>
+# define uv__cpu_set_t cpuset_t
+#endif
 
 static void uv__chld(uv_signal_t* handle, int signum) {
   uv_process_t* process;
@@ -80,6 +130,7 @@ static void uv__chld(uv_signal_t* handle, int signum) {
       continue;
     }
 
+    process->pid = 0; // pid is no longer valid (or unique)
     process->status = status;
     QUEUE_REMOVE(&process->queue);
     QUEUE_INSERT_TAIL(&pending, &process->queue);
@@ -111,68 +162,6 @@ static void uv__chld(uv_signal_t* handle, int signum) {
   assert(QUEUE_EMPTY(&pending));
 }
 
-
-static int uv__make_socketpair(int fds[2]) {
-#if defined(__FreeBSD__) || defined(__linux__)
-  if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, fds))
-    return UV__ERR(errno);
-
-  return 0;
-#else
-  int err;
-
-  if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds))
-    return UV__ERR(errno);
-
-  err = uv__cloexec(fds[0], 1);
-  if (err == 0)
-    err = uv__cloexec(fds[1], 1);
-
-  if (err != 0) {
-    uv__close(fds[0]);
-    uv__close(fds[1]);
-    return UV__ERR(errno);
-  }
-
-  return 0;
-#endif
-}
-
-
-int uv__make_pipe(int fds[2], int flags) {
-#if defined(__FreeBSD__) || defined(__linux__)
-  if (pipe2(fds, flags | O_CLOEXEC))
-    return UV__ERR(errno);
-
-  return 0;
-#else
-  if (pipe(fds))
-    return UV__ERR(errno);
-
-  if (uv__cloexec(fds[0], 1))
-    goto fail;
-
-  if (uv__cloexec(fds[1], 1))
-    goto fail;
-
-  if (flags & UV__F_NONBLOCK) {
-    if (uv__nonblock(fds[0], 1))
-      goto fail;
-
-    if (uv__nonblock(fds[1], 1))
-      goto fail;
-  }
-
-  return 0;
-
-fail:
-  uv__close(fds[0]);
-  uv__close(fds[1]);
-  return UV__ERR(errno);
-#endif
-}
-
-
 /*
  * Used for initializing stdio streams like options.stdin_stream. Returns
  * zero on success. See also the cleanup section in uv_spawn().
@@ -192,12 +181,12 @@ static int uv__process_init_stdio(uv_stdio_container_t* container, int fds[2]) {
     if (container->data.stream->type != UV_NAMED_PIPE)
       return UV_EINVAL;
     else
-      return uv__make_socketpair(fds);
+      return uv_socketpair(SOCK_STREAM, 0, fds, 0, 0);
 
   case UV_INHERIT_FD:
   case UV_INHERIT_STREAM:
     if (container->flags & UV_INHERIT_FD)
-      fd = container->data.fd;
+      fd = container->data.file;
     else
       fd = uv__stream_fd(container->data.stream);
 
@@ -245,6 +234,7 @@ static void uv__process_close_stream(uv_stdio_container_t* container) {
 }
 
 
+#ifndef __linux__
 static void uv__write_int(int fd, int val) {
   ssize_t n;
 
@@ -257,23 +247,35 @@ static void uv__write_int(int fd, int val) {
 
   assert(n == sizeof(val));
 }
+#endif
 
 
 #if !(defined(__APPLE__) && (TARGET_OS_TV || TARGET_OS_WATCH))
-/* execvp is marked __WATCHOS_PROHIBITED __TVOS_PROHIBITED, so must be
+/* May share the parent's memory space. Do not alter global state.
+ *
+ * execvp is marked __WATCHOS_PROHIBITED __TVOS_PROHIBITED, so must be
  * avoided. Since this isn't called on those targets, the function
  * doesn't even need to be defined for them.
  */
 static void uv__process_child_init(const uv_process_options_t* options,
+#ifdef __linux__
+                                   volatile int* error_out,
+#else
+                                   int error_fd,
+#endif
                                    int stdio_count,
-                                   int (*pipes)[2],
-                                   int error_fd) {
+                                   int (*pipes)[2]) {
   sigset_t set;
   int close_fd;
   int use_fd;
   int err;
   int fd;
   int n;
+#if defined(__linux__) || defined(__FreeBSD__)
+  int i;
+  int cpumask_size;
+  uv__cpu_set_t cpuset;
+#endif
 
   if (options->flags & UV_PROCESS_DETACHED)
     setsid();
@@ -288,8 +290,8 @@ static void uv__process_child_init(const uv_process_options_t* options,
       continue;
     pipes[fd][1] = fcntl(use_fd, F_DUPFD, stdio_count);
     if (pipes[fd][1] == -1) {
-      uv__write_int(error_fd, UV__ERR(errno));
-      _exit(127);
+      err = UV__ERR(errno);
+      goto error;
     }
   }
 
@@ -308,8 +310,8 @@ static void uv__process_child_init(const uv_process_options_t* options,
         close_fd = use_fd;
 
         if (use_fd < 0) {
-          uv__write_int(error_fd, UV__ERR(errno));
-          _exit(127);
+          err = UV__ERR(errno);
+          goto error;
         }
       }
     }
@@ -320,8 +322,8 @@ static void uv__process_child_init(const uv_process_options_t* options,
       fd = dup2(use_fd, fd);
 
     if (fd == -1) {
-      uv__write_int(error_fd, UV__ERR(errno));
-      _exit(127);
+      err = UV__ERR(errno);
+      goto error;
     }
 
     if (fd <= 2)
@@ -339,8 +341,8 @@ static void uv__process_child_init(const uv_process_options_t* options,
   }
 
   if (options->cwd != NULL && chdir(options->cwd)) {
-    uv__write_int(error_fd, UV__ERR(errno));
-    _exit(127);
+    err = UV__ERR(errno);
+    goto error;
   }
 
   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
@@ -355,18 +357,40 @@ static void uv__process_child_init(const uv_process_options_t* options,
   }
 
   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
-    uv__write_int(error_fd, UV__ERR(errno));
-    _exit(127);
+    err = UV__ERR(errno);
+    goto error;
   }
 
   if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {
-    uv__write_int(error_fd, UV__ERR(errno));
-    _exit(127);
+    err = UV__ERR(errno);
+    goto error;
   }
 
-  if (options->env != NULL) {
-    environ = options->env;
+#if defined(__linux__) || defined(__FreeBSD__)
+  if (options->cpumask != NULL) {
+    cpumask_size = uv_cpumask_size();
+    assert(options->cpumask_size >= (size_t)cpumask_size);
+
+    CPU_ZERO(&cpuset);
+    for (i = 0; i < cpumask_size; ++i) {
+      if (options->cpumask[i]) {
+        CPU_SET(i, &cpuset);
+      }
+    }
+
+#if defined(__linux__)
+    /* Avoid using pthread when using vfork. */
+    if (sched_setaffinity(0, sizeof(cpuset), &cpuset)) {
+      err = UV__ERR(errno);
+      goto error;
+    }
+#else
+    err = UV__ERR(pthread_setaffinity_np(pthread_self(), sizeof(cpuset), &cpuset));
+    if (err != 0)
+      goto error;
+#endif
   }
+#endif
 
   /* Reset signal disposition.  Use a hard-coded limit because NSIG
    * is not fixed on Linux: it's either 32, 34 or 64, depending on
@@ -385,21 +409,38 @@ static void uv__process_child_init(const uv_process_options_t* options,
     if (SIG_ERR != signal(n, SIG_DFL))
       continue;
 
-    uv__write_int(error_fd, UV__ERR(errno));
-    _exit(127);
+    err = UV__ERR(errno);
+    goto error;
   }
 
   /* Reset signal mask. */
   sigemptyset(&set);
-  err = pthread_sigmask(SIG_SETMASK, &set, NULL);
+  err = UV__ERR(pthread_sigmask(SIG_SETMASK, &set, NULL));
+  if (err != 0)
+    goto error;
 
-  if (err != 0) {
-    uv__write_int(error_fd, UV__ERR(err));
-    _exit(127);
+#ifdef __linux__
+  if (options->env != NULL) {
+    execvpe(options->file, options->args, options->env);
+  } else {
+    execvp(options->file, options->args);
+  }
+#else
+  if (options->env != NULL) {
+    environ = options->env;
   }
 
   execvp(options->file, options->args);
-  uv__write_int(error_fd, UV__ERR(errno));
+#endif
+
+  err = -errno;
+
+error:
+#ifdef __linux__
+  *error_out = err;
+#else
+  uv__write_int(error_fd, err);
+#endif
   _exit(127);
 }
 #endif
@@ -410,18 +451,40 @@ int uv_spawn(uv_loop_t* loop,
              const uv_process_options_t* options) {
 #if defined(__APPLE__) && (TARGET_OS_TV || TARGET_OS_WATCH)
   /* fork is marked __WATCHOS_PROHIBITED __TVOS_PROHIBITED. */
+  uv__handle_init(loop, (uv_handle_t*)process, UV_PROCESS);
+  QUEUE_INIT(&process->queue);
+  process->pid = 0;
   return UV_ENOSYS;
 #else
-  int signal_pipe[2] = { -1, -1 };
   int pipes_storage[8][2];
   int (*pipes)[2];
   int stdio_count;
-  ssize_t r;
   pid_t pid;
   int err;
-  int exec_errorno;
   int i;
+  sigset_t sigset;
+#ifdef __linux__
+  volatile int exec_errorno;
+  int cancelstate;
+#else
   int status;
+  int exec_errorno;
+  int signal_pipe[2] = { -1, -1 };
+  ssize_t r;
+#endif
+
+  uv__handle_init(loop, (uv_handle_t*)process, UV_PROCESS);
+  QUEUE_INIT(&process->queue);
+  process->pid = 0;
+
+  if (options->cpumask != NULL) {
+#if defined(__linux__) || defined(__FreeBSD__)
+    if (options->cpumask_size < (size_t)uv_cpumask_size())
+      return UV_EINVAL;
+#else
+    return UV_ENOTSUP;
+#endif
+  }
 
   assert(options->file != NULL);
   assert(!(options->flags & ~(UV_PROCESS_DETACHED |
@@ -432,9 +495,6 @@ int uv_spawn(uv_loop_t* loop,
                               UV_PROCESS_WINDOWS_HIDE_GUI |
                               UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS)));
 
-  uv__handle_init(loop, (uv_handle_t*)process, UV_PROCESS);
-  QUEUE_INIT(&process->queue);
-
   stdio_count = options->stdio_count;
   if (stdio_count < 3)
     stdio_count = 3;
@@ -458,6 +518,36 @@ int uv_spawn(uv_loop_t* loop,
       goto error;
   }
 
+  process->status = 0;
+  exec_errorno = 0;
+
+  uv_signal_start(&loop->child_watcher, uv__chld, SIGCHLD);
+
+  sigfillset(&sigset);
+  pthread_sigmask(SIG_SETMASK, &sigset, &sigset);
+
+#ifdef __linux__
+  /* Acquire write lock to prevent opening new fds in worker threads */
+  uv_rwlock_wrlock(&loop->cloexec_lock);
+  pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cancelstate);
+
+  pid = vfork();
+
+  if (pid == -1) {
+    err = -errno;
+    uv_rwlock_wrunlock(&loop->cloexec_lock);
+    pthread_sigmask(SIG_SETMASK, &sigset, NULL);
+    goto error;
+  }
+
+  if (pid == 0) {
+    uv__process_child_init(options, &exec_errorno, stdio_count, pipes);
+    abort();
+  }
+
+  pthread_setcancelstate(cancelstate, NULL);
+  uv_rwlock_wrunlock(&loop->cloexec_lock);
+#else /* !__linux__ */
   /* This pipe is used by the parent to wait until
    * the child has called `execve()`. We need this
    * to avoid the following race condition:
@@ -479,13 +569,14 @@ int uv_spawn(uv_loop_t* loop,
    * the parent polls the read end until it EOFs or errors with EPIPE.
    */
   err = uv__make_pipe(signal_pipe, 0);
-  if (err)
+  if (err) {
+    pthread_sigmask(SIG_SETMASK, &sigset, NULL);
     goto error;
-
-  uv_signal_start(&loop->child_watcher, uv__chld, SIGCHLD);
+  }
 
   /* Acquire write lock to prevent opening new fds in worker threads */
   uv_rwlock_wrlock(&loop->cloexec_lock);
+
   pid = fork();
 
   if (pid == -1) {
@@ -493,11 +584,12 @@ int uv_spawn(uv_loop_t* loop,
     uv_rwlock_wrunlock(&loop->cloexec_lock);
     uv__close(signal_pipe[0]);
     uv__close(signal_pipe[1]);
+    pthread_sigmask(SIG_SETMASK, &sigset, NULL);
     goto error;
   }
 
   if (pid == 0) {
-    uv__process_child_init(options, stdio_count, pipes, signal_pipe[1]);
+    uv__process_child_init(options, signal_pipe[1], stdio_count, pipes);
     abort();
   }
 
@@ -505,8 +597,6 @@ int uv_spawn(uv_loop_t* loop,
   uv_rwlock_wrunlock(&loop->cloexec_lock);
   uv__close(signal_pipe[1]);
 
-  process->status = 0;
-  exec_errorno = 0;
   do
     r = read(signal_pipe[0], &exec_errorno, sizeof(exec_errorno));
   while (r == -1 && errno == EINTR);
@@ -527,6 +617,7 @@ int uv_spawn(uv_loop_t* loop,
     abort();
 
   uv__close_nocheckstdio(signal_pipe[0]);
+#endif /* __linux__ */
 
   for (i = 0; i < options->stdio_count; i++) {
     err = uv__process_open_stream(options->stdio + i, pipes[i]);
@@ -543,14 +634,14 @@ int uv_spawn(uv_loop_t* loop,
   if (exec_errorno == 0) {
     QUEUE_INSERT_TAIL(&loop->process_handles, &process->queue);
     uv__handle_start(process);
+    process->pid = pid;
   }
 
-  process->pid = pid;
   process->exit_cb = options->exit_cb;
 
   if (pipes != pipes_storage)
     uv__free(pipes);
-
+  pthread_sigmask(SIG_SETMASK, &sigset, NULL);
   return exec_errorno;
 
 error:
@@ -575,6 +666,8 @@ error:
 
 
 int uv_process_kill(uv_process_t* process, int signum) {
+  if (process->pid == 0)
+    return UV_ESRCH;
   return uv_kill(process->pid, signum);
 }
 
@@ -588,6 +681,7 @@ int uv_kill(int pid, int signum) {
 
 
 void uv__process_close(uv_process_t* handle) {
+  /* TODO: assert(handle->pid == 0), otherwise we are creating a zombie */
   QUEUE_REMOVE(&handle->queue);
   uv__handle_stop(handle);
   if (QUEUE_EMPTY(&handle->loop->process_handles))
diff --git a/src/unix/signal.c b/src/unix/signal.c
index f40a3e54..5bc0fe99 100644
--- a/src/unix/signal.c
+++ b/src/unix/signal.c
@@ -60,22 +60,6 @@ RB_GENERATE_STATIC(uv__signal_tree_s,
                    uv_signal_s, tree_entry,
                    uv__signal_compare)
 
-static void uv__signal_global_reinit(void);
-
-static void uv__signal_global_init(void) {
-  if (uv__signal_lock_pipefd[0] == -1)
-    /* pthread_atfork can register before and after handlers, one
-     * for each child. This only registers one for the child. That
-     * state is both persistent and cumulative, so if we keep doing
-     * it the handler functions will be called multiple times. Thus
-     * we only want to do it once.
-     */
-    if (pthread_atfork(NULL, NULL, &uv__signal_global_reinit))
-      abort();
-
-  uv__signal_global_reinit();
-}
-
 
 void uv__signal_cleanup(void) {
   /* We can only use signal-safe functions here.
@@ -97,7 +81,7 @@ void uv__signal_cleanup(void) {
 }
 
 
-static void uv__signal_global_reinit(void) {
+static void uv__signal_global_init(void) {
   uv__signal_cleanup();
 
   if (uv__make_pipe(uv__signal_lock_pipefd, 0))
@@ -265,7 +249,7 @@ static int uv__signal_loop_once_init(uv_loop_t* loop) {
   if (loop->signal_pipefd[0] != -1)
     return 0;
 
-  err = uv__make_pipe(loop->signal_pipefd, UV__F_NONBLOCK);
+  err = uv__make_pipe(loop->signal_pipefd, UV_NONBLOCK_PIPE);
   if (err)
     return err;
 
@@ -278,16 +262,6 @@ static int uv__signal_loop_once_init(uv_loop_t* loop) {
 }
 
 
-int uv__signal_loop_fork(uv_loop_t* loop) {
-  uv__io_stop(loop, &loop->signal_io_watcher, POLLIN);
-  uv__close(loop->signal_pipefd[0]);
-  uv__close(loop->signal_pipefd[1]);
-  loop->signal_pipefd[0] = -1;
-  loop->signal_pipefd[1] = -1;
-  return uv__signal_loop_once_init(loop);
-}
-
-
 void uv__signal_loop_cleanup(uv_loop_t* loop) {
   QUEUE* q;
 
diff --git a/src/unix/stream.c b/src/unix/stream.c
index 8327f9cc..87641133 100644
--- a/src/unix/stream.c
+++ b/src/unix/stream.c
@@ -1314,10 +1314,10 @@ static void uv__stream_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {
    * have to do anything. If the partial read flag is not set, we can't
    * report the EOF yet because there is still data to read.
    */
-  if ((events & POLLHUP) &&
-      (stream->flags & UV_HANDLE_READING) &&
+  if ((events & POLLHUP) && ((events == POLLHUP) ||
+      ((stream->flags & UV_HANDLE_READING) &&
       (stream->flags & UV_HANDLE_READ_PARTIAL) &&
-      !(stream->flags & UV_HANDLE_READ_EOF)) {
+      !(stream->flags & UV_HANDLE_READ_EOF)))) {
     uv_buf_t buf = { NULL, 0 };
     uv__stream_eof(stream, &buf);
   }
diff --git a/src/unix/sunos.c b/src/unix/sunos.c
index d511c18b..faaafb30 100644
--- a/src/unix/sunos.c
+++ b/src/unix/sunos.c
@@ -99,18 +99,6 @@ void uv__platform_loop_delete(uv_loop_t* loop) {
 }
 
 
-int uv__io_fork(uv_loop_t* loop) {
-#if defined(PORT_SOURCE_FILE)
-  if (loop->fs_fd != -1) {
-    /* stop the watcher before we blow away its fileno */
-    uv__io_stop(loop, &loop->fs_event_watcher, POLLIN);
-  }
-#endif
-  uv__platform_loop_delete(loop);
-  return uv__platform_loop_init(loop);
-}
-
-
 void uv__platform_invalidate_fd(uv_loop_t* loop, int fd) {
   struct port_event* events;
   uintptr_t i;
diff --git a/src/unix/tcp.c b/src/unix/tcp.c
index 18acd20d..9e84bff5 100644
--- a/src/unix/tcp.c
+++ b/src/unix/tcp.c
@@ -459,3 +459,49 @@ int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable) {
 void uv__tcp_close(uv_tcp_t* handle) {
   uv__stream_close((uv_stream_t*)handle);
 }
+
+
+int uv_socketpair(int type, int protocol, uv_os_sock_t fds[2], int flags0, int flags1) {
+  uv_os_sock_t temp[2];
+  int err;
+#if defined(__FreeBSD__) || defined(__linux__)
+  int flags;
+
+  flags = type | SOCK_CLOEXEC;
+  if ((flags0 & UV_NONBLOCK_PIPE) && (flags1 & UV_NONBLOCK_PIPE))
+    flags |= UV_FS_O_NONBLOCK;
+
+  if (socketpair(AF_UNIX, type, protocol, temp))
+    return UV__ERR(errno);
+
+  if (flags & UV_FS_O_NONBLOCK) {
+    fds[0] = temp[0];
+    fds[1] = temp[1];
+    return 0;
+  }
+#else
+  if (socketpair(AF_UNIX, type, protocol, temp))
+    return UV__ERR(errno);
+
+  if ((err = uv__cloexec(temp[0], 1)))
+    goto fail;
+  if ((err = uv__cloexec(temp[1], 1)))
+    goto fail;
+#endif
+
+  if (flags0 & UV_NONBLOCK_PIPE)
+    if ((err = uv__nonblock(temp[0], 1)))
+        goto fail;
+  if (flags1 & UV_NONBLOCK_PIPE)
+    if ((err = uv__nonblock(temp[1], 1)))
+      goto fail;
+
+  fds[0] = temp[0];
+  fds[1] = temp[1];
+  return 0;
+
+fail:
+  uv__close(temp[0]);
+  uv__close(temp[1]);
+  return err;
+}
diff --git a/src/unix/thread.c b/src/unix/thread.c
index 1a85d1d4..82ae26be 100644
--- a/src/unix/thread.c
+++ b/src/unix/thread.c
@@ -41,98 +41,89 @@
 #include <gnu/libc-version.h>  /* gnu_get_libc_version() */
 #endif
 
+#if defined(__linux__)
+# include <sched.h>
+# define uv__cpu_set_t cpu_set_t
+#elif defined(__FreeBSD__)
+# include <sys/param.h>
+# include <sys/cpuset.h>
+# include <pthread_np.h>
+# define uv__cpu_set_t cpuset_t
+#endif
+
+
 #undef NANOSEC
 #define NANOSEC ((uint64_t) 1e9)
 
-#if defined(PTHREAD_BARRIER_SERIAL_THREAD)
-STATIC_ASSERT(sizeof(uv_barrier_t) == sizeof(pthread_barrier_t));
-#endif
-
 /* Note: guard clauses should match uv_barrier_t's in include/uv/unix.h. */
 #if defined(_AIX) || \
     defined(__OpenBSD__) || \
     !defined(PTHREAD_BARRIER_SERIAL_THREAD)
 int uv_barrier_init(uv_barrier_t* barrier, unsigned int count) {
-  struct _uv_barrier* b;
   int rc;
 
   if (barrier == NULL || count == 0)
     return UV_EINVAL;
 
-  b = uv__malloc(sizeof(*b));
-  if (b == NULL)
-    return UV_ENOMEM;
-
-  b->in = 0;
-  b->out = 0;
-  b->threshold = count;
+  barrier->in = 0;
+  barrier->out = 0;
+  barrier->threshold = count;
 
-  rc = uv_mutex_init(&b->mutex);
+  rc = uv_mutex_init(&barrier->mutex);
   if (rc != 0)
-    goto error2;
+    return rc;
 
-  rc = uv_cond_init(&b->cond);
+  rc = uv_cond_init(&barrier->cond);
   if (rc != 0)
     goto error;
 
-  barrier->b = b;
   return 0;
 
 error:
-  uv_mutex_destroy(&b->mutex);
-error2:
-  uv__free(b);
+  pthread_mutex_destroy(&barrier->mutex);
   return rc;
 }
 
 
 int uv_barrier_wait(uv_barrier_t* barrier) {
-  struct _uv_barrier* b;
   int last;
 
-  if (barrier == NULL || barrier->b == NULL)
+  if (barrier == NULL)
     return UV_EINVAL;
 
-  b = barrier->b;
-  uv_mutex_lock(&b->mutex);
+  uv_mutex_lock(&barrier->mutex);
 
-  if (++b->in == b->threshold) {
-    b->in = 0;
-    b->out = b->threshold;
-    uv_cond_signal(&b->cond);
+  if (++barrier->in == barrier->threshold) {
+    barrier->in = 0;
+    barrier->out = barrier->threshold;
+    uv_cond_signal(&barrier->cond);
   } else {
     do
-      uv_cond_wait(&b->cond, &b->mutex);
-    while (b->in != 0);
+      uv_cond_wait(&barrier->cond, &barrier->mutex);
+    while (barrier->in != 0);
   }
 
-  last = (--b->out == 0);
+  last = (--barrier->out == 0);
   if (!last)
-    uv_cond_signal(&b->cond);  /* Not needed for last thread. */
+    uv_cond_signal(&barrier->cond);  /* Not needed for last thread. */
 
-  uv_mutex_unlock(&b->mutex);
+  uv_mutex_unlock(&barrier->mutex);
   return last;
 }
 
 
 void uv_barrier_destroy(uv_barrier_t* barrier) {
-  struct _uv_barrier* b;
-
-  b = barrier->b;
-  uv_mutex_lock(&b->mutex);
+  uv_mutex_lock(&barrier->mutex);
 
-  assert(b->in == 0);
-  assert(b->out == 0);
+  assert(barrier->in == 0);
+  assert(barrier->out == 0);
 
-  if (b->in != 0 || b->out != 0)
+  if (barrier->in != 0 || barrier->out != 0)
     abort();
 
-  uv_mutex_unlock(&b->mutex);
-  uv_mutex_destroy(&b->mutex);
-  uv_cond_destroy(&b->cond);
-
-  uv__free(barrier->b);
-  barrier->b = NULL;
+  uv_mutex_unlock(&barrier->mutex);
+  uv_mutex_destroy(&barrier->mutex);
+  uv_cond_destroy(&barrier->cond);
 }
 
 #else
@@ -265,6 +256,82 @@ int uv_thread_create_ex(uv_thread_t* tid,
 }
 
 
+#if defined(__linux__) || defined(__FreeBSD__)
+
+int uv_thread_setaffinity(uv_thread_t* tid,
+                          char* cpumask,
+                          char* oldmask,
+                          size_t mask_size) {
+  int i;
+  int r;
+  uv__cpu_set_t cpuset;
+  int cpumasksize;
+
+  cpumasksize = uv_cpumask_size();
+  if (cpumasksize < 0)
+    return cpumasksize;
+  if (mask_size < (size_t)cpumasksize)
+    return UV_EINVAL;
+
+  if (oldmask != NULL) {
+    r = uv_thread_getaffinity(tid, oldmask, mask_size);
+    if (r < 0)
+      return r;
+  }
+
+  CPU_ZERO(&cpuset);
+  for (i = 0; i < cpumasksize; i++)
+    if (cpumask[i])
+      CPU_SET(i, &cpuset);
+
+  return UV__ERR(pthread_setaffinity_np(*tid, sizeof(cpuset), &cpuset));
+}
+
+
+int uv_thread_getaffinity(uv_thread_t* tid,
+                          char* cpumask,
+                          size_t mask_size) {
+  int r;
+  int i;
+  uv__cpu_set_t cpuset;
+  int cpumasksize;
+
+  cpumasksize = uv_cpumask_size();
+  if (cpumasksize < 0)
+    return cpumasksize;
+  if (mask_size < (size_t)cpumasksize)
+    return UV_EINVAL;
+
+  CPU_ZERO(&cpuset);
+  r = pthread_getaffinity_np(*tid, sizeof(cpuset), &cpuset);
+  if (r)
+    return UV__ERR(r);
+  for (i = 0; i < cpumasksize; i++)
+    cpumask[i] = !!CPU_ISSET(i, &cpuset);
+
+  return 0;
+}
+#else
+int uv_thread_setaffinity(uv_thread_t* tid,
+                          char* cpumask,
+                          char* oldmask,
+                          size_t mask_size) {
+  return UV_ENOTSUP;
+}
+
+
+int uv_thread_getaffinity(uv_thread_t* tid,
+                          char* cpumask,
+                          size_t mask_size) {
+  return UV_ENOTSUP;
+}
+#endif /* defined(__linux__) || defined(UV_BSD_H) */
+
+int uv_thread_detach(uv_thread_t* tid) {
+  return UV__ERR(pthread_detach(*tid));
+}
+
+
 uv_thread_t uv_thread_self(void) {
   return pthread_self();
 }
diff --git a/src/unix/tty.c b/src/unix/tty.c
index 6f60abaa..c7ab78ab 100644
--- a/src/unix/tty.c
+++ b/src/unix/tty.c
@@ -312,7 +312,7 @@ int uv_tty_get_winsize(uv_tty_t* tty, int* width, int* height) {
 }
 
 
-uv_handle_type uv_guess_handle(uv_file file) {
+uv_handle_type uv_guess_handle(uv_os_fd_t file) {
   struct sockaddr sa;
   struct stat s;
   socklen_t len;
diff --git a/src/unix/udp.c b/src/unix/udp.c
index 16c7f38a..65348023 100644
--- a/src/unix/udp.c
+++ b/src/unix/udp.c
@@ -840,10 +840,6 @@ static int uv__udp_set_membership6(uv_udp_t* handle,
                  optname,
                  &mreq,
                  sizeof(mreq))) {
-#if defined(__MVS__)
-  if (errno == ENXIO)
-    return UV_ENODEV;
-#endif
     return UV__ERR(errno);
   }
 
diff --git a/src/uv-common.c b/src/uv-common.c
index 602e5f49..76e15b11 100644
--- a/src/uv-common.c
+++ b/src/uv-common.c
@@ -26,7 +26,7 @@
 #include <errno.h>
 #include <stdarg.h>
 #include <stddef.h> /* NULL */
-#include <stdio.h>
+#include <stdio.h> /* FILE, printf */
 #include <stdlib.h> /* malloc */
 #include <string.h> /* memset */
 
@@ -73,9 +73,7 @@ char* uv__strndup(const char* s, size_t n) {
 }
 
 void* uv__malloc(size_t size) {
-  if (size > 0)
-    return uv__allocator.local_malloc(size);
-  return NULL;
+  return uv__allocator.local_malloc(size);
 }
 
 void uv__free(void* ptr) {
@@ -94,10 +92,7 @@ void* uv__calloc(size_t count, size_t size) {
 }
 
 void* uv__realloc(void* ptr, size_t size) {
-  if (size > 0)
-    return uv__allocator.local_realloc(ptr, size);
-  uv__free(ptr);
-  return NULL;
+  return uv__allocator.local_realloc(ptr, size);
 }
 
 void* uv__reallocf(void* ptr, size_t size) {
@@ -154,7 +149,7 @@ size_t uv_loop_size(void) {
 }
 
 
-uv_buf_t uv_buf_init(char* base, unsigned int len) {
+uv_buf_t uv_buf_init(char* base, size_t len) {
   uv_buf_t buf;
   buf.base = base;
   buf.len = len;
@@ -252,11 +247,14 @@ int uv_ip6_addr(const char* ip, int port, struct sockaddr_in6* addr) {
     ip = address_part;
 
     zone_index++; /* skip '%' */
-    /* NOTE: unknown interface (id=0) is silently ignored */
 #ifdef _WIN32
+    /* NOTE: unknown interfaces are silently ignored on Windows */
     addr->sin6_scope_id = atoi(zone_index);
 #else
     addr->sin6_scope_id = if_nametoindex(zone_index);
+
+    if (addr->sin6_scope_id == 0)
+      return -errno;
 #endif
   }
 
@@ -502,7 +500,7 @@ void uv_walk(uv_loop_t* loop, uv_walk_cb walk_cb, void* arg) {
 }
 
 
-static void uv__print_handles(uv_loop_t* loop, int only_active, FILE* stream) {
+static void uv__print_handles(uv_loop_t* loop, int only_active, void* stream) {
   const char* type;
   QUEUE* q;
   uv_handle_t* h;
@@ -534,12 +532,12 @@ static void uv__print_handles(uv_loop_t* loop, int only_active, FILE* stream) {
 }
 
 
-void uv_print_all_handles(uv_loop_t* loop, FILE* stream) {
+void uv_print_all_handles(uv_loop_t* loop, void* stream) {
   uv__print_handles(loop, 0, stream);
 }
 
 
-void uv_print_active_handles(uv_loop_t* loop, FILE* stream) {
+void uv_print_active_handles(uv_loop_t* loop, void* stream) {
   uv__print_handles(loop, 1, stream);
 }
 
diff --git a/src/uv-common.h b/src/uv-common.h
index e851291c..f76b1f1c 100644
--- a/src/uv-common.h
+++ b/src/uv-common.h
@@ -30,12 +30,7 @@
 #include <assert.h>
 #include <stdarg.h>
 #include <stddef.h>
-
-#if defined(_MSC_VER) && _MSC_VER < 1600
-# include "uv/stdint-msvc2008.h"
-#else
-# include <stdint.h>
-#endif
+#include <stdint.h>
 
 #include "uv.h"
 #include "uv/tree.h"
@@ -48,10 +43,6 @@
 # define UV__ERR(x) (x)
 #endif
 
-#if !defined(snprintf) && defined(_MSC_VER) && _MSC_VER < 1900
-extern int snprintf(char*, size_t, const char*, ...);
-#endif
-
 #define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
 
 #define container_of(ptr, type, member) \
@@ -93,7 +84,7 @@ enum {
   UV_HANDLE_WRITABLE                    = 0x00008000,
   UV_HANDLE_READ_PENDING                = 0x00010000,
   UV_HANDLE_SYNC_BYPASS_IOCP            = 0x00020000,
-  UV_HANDLE_ZERO_READ                   = 0x00040000,
+  /*UV_HANDLE_FLAG_UNUSED               = 0x00040000,*/
   UV_HANDLE_EMULATE_IOCP                = 0x00080000,
   UV_HANDLE_BLOCKING_WRITES             = 0x00100000,
   UV_HANDLE_CANCELLATION_PENDING        = 0x00200000,
@@ -210,10 +201,6 @@ void uv__fs_scandir_cleanup(uv_fs_t* req);
 void uv__fs_readdir_cleanup(uv_fs_t* req);
 uv_dirent_type_t uv__fs_get_dirent_type(uv__dirent_t* dent);
 
-int uv__next_timeout(const uv_loop_t* loop);
-void uv__run_timers(uv_loop_t* loop);
-void uv__timer_close(uv_timer_t* handle);
-
 void uv__process_title_cleanup(void);
 void uv__signal_cleanup(void);
 void uv__threadpool_cleanup(void);
@@ -293,7 +280,7 @@ void uv__threadpool_cleanup(void);
   (((h)->flags & UV_HANDLE_REF) != 0)
 
 #if defined(_WIN32)
-# define uv__handle_platform_init(h) ((h)->u.fd = -1)
+# define uv__handle_platform_init(h)
 #else
 # define uv__handle_platform_init(h) ((h)->next_closing = NULL)
 #endif
@@ -312,15 +299,17 @@ void uv__threadpool_cleanup(void);
  * a circular dependency between src/uv-common.h and src/win/internal.h.
  */
 #if defined(_WIN32)
-# define UV_REQ_INIT(req, typ)                                                \
+# define UV_REQ_INIT(loop_, req, typ)                                         \
   do {                                                                        \
+    (req)->loop = (loop_);                                                    \
     (req)->type = (typ);                                                      \
     (req)->u.io.overlapped.Internal = 0;  /* SET_REQ_SUCCESS() */             \
   }                                                                           \
   while (0)
 #else
-# define UV_REQ_INIT(req, typ)                                                \
+# define UV_REQ_INIT(loop_, req, typ)                                         \
   do {                                                                        \
+    (req)->loop = (loop_);                                                    \
     (req)->type = (typ);                                                      \
   }                                                                           \
   while (0)
@@ -328,7 +317,7 @@ void uv__threadpool_cleanup(void);
 
 #define uv__req_init(loop, req, typ)                                          \
   do {                                                                        \
-    UV_REQ_INIT(req, typ);                                                    \
+    UV_REQ_INIT(loop, req, typ);                                              \
     uv__req_register(loop, req);                                              \
   }                                                                           \
   while (0)
@@ -348,6 +337,17 @@ void uv__free(void* ptr);
 void* uv__realloc(void* ptr, size_t size);
 void* uv__reallocf(void* ptr, size_t size);
 
+/* Loop watcher prototypes */
+void uv__idle_close(uv_idle_t* handle);
+void uv__prepare_close(uv_prepare_t* handle);
+void uv__check_close(uv_check_t* handle);
+
+/* Timer prototypes */
+void uv__run_timers(uv_loop_t* loop);
+int uv__next_timeout(const uv_loop_t* loop);
+void uv__timer_close(uv_timer_t* handle);
+
+/* Metrics prototypes */
 typedef struct uv__loop_metrics_s uv__loop_metrics_t;
 typedef struct uv__loop_internal_fields_s uv__loop_internal_fields_t;
 
diff --git a/src/uv-data-getter-setters.c b/src/uv-data-getter-setters.c
index 0bd04486..4efdd2ad 100644
--- a/src/uv-data-getter-setters.c
+++ b/src/uv-data-getter-setters.c
@@ -70,6 +70,10 @@ void* uv_req_get_data(const uv_req_t* req) {
   return req->data;
 }
 
+uv_loop_t* uv_req_get_loop(const uv_req_t* req) {
+  return req->loop;
+}
+
 void uv_req_set_data(uv_req_t* req, void* data) {
   req->data = data;
 }
diff --git a/src/win/async.c b/src/win/async.c
index d787f660..722397dc 100644
--- a/src/win/async.c
+++ b/src/win/async.c
@@ -23,31 +23,23 @@
 
 #include "uv.h"
 #include "internal.h"
-#include "atomicops-inl.h"
 #include "handle-inl.h"
 #include "req-inl.h"
 
 
 void uv_async_endgame(uv_loop_t* loop, uv_async_t* handle) {
-  if (handle->flags & UV_HANDLE_CLOSING &&
-      !handle->async_sent) {
-    assert(!(handle->flags & UV_HANDLE_CLOSED));
-    uv__handle_close(handle);
-  }
+  assert(handle->flags & UV_HANDLE_CLOSING);
+  assert(!(handle->flags & UV_HANDLE_CLOSED));
+  uv__handle_close(handle);
 }
 
 
 int uv_async_init(uv_loop_t* loop, uv_async_t* handle, uv_async_cb async_cb) {
-  uv_req_t* req;
-
   uv__handle_init(loop, (uv_handle_t*) handle, UV_ASYNC);
   handle->async_sent = 0;
   handle->async_cb = async_cb;
 
-  req = &handle->async_req;
-  UV_REQ_INIT(req, UV_WAKEUP);
-  req->data = handle;
-
+  QUEUE_INSERT_TAIL(&loop->async_handles, &handle->queue);
   uv__handle_start(handle);
 
   return 0;
@@ -55,44 +47,46 @@ int uv_async_init(uv_loop_t* loop, uv_async_t* handle, uv_async_cb async_cb) {
 
 
 void uv_async_close(uv_loop_t* loop, uv_async_t* handle) {
-  if (!((uv_async_t*)handle)->async_sent) {
-    uv_want_endgame(loop, (uv_handle_t*) handle);
-  }
-
+  QUEUE_REMOVE(&handle->queue);
+  uv_want_endgame(loop, (uv_handle_t*) handle);
   uv__handle_closing(handle);
 }
 
 
 int uv_async_send(uv_async_t* handle) {
-  uv_loop_t* loop = handle->loop;
-
-  if (handle->type != UV_ASYNC) {
-    /* Can't set errno because that's not thread-safe. */
-    return -1;
-  }
-
-  /* The user should make sure never to call uv_async_send to a closing or
-   * closed handle. */
-  assert(!(handle->flags & UV_HANDLE_CLOSING));
+  /* First do a cheap read. */
+  if (handle->async_sent != 0)
+    return 0;
 
-  if (!uv__atomic_exchange_set(&handle->async_sent)) {
-    POST_COMPLETION_FOR_REQ(loop, &handle->async_req);
+  if (InterlockedExchange(&handle->async_sent, 1) == 0) {
+    uv_loop_t* loop = handle->loop;
+    POST_COMPLETION_FOR_REQ(loop, &loop->async_req);
   }
 
   return 0;
 }
 
 
-void uv_process_async_wakeup_req(uv_loop_t* loop, uv_async_t* handle,
-    uv_req_t* req) {
-  assert(handle->type == UV_ASYNC);
+void uv_process_async_wakeup_req(uv_loop_t* loop,
+                                 uv_req_t* req) {
+  QUEUE queue;
+  QUEUE* q;
+  uv_async_t* h;
+
   assert(req->type == UV_WAKEUP);
 
-  handle->async_sent = 0;
+  QUEUE_MOVE(&loop->async_handles, &queue);
+  while (!QUEUE_EMPTY(&queue)) {
+    q = QUEUE_HEAD(&queue);
+    h = QUEUE_DATA(q, uv_async_t, queue);
+
+    QUEUE_REMOVE(q);
+    QUEUE_INSERT_TAIL(&loop->async_handles, q);
+
+    if (InterlockedExchange(&h->async_sent, 0) == 0)
+      continue;
 
-  if (handle->flags & UV_HANDLE_CLOSING) {
-    uv_want_endgame(loop, (uv_handle_t*)handle);
-  } else if (handle->async_cb != NULL) {
-    handle->async_cb(handle);
+    if (h->async_cb != NULL)
+      h->async_cb(h);
   }
 }
diff --git a/src/win/atomicops-inl.h b/src/win/atomicops-inl.h
deleted file mode 100644
index 52713cf3..00000000
--- a/src/win/atomicops-inl.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef UV_WIN_ATOMICOPS_INL_H_
-#define UV_WIN_ATOMICOPS_INL_H_
-
-#include "uv.h"
-#include "internal.h"
-
-
-/* Atomic set operation on char */
-#ifdef _MSC_VER /* MSVC */
-
-/* _InterlockedOr8 is supported by MSVC on x32 and x64. It is slightly less
- * efficient than InterlockedExchange, but InterlockedExchange8 does not exist,
- * and interlocked operations on larger targets might require the target to be
- * aligned. */
-#pragma intrinsic(_InterlockedOr8)
-
-static char INLINE uv__atomic_exchange_set(char volatile* target) {
-  return _InterlockedOr8(target, 1);
-}
-
-#else /* GCC */
-
-/* Mingw-32 version, hopefully this works for 64-bit gcc as well. */
-static inline char uv__atomic_exchange_set(char volatile* target) {
-  const char one = 1;
-  char old_value;
-  __asm__ __volatile__ ("lock xchgb %0, %1\n\t"
-                        : "=r"(old_value), "=m"(*target)
-                        : "0"(one), "m"(*target)
-                        : "memory");
-  return old_value;
-}
-
-#endif
-
-#endif /* UV_WIN_ATOMICOPS_INL_H_ */
diff --git a/src/win/core.c b/src/win/core.c
index e53a0f8e..8a9fafff 100644
--- a/src/win/core.c
+++ b/src/win/core.c
@@ -20,14 +20,8 @@
  */
 
 #include <assert.h>
-#include <errno.h>
 #include <limits.h>
-#include <stdio.h>
 #include <stdlib.h>
-#include <string.h>
-#if defined(_MSC_VER) || defined(__MINGW64_VERSION_MAJOR)
-#include <crtdbg.h>
-#endif
 
 #include "uv.h"
 #include "internal.h"
@@ -35,138 +29,37 @@
 #include "handle-inl.h"
 #include "heap-inl.h"
 #include "req-inl.h"
+#include "heap-inl.h"
 
 /* uv_once initialization guards */
 static uv_once_t uv_init_guard_ = UV_ONCE_INIT;
 
-
-#if defined(_DEBUG) && (defined(_MSC_VER) || defined(__MINGW64_VERSION_MAJOR))
-/* Our crt debug report handler allows us to temporarily disable asserts
- * just for the current thread.
- */
-
-UV_THREAD_LOCAL int uv__crt_assert_enabled = TRUE;
-
-static int uv__crt_dbg_report_handler(int report_type, char *message, int *ret_val) {
-  if (uv__crt_assert_enabled || report_type != _CRT_ASSERT)
-    return FALSE;
-
-  if (ret_val) {
-    /* Set ret_val to 0 to continue with normal execution.
-     * Set ret_val to 1 to trigger a breakpoint.
-    */
-
-    if(IsDebuggerPresent())
-      *ret_val = 1;
-    else
-      *ret_val = 0;
-  }
-
-  /* Don't call _CrtDbgReport. */
-  return TRUE;
-}
-#else
-UV_THREAD_LOCAL int uv__crt_assert_enabled = FALSE;
-#endif
-
-
-#if !defined(__MINGW32__) || __MSVCRT_VERSION__ >= 0x800
-static void uv__crt_invalid_parameter_handler(const wchar_t* expression,
-    const wchar_t* function, const wchar_t * file, unsigned int line,
-    uintptr_t reserved) {
-  /* No-op. */
-}
-#endif
-
-static uv_loop_t** uv__loops;
-static int uv__loops_size;
-static int uv__loops_capacity;
-#define UV__LOOPS_CHUNK_SIZE 8
+static void* uv__loops[2];
 static uv_mutex_t uv__loops_lock;
 
 static void uv__loops_init(void) {
   uv_mutex_init(&uv__loops_lock);
+  QUEUE_INIT(&uv__loops);
 }
 
-static int uv__loops_add(uv_loop_t* loop) {
-  uv_loop_t** new_loops;
-  int new_capacity, i;
-
+static void uv__loops_add(uv_loop_t* loop) {
   uv_mutex_lock(&uv__loops_lock);
-
-  if (uv__loops_size == uv__loops_capacity) {
-    new_capacity = uv__loops_capacity + UV__LOOPS_CHUNK_SIZE;
-    new_loops = uv__realloc(uv__loops, sizeof(uv_loop_t*) * new_capacity);
-    if (!new_loops)
-      goto failed_loops_realloc;
-    uv__loops = new_loops;
-    for (i = uv__loops_capacity; i < new_capacity; ++i)
-      uv__loops[i] = NULL;
-    uv__loops_capacity = new_capacity;
-  }
-  uv__loops[uv__loops_size] = loop;
-  ++uv__loops_size;
-
-  uv_mutex_unlock(&uv__loops_lock);
-  return 0;
-
-failed_loops_realloc:
+  QUEUE_INSERT_TAIL(&uv__loops, &loop->loops_queue);
   uv_mutex_unlock(&uv__loops_lock);
-  return ERROR_OUTOFMEMORY;
 }
 
 static void uv__loops_remove(uv_loop_t* loop) {
-  int loop_index;
-  int smaller_capacity;
-  uv_loop_t** new_loops;
-
   uv_mutex_lock(&uv__loops_lock);
-
-  for (loop_index = 0; loop_index < uv__loops_size; ++loop_index) {
-    if (uv__loops[loop_index] == loop)
-      break;
-  }
-  /* If loop was not found, ignore */
-  if (loop_index == uv__loops_size)
-    goto loop_removed;
-
-  uv__loops[loop_index] = uv__loops[uv__loops_size - 1];
-  uv__loops[uv__loops_size - 1] = NULL;
-  --uv__loops_size;
-
-  if (uv__loops_size == 0) {
-    uv__loops_capacity = 0;
-    uv__free(uv__loops);
-    uv__loops = NULL;
-    goto loop_removed;
-  }
-
-  /* If we didn't grow to big skip downsizing */
-  if (uv__loops_capacity < 4 * UV__LOOPS_CHUNK_SIZE)
-    goto loop_removed;
-
-  /* Downsize only if more than half of buffer is free */
-  smaller_capacity = uv__loops_capacity / 2;
-  if (uv__loops_size >= smaller_capacity)
-    goto loop_removed;
-  new_loops = uv__realloc(uv__loops, sizeof(uv_loop_t*) * smaller_capacity);
-  if (!new_loops)
-    goto loop_removed;
-  uv__loops = new_loops;
-  uv__loops_capacity = smaller_capacity;
-
-loop_removed:
+  QUEUE_REMOVE(&loop->loops_queue);
   uv_mutex_unlock(&uv__loops_lock);
 }
 
-void uv__wake_all_loops(void) {
-  int i;
-  uv_loop_t* loop;
+void uv__wake_all_loops() {
+  QUEUE* q;
 
   uv_mutex_lock(&uv__loops_lock);
-  for (i = 0; i < uv__loops_size; ++i) {
-    loop = uv__loops[i];
-    assert(loop);
+  QUEUE_FOREACH(q, &uv__loops) {
+    uv_loop_t* loop = QUEUE_DATA(q, uv_loop_t, loops_queue);
     if (loop->iocp != INVALID_HANDLE_VALUE)
       PostQueuedCompletionStatus(loop->iocp, 0, 0, NULL);
   }
@@ -178,21 +71,6 @@ static void uv_init(void) {
   SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX |
                SEM_NOOPENFILEERRORBOX);
 
-  /* Tell the CRT to not exit the application when an invalid parameter is
-   * passed. The main issue is that invalid FDs will trigger this behavior.
-   */
-#if !defined(__MINGW32__) || __MSVCRT_VERSION__ >= 0x800
-  _set_invalid_parameter_handler(uv__crt_invalid_parameter_handler);
-#endif
-
-  /* We also need to setup our debug report handler because some CRT
-   * functions (eg _get_osfhandle) raise an assert when called with invalid
-   * FDs even though they return the proper error code in the release build.
-   */
-#if defined(_DEBUG) && (defined(_MSC_VER) || defined(__MINGW64_VERSION_MAJOR))
-  _CrtSetReportHook(uv__crt_dbg_report_handler);
-#endif
-
   /* Initialize tracking of all uv loops */
   uv__loops_init();
 
@@ -221,16 +99,26 @@ static void uv_init(void) {
 }
 
 
+/* The number of milliseconds in one second. */
+#define UV__MILLISEC 1000
+
+
+void uv_update_time(uv_loop_t* loop) {
+  uint64_t new_time = uv__hrtime(UV__MILLISEC);
+  assert(new_time >= loop->time);
+  loop->time = new_time;
+}
+
+
 int uv_loop_init(uv_loop_t* loop) {
   uv__loop_internal_fields_t* lfields;
-  struct heap* timer_heap;
   int err;
 
   /* Initialize libuv itself first */
   uv__once_init();
 
   /* Create an I/O completion port */
-  loop->iocp = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);
+  loop->iocp = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);
   if (loop->iocp == NULL)
     return uv_translate_sys_error(GetLastError());
 
@@ -258,28 +146,18 @@ int uv_loop_init(uv_loop_t* loop) {
 
   loop->endgame_handles = NULL;
 
-  loop->timer_heap = timer_heap = uv__malloc(sizeof(*timer_heap));
-  if (timer_heap == NULL) {
-    err = UV_ENOMEM;
-    goto fail_timers_alloc;
-  }
-
-  heap_init(timer_heap);
+  heap_init((struct heap*) &loop->timer_heap);
+  loop->timer_counter = 0;
 
-  loop->check_handles = NULL;
-  loop->prepare_handles = NULL;
-  loop->idle_handles = NULL;
+  QUEUE_INIT(&loop->check_handles);
+  QUEUE_INIT(&loop->prepare_handles);
+  QUEUE_INIT(&loop->idle_handles);
 
-  loop->next_prepare_handle = NULL;
-  loop->next_check_handle = NULL;
-  loop->next_idle_handle = NULL;
+  QUEUE_INIT(&loop->async_handles);
+  UV_REQ_INIT(loop, &loop->async_req, UV_WAKEUP);
 
   memset(&loop->poll_peer_sockets, 0, sizeof loop->poll_peer_sockets);
 
-  loop->active_tcp_streams = 0;
-  loop->active_udp_streams = 0;
-
-  loop->timer_counter = 0;
   loop->stop_flag = 0;
 
   err = uv_mutex_init(&loop->wq_mutex);
@@ -293,9 +171,8 @@ int uv_loop_init(uv_loop_t* loop) {
   uv__handle_unref(&loop->wq_async);
   loop->wq_async.flags |= UV_HANDLE_INTERNAL;
 
-  err = uv__loops_add(loop);
-  if (err)
-    goto fail_async_init;
+  QUEUE_INIT(&loop->loops_queue);
+  uv__loops_add(loop);
 
   return 0;
 
@@ -303,10 +180,6 @@ fail_async_init:
   uv_mutex_destroy(&loop->wq_mutex);
 
 fail_mutex_init:
-  uv__free(timer_heap);
-  loop->timer_heap = NULL;
-
-fail_timers_alloc:
   uv_mutex_destroy(&lfields->loop_metrics.lock);
 
 fail_metrics_mutex_init:
@@ -319,13 +192,6 @@ fail_metrics_mutex_init:
 }
 
 
-void uv_update_time(uv_loop_t* loop) {
-  uint64_t new_time = uv__hrtime(1000);
-  assert(new_time >= loop->time);
-  loop->time = new_time;
-}
-
-
 void uv__once_init(void) {
   uv_once(&uv_init_guard_, uv_init);
 }
@@ -360,9 +226,6 @@ void uv__loop_close(uv_loop_t* loop) {
   uv_mutex_unlock(&loop->wq_mutex);
   uv_mutex_destroy(&loop->wq_mutex);
 
-  uv__free(loop->timer_heap);
-  loop->timer_heap = NULL;
-
   lfields = uv__get_internal_fields(loop);
   uv_mutex_destroy(&lfields->loop_metrics.lock);
   uv__free(lfields);
@@ -385,13 +248,8 @@ int uv__loop_configure(uv_loop_t* loop, uv_loop_option option, va_list ap) {
 }
 
 
-int uv_backend_fd(const uv_loop_t* loop) {
-  return -1;
-}
-
-
-int uv_loop_fork(uv_loop_t* loop) {
-  return UV_ENOSYS;
+uv_os_fd_t uv_backend_fd(const uv_loop_t* loop) {
+  return loop->iocp;
 }
 
 
@@ -408,14 +266,14 @@ int uv_backend_timeout(const uv_loop_t* loop) {
   if (loop->endgame_handles)
     return 0;
 
-  if (loop->idle_handles)
+  if (!QUEUE_EMPTY(&loop->idle_handles))
     return 0;
 
   return uv__next_timeout(loop);
 }
 
 
-static void uv__poll_wine(uv_loop_t* loop, DWORD timeout) {
+static void uv__poll_wine(uv_loop_t* loop, int timeout) {
   DWORD bytes;
   ULONG_PTR key;
   OVERLAPPED* overlapped;
@@ -462,7 +320,7 @@ static void uv__poll_wine(uv_loop_t* loop, DWORD timeout) {
 
     if (overlapped) {
       /* Package was dequeued */
-      req = uv_overlapped_to_req(overlapped);
+      req = container_of(overlapped, uv_req_t, u.io.overlapped);
       uv_insert_pending_req(loop, req);
 
       /* Some time might have passed waiting for I/O,
@@ -494,7 +352,7 @@ static void uv__poll_wine(uv_loop_t* loop, DWORD timeout) {
 }
 
 
-static void uv__poll(uv_loop_t* loop, DWORD timeout) {
+static void uv__poll(uv_loop_t* loop, int timeout) {
   BOOL success;
   uv_req_t* req;
   OVERLAPPED_ENTRY overlappeds[128];
@@ -502,6 +360,7 @@ static void uv__poll(uv_loop_t* loop, DWORD timeout) {
   ULONG i;
   int repeat;
   uint64_t timeout_time;
+  BOOL gotwakeup = FALSE;
   uint64_t user_timeout;
   int reset_timeout;
 
@@ -547,7 +406,17 @@ static void uv__poll(uv_loop_t* loop, DWORD timeout) {
          * meant only to wake us up.
          */
         if (overlappeds[i].lpOverlapped) {
-          req = uv_overlapped_to_req(overlappeds[i].lpOverlapped);
+          req = container_of(overlappeds[i].lpOverlapped, uv_req_t, u.io.overlapped);
+          /* If multiple async handles were triggered we might end up with
+           * multiple UV_WAKEUP requests (IOCP completion events). They all
+           * share the same req however, so we need to be careful to only make
+           * it pending once.
+           */
+          if (req->type == UV_WAKEUP) {
+            if (gotwakeup)
+              continue;
+            gotwakeup = TRUE;
+          }
           uv_insert_pending_req(loop, req);
         }
       }
@@ -594,7 +463,7 @@ int uv_loop_alive(const uv_loop_t* loop) {
 
 
 int uv_run(uv_loop_t *loop, uv_run_mode mode) {
-  DWORD timeout;
+  int timeout;
   int r;
   int ran_pending;
 
@@ -607,13 +476,15 @@ int uv_run(uv_loop_t *loop, uv_run_mode mode) {
     uv__run_timers(loop);
 
     ran_pending = uv_process_reqs(loop);
-    uv_idle_invoke(loop);
-    uv_prepare_invoke(loop);
+    uv__run_idle(loop);
+    uv__run_prepare(loop);
 
     timeout = 0;
     if ((mode == UV_RUN_ONCE && !ran_pending) || mode == UV_RUN_DEFAULT)
       timeout = uv_backend_timeout(loop);
 
+    if (timeout == -1)
+        timeout = INFINITE;
     if (pGetQueuedCompletionStatusEx)
       uv__poll(loop, timeout);
     else
@@ -626,7 +497,7 @@ int uv_run(uv_loop_t *loop, uv_run_mode mode) {
      */
     uv__metrics_update_idle_time(loop);
 
-    uv_check_invoke(loop);
+    uv__run_check(loop);
     uv_process_endgames(loop);
 
     if (mode == UV_RUN_ONCE) {
@@ -720,10 +591,12 @@ int uv__socket_sockopt(uv_handle_t* handle, int optname, int* value) {
   return 0;
 }
 
+
 int uv_cpumask_size(void) {
   return (int)(sizeof(DWORD_PTR) * 8);
 }
 
+
 int uv__getsockpeername(const uv_handle_t* handle,
                         uv__peersockfunc func,
                         struct sockaddr* name,
diff --git a/src/win/error.c b/src/win/error.c
index 3ec984c8..c24867d7 100644
--- a/src/win/error.c
+++ b/src/win/error.c
@@ -20,10 +20,8 @@
  */
 
 #include <assert.h>
-#include <errno.h>
-#include <stdio.h>
-#include <string.h>
 #include <stdlib.h>
+#include <stdio.h> /* printf */
 
 #include "uv.h"
 #include "internal.h"
@@ -69,6 +67,7 @@ int uv_translate_sys_error(int sys_errno) {
   }
 
   switch (sys_errno) {
+    case ERROR_ACCESS_DENIED:               return UV_EACCES;
     case ERROR_NOACCESS:                    return UV_EACCES;
     case WSAEACCES:                         return UV_EACCES;
     case ERROR_ELEVATION_REQUIRED:          return UV_EACCES;
@@ -101,6 +100,7 @@ int uv_translate_sys_error(int sys_errno) {
     case WSAEHOSTUNREACH:                   return UV_EHOSTUNREACH;
     case ERROR_INSUFFICIENT_BUFFER:         return UV_EINVAL;
     case ERROR_INVALID_DATA:                return UV_EINVAL;
+    case ERROR_INVALID_NAME:                return UV_EINVAL;
     case ERROR_INVALID_PARAMETER:           return UV_EINVAL;
     case ERROR_SYMLINK_NOT_SUPPORTED:       return UV_EINVAL;
     case WSAEINVAL:                         return UV_EINVAL;
@@ -135,7 +135,6 @@ int uv_translate_sys_error(int sys_errno) {
     case ERROR_DIRECTORY:                   return UV_ENOENT;
     case ERROR_ENVVAR_NOT_FOUND:            return UV_ENOENT;
     case ERROR_FILE_NOT_FOUND:              return UV_ENOENT;
-    case ERROR_INVALID_NAME:                return UV_ENOENT;
     case ERROR_INVALID_DRIVE:               return UV_ENOENT;
     case ERROR_INVALID_REPARSE_DATA:        return UV_ENOENT;
     case ERROR_MOD_NOT_FOUND:               return UV_ENOENT;
@@ -155,7 +154,6 @@ int uv_translate_sys_error(int sys_errno) {
     case WSAENOTSOCK:                       return UV_ENOTSOCK;
     case ERROR_NOT_SUPPORTED:               return UV_ENOTSUP;
     case ERROR_BROKEN_PIPE:                 return UV_EOF;
-    case ERROR_ACCESS_DENIED:               return UV_EPERM;
     case ERROR_PRIVILEGE_NOT_HELD:          return UV_EPERM;
     case ERROR_BAD_PIPE:                    return UV_EPIPE;
     case ERROR_NO_DATA:                     return UV_EPIPE;
diff --git a/src/win/fs-event.c b/src/win/fs-event.c
index 0126c5ed..2d7d0e06 100644
--- a/src/win/fs-event.c
+++ b/src/win/fs-event.c
@@ -20,9 +20,7 @@
  */
 
 #include <assert.h>
-#include <errno.h>
-#include <stdio.h>
-#include <string.h>
+#include <stdio.h> /* printf */
 
 #include "uv.h"
 #include "internal.h"
@@ -146,7 +144,7 @@ int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle) {
   handle->short_filew = NULL;
   handle->dirw = NULL;
 
-  UV_REQ_INIT(&handle->req, UV_FS_EVENT_REQ);
+  UV_REQ_INIT(loop, &handle->req, UV_FS_EVENT_REQ);
   handle->req.data = handle;
 
   return 0;
@@ -487,7 +485,7 @@ void uv_process_fs_event_req(uv_loop_t* loop, uv_req_t* req,
                 uv_fatal_error(ERROR_OUTOFMEMORY, "uv__malloc");
               }
 
-              _snwprintf(filenamew, size, L"%s\\%.*s", handle->dirw,
+              swprintf(filenamew, size, L"%s\\%.*s", handle->dirw,
                 file_info->FileNameLength / (DWORD)sizeof(WCHAR),
                 file_info->FileName);
 
diff --git a/src/win/fs-fd-hash-inl.h b/src/win/fs-fd-hash-inl.h
index 0b532af1..759c1062 100644
--- a/src/win/fs-fd-hash-inl.h
+++ b/src/win/fs-fd-hash-inl.h
@@ -51,7 +51,7 @@ struct uv__fd_info_s {
 };
 
 struct uv__fd_hash_entry_s {
-  uv_file fd;
+  uv_os_fd_t fd;
   struct uv__fd_info_s info;
 };
 
@@ -91,7 +91,7 @@ INLINE static void uv__fd_hash_init(void) {
 
 #define FIND_COMMON_VARIABLES                                                \
   unsigned i;                                                                \
-  unsigned bucket = fd % ARRAY_SIZE(uv__fd_hash);                            \
+  unsigned bucket = ((uintptr_t) fd) % ARRAY_SIZE(uv__fd_hash);              \
   struct uv__fd_hash_entry_s* entry_ptr = NULL;                              \
   struct uv__fd_hash_entry_group_s* group_ptr;                               \
   struct uv__fd_hash_bucket_s* bucket_ptr = &uv__fd_hash[bucket];
@@ -119,7 +119,7 @@ INLINE static void uv__fd_hash_init(void) {
       FIND_IN_GROUP_PTR(UV__FD_HASH_GROUP_SIZE);                             \
   } while (0)
 
-INLINE static int uv__fd_hash_get(int fd, struct uv__fd_info_s* info) {
+INLINE static int uv__fd_hash_get(uv_os_fd_t fd, struct uv__fd_info_s* info) {
   FIND_COMMON_VARIABLES
 
   uv_mutex_lock(&uv__fd_hash_mutex);
@@ -134,7 +134,7 @@ INLINE static int uv__fd_hash_get(int fd, struct uv__fd_info_s* info) {
   return entry_ptr != NULL;
 }
 
-INLINE static void uv__fd_hash_add(int fd, struct uv__fd_info_s* info) {
+INLINE static void uv__fd_hash_add(uv_os_fd_t fd, struct uv__fd_info_s* info) {
   FIND_COMMON_VARIABLES
 
   uv_mutex_lock(&uv__fd_hash_mutex);
@@ -164,7 +164,7 @@ INLINE static void uv__fd_hash_add(int fd, struct uv__fd_info_s* info) {
   uv_mutex_unlock(&uv__fd_hash_mutex);
 }
 
-INLINE static int uv__fd_hash_remove(int fd, struct uv__fd_info_s* info) {
+INLINE static int uv__fd_hash_remove(uv_os_fd_t fd, struct uv__fd_info_s* info) {
   FIND_COMMON_VARIABLES
 
   uv_mutex_lock(&uv__fd_hash_mutex);
diff --git a/src/win/fs.c b/src/win/fs.c
index 8a801749..5e3bd214 100644
--- a/src/win/fs.c
+++ b/src/win/fs.c
@@ -23,10 +23,9 @@
 #include <stdlib.h>
 #include <direct.h>
 #include <errno.h>
-#include <fcntl.h>
-#include <io.h>
 #include <limits.h>
-#include <sys/stat.h>
+#include <math.h>
+#include <sys/stat.h> /* stat constants */
 #include <sys/utime.h>
 #include <stdio.h>
 
@@ -36,11 +35,17 @@
 #include "handle-inl.h"
 #include "fs-fd-hash-inl.h"
 
+#include <wincrypt.h>
+#include <accctrl.h> /* for SE_FILE_OBJECT constant */
+#include <aclapi.h>  /* for SetEntriesInAcl() */
+
 
 #define UV_FS_FREE_PATHS         0x0002
 #define UV_FS_FREE_PTR           0x0008
 #define UV_FS_CLEANEDUP          0x0010
 
+/* number of attempts to generate a unique directory name before declaring failure */
+#define TMP_MAX 32767
 
 #define INIT(subtype)                                                         \
   do {                                                                        \
@@ -67,6 +72,26 @@
   }                                                                           \
   while (0)
 
+#define POST0                                                                 \
+  do {                                                                        \
+    if (cb != NULL) {                                                         \
+      uv__req_register(loop, req);                                            \
+      uv__work_submit(loop,                                                   \
+                      &req->work_req,                                         \
+                      UV__WORK_FAST_IO,                                       \
+                      uv__fs_work,                                            \
+                      uv__fs_done);                                           \
+      return 0;                                                               \
+    }                                                                         \
+    else {                                                                    \
+      uv__fs_work(&req->work_req);                                            \
+      if (req->result < 0)                                                    \
+        return req->result;                                                   \
+      return 0;                                                               \
+    }                                                                         \
+  }                                                                           \
+  while (0)
+
 #define SET_REQ_RESULT(req, result_value)                                   \
   do {                                                                      \
     req->result = (result_value);                                           \
@@ -85,8 +110,12 @@
     req->sys_errno_ = (sys_errno);                                          \
   } while (0)
 
-#define VERIFY_FD(fd, req)                                                  \
-  if (fd == -1) {                                                           \
+#define VERIFY_HANDLE(hFile, req)                                           \
+  if (hFile == UV_STDIN_FD ||                                               \
+      hFile == UV_STDOUT_FD ||                                              \
+      hFile == UV_STDERR_FD)                                                \
+    hFile = GetStdHandle((DWORD)(uintptr_t) hFile);                         \
+  if (hFile == NULL || hFile == INVALID_HANDLE_VALUE) {                     \
     req->result = UV_EBADF;                                                 \
     req->sys_errno_ = ERROR_INVALID_HANDLE;                                 \
     return;                                                                 \
@@ -250,8 +279,7 @@ INLINE static int fs__capture_path(uv_fs_t* req, const char* path,
 INLINE static void uv_fs_req_init(uv_loop_t* loop, uv_fs_t* req,
     uv_fs_type fs_type, const uv_fs_cb cb) {
   uv__once_init();
-  UV_REQ_INIT(req, UV_FS);
-  req->loop = loop;
+  UV_REQ_INIT(loop, req, UV_FS);
   req->flags = 0;
   req->fs_type = fs_type;
   req->sys_errno_ = 0;
@@ -453,7 +481,7 @@ void fs__open(uv_fs_t* req) {
   DWORD disposition;
   DWORD attributes = 0;
   HANDLE file;
-  int fd, current_umask;
+  int current_umask;
   int flags = req->fs.info.file_flags;
   struct uv__fd_info_s fd_info;
 
@@ -635,22 +663,6 @@ void fs__open(uv_fs_t* req) {
     return;
   }
 
-  fd = _open_osfhandle((intptr_t) file, flags);
-  if (fd < 0) {
-    /* The only known failure mode for _open_osfhandle() is EMFILE, in which
-     * case GetLastError() will return zero. However we'll try to handle other
-     * errors as well, should they ever occur.
-     */
-    if (errno == EMFILE)
-      SET_REQ_UV_ERROR(req, UV_EMFILE, ERROR_TOO_MANY_OPEN_FILES);
-    else if (GetLastError() != ERROR_SUCCESS)
-      SET_REQ_WIN32_ERROR(req, GetLastError());
-    else
-      SET_REQ_WIN32_ERROR(req, (DWORD) UV_UNKNOWN);
-    CloseHandle(file);
-    return;
-  }
-
   if (flags & UV_FS_O_FILEMAP) {
     FILE_STANDARD_INFO file_info;
     if (!GetFileInformationByHandleEx(file,
@@ -692,10 +704,10 @@ void fs__open(uv_fs_t* req) {
       }
     }
 
-    uv__fd_hash_add(fd, &fd_info);
+    uv__fd_hash_add(file, &fd_info);
   }
 
-  SET_REQ_RESULT(req, fd);
+  SET_REQ_RESULT(req, (uintptr_t)file);
   return;
 
  einval:
@@ -703,29 +715,26 @@ void fs__open(uv_fs_t* req) {
 }
 
 void fs__close(uv_fs_t* req) {
-  int fd = req->file.fd;
+  HANDLE handle = req->file.hFile;
   int result;
   struct uv__fd_info_s fd_info;
 
-  VERIFY_FD(fd, req);
+  if (handle == UV_STDIN_FD || handle == UV_STDOUT_FD || handle == UV_STDERR_FD) {
+    result = 0;
+  } else {
+    VERIFY_HANDLE(handle, req);
 
-  if (uv__fd_hash_remove(fd, &fd_info)) {
-    if (fd_info.mapping != INVALID_HANDLE_VALUE) {
-      CloseHandle(fd_info.mapping);
+    if (uv__fd_hash_remove(handle, &fd_info)) {
+      if (fd_info.mapping != INVALID_HANDLE_VALUE) {
+        CloseHandle(fd_info.mapping);
+      }
     }
-  }
 
-  if (fd > 2)
-    result = _close(fd);
-  else
-    result = 0;
+    result = CloseHandle(handle);
+  }
 
-  /* _close doesn't set _doserrno on failure, but it does always set errno
-   * to EBADF on failure.
-   */
-  if (result == -1) {
-    assert(errno == EBADF);
-    SET_REQ_UV_ERROR(req, UV_EBADF, ERROR_INVALID_HANDLE);
+  if (result == 0) {
+    SET_REQ_WIN32_ERROR(req, GetLastError());
   } else {
     SET_REQ_RESULT(req, 0);
   }
@@ -753,7 +762,7 @@ LONG fs__filemap_ex_filter(LONG excode, PEXCEPTION_POINTERS pep,
 
 
 void fs__read_filemap(uv_fs_t* req, struct uv__fd_info_s* fd_info) {
-  int fd = req->file.fd; /* VERIFY_FD done in fs__read */
+  HANDLE file = req->file.hFile; /* VERIFY_HANDLE done in fs__read */
   int rw_flags = fd_info->flags &
     (UV_FS_O_RDONLY | UV_FS_O_WRONLY | UV_FS_O_RDWR);
   size_t read_size, done_read;
@@ -842,7 +851,7 @@ void fs__read_filemap(uv_fs_t* req, struct uv__fd_info_s* fd_info) {
 
   if (req->fs.info.offset == -1) {
     fd_info->current_pos = end_pos;
-    uv__fd_hash_add(fd, fd_info);
+    uv__fd_hash_add(file, fd_info);
   }
 
   SET_REQ_RESULT(req, read_size);
@@ -850,9 +859,8 @@ void fs__read_filemap(uv_fs_t* req, struct uv__fd_info_s* fd_info) {
 }
 
 void fs__read(uv_fs_t* req) {
-  int fd = req->file.fd;
+  HANDLE handle = req->file.hFile;
   int64_t offset = req->fs.info.offset;
-  HANDLE handle;
   OVERLAPPED overlapped, *overlapped_ptr;
   LARGE_INTEGER offset_;
   DWORD bytes;
@@ -864,21 +872,15 @@ void fs__read(uv_fs_t* req) {
   int restore_position;
   struct uv__fd_info_s fd_info;
 
-  VERIFY_FD(fd, req);
+  VERIFY_HANDLE(handle, req);
 
-  if (uv__fd_hash_get(fd, &fd_info)) {
+  if (uv__fd_hash_get(handle, &fd_info)) {
     fs__read_filemap(req, &fd_info);
     return;
   }
 
   zero_offset.QuadPart = 0;
   restore_position = 0;
-  handle = uv__get_osfhandle(fd);
-
-  if (handle == INVALID_HANDLE_VALUE) {
-    SET_REQ_WIN32_ERROR(req, ERROR_INVALID_HANDLE);
-    return;
-  }
 
   if (offset != -1) {
     memset(&overlapped, 0, sizeof overlapped);
@@ -929,7 +931,6 @@ void fs__read(uv_fs_t* req) {
 
 void fs__write_filemap(uv_fs_t* req, HANDLE file,
                        struct uv__fd_info_s* fd_info) {
-  int fd = req->file.fd; /* VERIFY_FD done in fs__write */
   int force_append = fd_info->flags & UV_FS_O_APPEND;
   int rw_flags = fd_info->flags &
     (UV_FS_O_RDONLY | UV_FS_O_WRONLY | UV_FS_O_RDWR);
@@ -988,12 +989,12 @@ void fs__write_filemap(uv_fs_t* req, HANDLE file,
       fd_info->mapping = INVALID_HANDLE_VALUE;
       fd_info->size.QuadPart = 0;
       fd_info->current_pos.QuadPart = 0;
-      uv__fd_hash_add(fd, fd_info);
+      uv__fd_hash_add(file, fd_info);
       return;
     }
 
     fd_info->size = end_pos;
-    uv__fd_hash_add(fd, fd_info);
+    uv__fd_hash_add(file, fd_info);
   }
 
   view_offset = pos.QuadPart % uv__allocation_granularity;
@@ -1042,7 +1043,7 @@ void fs__write_filemap(uv_fs_t* req, HANDLE file,
 
   if (req->fs.info.offset == -1) {
     fd_info->current_pos = end_pos;
-    uv__fd_hash_add(fd, fd_info);
+    uv__fd_hash_add(file, fd_info);
   }
 
   GetSystemTimeAsFileTime(&ft);
@@ -1052,9 +1053,8 @@ void fs__write_filemap(uv_fs_t* req, HANDLE file,
 }
 
 void fs__write(uv_fs_t* req) {
-  int fd = req->file.fd;
+  HANDLE handle = req->file.hFile;
   int64_t offset = req->fs.info.offset;
-  HANDLE handle;
   OVERLAPPED overlapped, *overlapped_ptr;
   LARGE_INTEGER offset_;
   DWORD bytes;
@@ -1065,17 +1065,12 @@ void fs__write(uv_fs_t* req) {
   int restore_position;
   struct uv__fd_info_s fd_info;
 
-  VERIFY_FD(fd, req);
+  VERIFY_HANDLE(handle, req);
 
   zero_offset.QuadPart = 0;
   restore_position = 0;
-  handle = uv__get_osfhandle(fd);
-  if (handle == INVALID_HANDLE_VALUE) {
-    SET_REQ_WIN32_ERROR(req, ERROR_INVALID_HANDLE);
-    return;
-  }
 
-  if (uv__fd_hash_get(fd, &fd_info)) {
+  if (uv__fd_hash_get(handle, &fd_info)) {
     fs__write_filemap(req, handle, &fd_info);
     return;
   }
@@ -1303,7 +1298,6 @@ void fs__mkdtemp(uv_fs_t* req) {
 
 static int fs__mkstemp_func(uv_fs_t* req) {
   HANDLE file;
-  int fd;
 
   file = CreateFileW(req->file.pathw,
                      GENERIC_READ | GENERIC_WRITE,
@@ -1327,23 +1321,7 @@ static int fs__mkstemp_func(uv_fs_t* req) {
     return 0;
   }
 
-  fd = _open_osfhandle((intptr_t) file, 0);
-  if (fd < 0) {
-    /* The only known failure mode for _open_osfhandle() is EMFILE, in which
-     * case GetLastError() will return zero. However we'll try to handle other
-     * errors as well, should they ever occur.
-     */
-    if (errno == EMFILE)
-      SET_REQ_UV_ERROR(req, UV_EMFILE, ERROR_TOO_MANY_OPEN_FILES);
-    else if (GetLastError() != ERROR_SUCCESS)
-      SET_REQ_WIN32_ERROR(req, GetLastError());
-    else
-      SET_REQ_WIN32_ERROR(req, UV_UNKNOWN);
-    CloseHandle(file);
-    return 1;
-  }
-
-  SET_REQ_RESULT(req, fd);
+  SET_REQ_RESULT(req, (uintptr_t) file);
 
   return 1;
 }
@@ -1917,17 +1895,9 @@ static void fs__lstat(uv_fs_t* req) {
 
 
 static void fs__fstat(uv_fs_t* req) {
-  int fd = req->file.fd;
-  HANDLE handle;
-
-  VERIFY_FD(fd, req);
+  HANDLE handle = req->file.hFile;
 
-  handle = uv__get_osfhandle(fd);
-
-  if (handle == INVALID_HANDLE_VALUE) {
-    SET_REQ_WIN32_ERROR(req, ERROR_INVALID_HANDLE);
-    return;
-  }
+  VERIFY_HANDLE(handle, req);
 
   if (fs__stat_handle(handle, &req->statbuf, 0) != 0) {
     SET_REQ_WIN32_ERROR(req, GetLastError());
@@ -1950,12 +1920,12 @@ static void fs__rename(uv_fs_t* req) {
 
 
 INLINE static void fs__sync_impl(uv_fs_t* req) {
-  int fd = req->file.fd;
+  HANDLE handle = req->file.hFile;
   int result;
 
-  VERIFY_FD(fd, req);
+  VERIFY_HANDLE(handle, req);
 
-  result = FlushFileBuffers(uv__get_osfhandle(fd)) ? 0 : -1;
+  result = FlushFileBuffers(handle) ? 0 : -1;
   if (result == -1) {
     SET_REQ_WIN32_ERROR(req, GetLastError());
   } else {
@@ -1975,18 +1945,16 @@ static void fs__fdatasync(uv_fs_t* req) {
 
 
 static void fs__ftruncate(uv_fs_t* req) {
-  int fd = req->file.fd;
   HANDLE handle;
   struct uv__fd_info_s fd_info = { 0 };
   NTSTATUS status;
   IO_STATUS_BLOCK io_status;
   FILE_END_OF_FILE_INFORMATION eof_info;
 
-  VERIFY_FD(fd, req);
+  handle = req->file.hFile;
+  VERIFY_HANDLE(handle, req);
 
-  handle = uv__get_osfhandle(fd);
-
-  if (uv__fd_hash_get(fd, &fd_info)) {
+  if (uv__fd_hash_get(handle, &fd_info)) {
     if (fd_info.is_directory) {
       SET_REQ_WIN32_ERROR(req, ERROR_ACCESS_DENIED);
       return;
@@ -2015,7 +1983,7 @@ static void fs__ftruncate(uv_fs_t* req) {
       fd_info.mapping = INVALID_HANDLE_VALUE;
       fd_info.size.QuadPart = 0;
       fd_info.current_pos.QuadPart = 0;
-      uv__fd_hash_add(fd, &fd_info);
+      uv__fd_hash_add(handle, &fd_info);
       return;
     }
   }
@@ -2040,12 +2008,12 @@ static void fs__ftruncate(uv_fs_t* req) {
         fd_info.mapping = INVALID_HANDLE_VALUE;
         fd_info.size.QuadPart = 0;
         fd_info.current_pos.QuadPart = 0;
-        uv__fd_hash_add(fd, &fd_info);
+        uv__fd_hash_add(handle, &fd_info);
         return;
       }
     }
 
-    uv__fd_hash_add(fd, &fd_info);
+    uv__fd_hash_add(handle, &fd_info);
   }
 }
 
@@ -2088,41 +2056,47 @@ static void fs__copyfile(uv_fs_t* req) {
 
 
 static void fs__sendfile(uv_fs_t* req) {
-  int fd_in = req->file.fd, fd_out = req->fs.info.fd_out;
+  HANDLE fd_in = req->file.hFile;
+  HANDLE fd_out = req->fs.info.hFile_out;
   size_t length = req->fs.info.bufsml[0].len;
   int64_t offset = req->fs.info.offset;
   const size_t max_buf_size = 65536;
   size_t buf_size = length < max_buf_size ? length : max_buf_size;
-  int n, result = 0;
-  int64_t result_offset = 0;
+  int result = 0;
+  BOOL io_success = 1;
   char* buf = (char*) uv__malloc(buf_size);
   if (!buf) {
     uv_fatal_error(ERROR_OUTOFMEMORY, "uv__malloc");
   }
 
   if (offset != -1) {
-    result_offset = _lseeki64(fd_in, offset, SEEK_SET);
+    LARGE_INTEGER offset_u;
+    offset_u.QuadPart = offset;
+    io_success = SetFilePointerEx(fd_in, offset_u, NULL, FILE_BEGIN);
   }
 
-  if (result_offset == -1) {
+  if (!io_success) {
     result = -1;
   } else {
     while (length > 0) {
-      n = _read(fd_in, buf, length < buf_size ? length : buf_size);
-      if (n == 0) {
-        break;
-      } else if (n == -1) {
+      DWORD n, n_out;
+      io_success = ReadFile(fd_in, buf, length < buf_size ? length : buf_size, &n, NULL);
+      if (!io_success) {
         result = -1;
         break;
       }
+      else if (n == 0) {
+        break;
+      }
 
       length -= n;
 
-      n = _write(fd_out, buf, n);
-      if (n == -1) {
+      io_success = WriteFile(fd_out, buf, n, &n_out, NULL);
+      if (!io_success) {
         result = -1;
         break;
       }
+      /* hopefully n == n_out here (e.g. that fd_out wasn't opened non-blocking mode) */
 
       result += n;
     }
@@ -2143,43 +2117,459 @@ static void fs__access(uv_fs_t* req) {
   }
 
   /*
-   * Access is possible if
-   * - write access wasn't requested,
-   * - or the file isn't read-only,
-   * - or it's a directory.
-   * (Directories cannot be read-only on Windows.)
+   * If write access was requested, ensure that either
+   * the requested file is not marked as READONLY,
+   * or that it's actually a directory (directories
+   * cannot be read-only in Windows)
    */
-  if (!(req->fs.info.mode & W_OK) ||
-      !(attr & FILE_ATTRIBUTE_READONLY) ||
-      (attr & FILE_ATTRIBUTE_DIRECTORY)) {
-    SET_REQ_RESULT(req, 0);
-  } else {
+  if ((req->fs.info.mode & W_OK) &&
+      ((attr & FILE_ATTRIBUTE_READONLY) ||
+       !(attr & FILE_ATTRIBUTE_DIRECTORY))) {
     SET_REQ_WIN32_ERROR(req, UV_EPERM);
+    return;
+  }
+
+  /*
+   * If executable access was requested, we must check
+   * with the AccessCheck() ACL call.  This is mildly
+   * expensive, so only do it if `X_OK` was requested.
+   */
+  if (req->fs.info.mode & X_OK) {
+    DWORD sdLen = 0, err = 0, tokenAccess = 0, executeAccessRights = 0,
+          grantedAccess = 0, privilegesLen = 0;
+    SECURITY_INFORMATION si = NULL;
+    PSECURITY_DESCRIPTOR sd = NULL;
+    HANDLE hToken = NULL, hImpersonatedToken = NULL;
+    GENERIC_MAPPING mapping = { 0xFFFFFFFF };
+    PRIVILEGE_SET privileges = { 0 };
+    BOOL result = FALSE;
+
+    /*
+     * First, we must allocate enough space. We do that
+     * by first passing in a zero-length null pointer,
+     * storing the desired length into `sd_length`.
+     * We expect this call to fail with a certain error code.
+     */
+     si = OWNER_SECURITY_INFORMATION |
+          GROUP_SECURITY_INFORMATION |
+          DACL_SECURITY_INFORMATION;
+    if (GetFileSecurityW(req->file.pathw, si, NULL, 0, &sdLen)) {
+      SET_REQ_RESULT(req, UV_UNKNOWN);
+      return;
+    }
+    err = GetLastError();
+    if (ERROR_INSUFFICIENT_BUFFER != err) {
+      SET_REQ_WIN32_ERROR(req, err);
+      return;
+    }
+
+    /* Now that we know how big `sd` must be, allocate it */
+    sd = (PSECURITY_DESCRIPTOR)uv__malloc(sdLen);
+    if (!sd) {
+      uv_fatal_error(ERROR_OUTOFMEMORY, "uv__malloc");
+    }
+
+    /* Call `GetFileSecurity()` with the requisite `sd` structure. */
+    if (!GetFileSecurityW(req->file.pathw, si, sd, sdLen, &sdLen)) {
+      SET_REQ_WIN32_ERROR(req, GetLastError());
+      goto accesscheck_cleanup;
+    }
+
+    /*
+     * Next we need to create an impersonation token representing
+     * the current user and the current process.
+     */
+    tokenAccess = TOKEN_IMPERSONATE |
+                  TOKEN_QUERY |
+                  TOKEN_DUPLICATE |
+                  STANDARD_RIGHTS_READ;
+    if (!OpenProcessToken(GetCurrentProcess(), tokenAccess, &hToken )) {
+      SET_REQ_WIN32_ERROR(req, GetLastError());
+      goto accesscheck_cleanup;
+    }
+    if (!DuplicateToken(hToken, SecurityImpersonation, &hImpersonatedToken)) {
+      SET_REQ_WIN32_ERROR(req, GetLastError());
+      goto accesscheck_cleanup;
+    }
+
+    /*
+     * Next, construct a mapping from generic access rights to
+     * the more specific access rights that AccessCheck expects.
+     */
+    executeAccessRights = FILE_GENERIC_EXECUTE;
+    mapping.GenericExecute = FILE_GENERIC_EXECUTE;
+    MapGenericMask(&executeAccessRights, &mapping);
+
+    privilegesLen = sizeof(privileges);
+    result = FALSE;
+    if (AccessCheck(sd,
+                    hImpersonatedToken,
+                    executeAccessRights,
+                    &mapping,
+                    &privileges,
+                    &privilegesLen,
+                    &grantedAccess,
+                    &result)) {
+      /*
+       * If AccessCheck passes, nothing went wrong, but
+       * we must still check that we have access.
+       */
+      if (!result) {
+        SET_REQ_WIN32_ERROR(req, UV_EPERM);
+        goto accesscheck_cleanup;
+      }
+    } else {
+      /*
+       * This signifies that something went wrong with the
+       * actual AccessCheck() invocation itself.
+       */
+      SET_REQ_WIN32_ERROR(req, GetLastError());
+      goto accesscheck_cleanup;
+    }
+
+accesscheck_cleanup:
+    uv__free(sd);
+    if (hImpersonatedToken != NULL) {
+      CloseHandle(hImpersonatedToken);
+    }
+    if (hToken != NULL) {
+      CloseHandle(hToken);
+    }
+    /*
+     * If the result is false, return immediately.
+     * Some error code has been set in the `req` already.
+     */
+    if (!result) {
+      return;
+    }
   }
 
+  /* If we get to the end, everything worked out. */
+  SET_REQ_SUCCESS(req);
 }
 
+static void build_access_struct(EXPLICIT_ACCESS_W* ea, PSID owner,
+                                TRUSTEE_TYPE user_type, mode_t mode_triplet,
+                                ACCESS_MODE allow_deny) {
+  /*
+   * We map the typical POSIX mode bits r/w/x as the Windows
+   * FILE_GENERIC_{READ,WRITE,EXECUTE} permissions with a little bit of of extra permissions
+   * added on, to deal with directories and win32 idiosyncrasies.
+   */
+  ZeroMemory(ea, sizeof(EXPLICIT_ACCESS_W));
+
+  /*
+   * Initialize two EXLPICIT_ACCESS structures; one to explicitly allow things, the
+   * other to explicitly deny them.  We leave no middle ground for inheritance to mess
+   * things up.
+   */
+  ea->grfAccessPermissions = 0;
+  ea->grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
+  ea->Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
+  ea->Trustee.TrusteeForm = TRUSTEE_IS_SID;
+  ea->Trustee.TrusteeType = user_type;
+  ea->Trustee.ptstrName = owner;
+
+  ea->grfAccessMode = allow_deny;
+
+  /*
+   * We would like to use FILE_GENERIC_* for everything, but unfortunately:
+   *
+   * - This does not include the rights for a directory to delete its children,
+   *   so we include that manually with the "write" permission by including the
+   *   FILE_ADD_SUBDIRECTORY and FILE_DELETE_CHILD permissions.
+   * - All FILE_GENERIC_* defines share the SYNCHRONIZE permission, which means
+   *   that if we deny FILE_GENERIC_WRITE but allow FILE_GENERIC_READ, that one
+   *   permission will still be denied.  We work around this by only denying the
+   *   SYNCHRONIZE permission if read is not allowed, allowing it otherwise.
+   * - We want to be able to set things as read-only even after the ACL has been
+   *   set, so we never give up the FILE_WRITE_ATTRIBUTES permission, unless we're
+   *   actually being set to 0o000.
+   */
+
+  if (mode_triplet & 0x1) {
+    ea->grfAccessPermissions |= STANDARD_RIGHTS_EXECUTE | FILE_READ_ATTRIBUTES | FILE_EXECUTE;
+    if (allow_deny == GRANT_ACCESS) {
+      ea->grfAccessPermissions |= SYNCHRONIZE | FILE_WRITE_ATTRIBUTES;
+    }
+  }
+
+  if (mode_triplet & 0x2) {
+    ea->grfAccessPermissions |= STANDARD_RIGHTS_WRITE | FILE_WRITE_DATA | FILE_WRITE_EA | FILE_APPEND_DATA | FILE_ADD_SUBDIRECTORY | FILE_DELETE_CHILD | DELETE;
+    if (allow_deny == GRANT_ACCESS) {
+      ea->grfAccessPermissions |= SYNCHRONIZE | FILE_WRITE_ATTRIBUTES;
+    }
+  }
+
+  if (mode_triplet & 0x4) {
+    ea->grfAccessPermissions |= FILE_GENERIC_READ | FILE_WRITE_ATTRIBUTES;
+  }
+}
 
 static void fs__chmod(uv_fs_t* req) {
-  int result = _wchmod(req->file.pathw, req->fs.info.mode);
-  if (result == -1)
-    SET_REQ_WIN32_ERROR(req, _doserrno);
-  else
-    SET_REQ_RESULT(req, 0);
+  PACL pOldDACL = NULL, pNewDACL = NULL;
+  PSID psidOwner = NULL, psidGroup = NULL, psidEveryone = NULL,
+       psidNull = NULL, psidCreatorGroup = NULL;
+  PSECURITY_DESCRIPTOR pSD = NULL;
+  PEXPLICIT_ACCESS_W ea = NULL, pOldEAs = NULL;
+  SECURITY_INFORMATION si = NULL;
+  DWORD numGroups = 0, tokenAccess = 0, u_mode = 0, g_mode = 0, o_mode = 0,
+        u_deny_mode = 0, g_deny_mode = 0, attr = 0, new_attr = 0;
+  HANDLE hToken = NULL, hImpersonatedToken = NULL;
+  ULONG numOldEAs = 0, numNewEAs = 0, numOtherGroups = 0,
+        ea_idx = 0, ea_write_idx = 0;
+
+  /* Create well-known SIDs for various global groups */
+  SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
+  SID_IDENTIFIER_AUTHORITY SIDAuthNull = SECURITY_NULL_SID_AUTHORITY;
+  SID_IDENTIFIER_AUTHORITY SIDAuthCreator = SECURITY_CREATOR_SID_AUTHORITY;
+
+  if (!AllocateAndInitializeSid(&SIDAuthWorld, 1, SECURITY_WORLD_RID,
+                                0, 0, 0, 0, 0, 0, 0, &psidEveryone) ||
+      !AllocateAndInitializeSid(&SIDAuthNull, 1, SECURITY_NULL_RID,
+                                0, 0, 0, 0, 0, 0, 0, &psidNull) ||
+      !AllocateAndInitializeSid(&SIDAuthCreator, 1, SECURITY_CREATOR_GROUP_RID,
+                                0, 0, 0, 0, 0, 0, 0, &psidCreatorGroup) ||
+      !AllocateAndInitializeSid(&SIDAuthWorld, 1, SECURITY_WORLD_RID,
+                                0, 0, 0, 0, 0, 0, 0, &psidEveryone)) {
+      SET_REQ_WIN32_ERROR(req, GetLastError());
+      goto chmod_cleanup;
+  }
+
+  /* Get the old DACL so that we can merge into it */
+  si = OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
+       DACL_SECURITY_INFORMATION;
+  if (ERROR_SUCCESS != GetNamedSecurityInfoW(req->file.pathw, SE_FILE_OBJECT,
+                                             si, &psidOwner, &psidGroup,
+                                             &pOldDACL, NULL, &pSD)) {
+    SET_REQ_WIN32_ERROR(req, GetLastError());
+    goto chmod_cleanup;
+  }
+
+  /* Extract EAs from old DACL */
+  if (ERROR_SUCCESS != GetExplicitEntriesFromAclW(pOldDACL, &numOldEAs,
+                                                  &pOldEAs)) {
+    SET_REQ_WIN32_ERROR(req, GetLastError());
+    goto chmod_cleanup;
+  }
+
+  /*
+   * Work around Win32 bug where GetExplicitEntriesFromAclW() fails on newly-created files;
+   * We fix it by forcibly clearing some kind of cache by setting the security info with the
+   * old DACL, then attempting to read it in again.
+   */
+  if (numOldEAs != pOldDACL->AceCount) {
+    if (ERROR_SUCCESS != SetNamedSecurityInfoW(
+              req->file.pathw,
+              SE_FILE_OBJECT,
+              DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
+              NULL, NULL, pOldDACL, NULL)) {
+      SET_REQ_WIN32_ERROR(req, GetLastError());
+      goto chmod_cleanup;
+    }
+    if (pSD != NULL) {
+      LocalFree(pSD);
+      pSD = NULL;
+    }
+    if (ERROR_SUCCESS != GetNamedSecurityInfoW(req->file.pathw, SE_FILE_OBJECT,
+                                               si, &psidOwner, &psidGroup,
+                                               &pOldDACL, NULL, &pSD)) {
+      SET_REQ_WIN32_ERROR(req, GetLastError());
+      goto chmod_cleanup;
+    }
+    if (pOldEAs != NULL) {
+      LocalFree(pOldEAs);
+      pOldEAs = NULL;
+    }
+    if (ERROR_SUCCESS != GetExplicitEntriesFromAclW(pOldDACL, &numOldEAs,
+                                                    &pOldEAs)) {
+      SET_REQ_WIN32_ERROR(req, GetLastError());
+      goto chmod_cleanup;
+    }
+  }
+
+  /* If the file does not contain a group owner, we will use the user's 'Creator Group ID' instead */
+  if (EqualSid(psidGroup, psidNull)) {
+    psidGroup = psidCreatorGroup;
+  }
+
+  /*
+   * We next need to scan all groups that the current user "belongs" to, in order to
+   * set the permissions for those groups to be the same as the "group" bit; so first
+   * we collect a list of group PSIDs:
+   */
+  tokenAccess = TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_DUPLICATE |
+                STANDARD_RIGHTS_READ;
+  if (!OpenProcessToken(GetCurrentProcess(), tokenAccess, &hToken )) {
+    SET_REQ_WIN32_ERROR(req, GetLastError());
+    goto chmod_cleanup;
+  }
+  if (!DuplicateToken(hToken, SecurityImpersonation, &hImpersonatedToken)) {
+    SET_REQ_WIN32_ERROR(req, GetLastError());
+    goto chmod_cleanup;
+  }
+
+  /* Iterate over all old ACEs, looking for groups that we belong to */
+  for (ea_idx=0; ea_idx<numOldEAs; ++ea_idx) {
+    BOOL isMember = FALSE;
+    PSID pEASid = (PSID)pOldEAs[ea_idx].Trustee.ptstrName;
+    /* Skip this EA if it isn't an SID, or it is "Everyone" or our actual group */
+    if (pOldEAs[ea_idx].Trustee.TrusteeForm != TRUSTEE_IS_SID ||
+        EqualSid(pEASid, psidEveryone) ||
+        EqualSid(pEASid, psidGroup)) {
+      continue;
+    }
+
+    /* Check to see if our user is a member of this group */
+    if (!CheckTokenMembership(hImpersonatedToken, pEASid, &isMember)) {
+      SET_REQ_WIN32_ERROR(req, GetLastError());
+      goto chmod_cleanup;
+    }
+
+    /* If we're a member, then count it */
+    if (isMember) {
+      numOtherGroups++;
+    }
+  }
+
+  /* Create an ACE for each triplet (user, group, other) */
+  numNewEAs = 8 + 3*numOtherGroups;
+  ea = (PEXPLICIT_ACCESS_W) malloc(sizeof(EXPLICIT_ACCESS_W)*numNewEAs);
+  u_mode = ((req->fs.info.mode & S_IRWXU) >> 6);
+  g_mode = ((req->fs.info.mode & S_IRWXG) >> 3);
+  o_mode = ((req->fs.info.mode & S_IRWXO) >> 0);
+
+  /* We start by revoking previous permissions for trustees we care about */
+  build_access_struct(&ea[0], psidOwner,    TRUSTEE_IS_USER,  0, REVOKE_ACCESS);
+  build_access_struct(&ea[1], psidGroup,    TRUSTEE_IS_GROUP, 0, REVOKE_ACCESS);
+  build_access_struct(&ea[2], psidEveryone, TRUSTEE_IS_GROUP, 0, REVOKE_ACCESS);
+
+  /*
+   * We also add explicit denies to user and group if the user shouldn't have
+   * a permission but the group or everyone can, for instance.
+   */
+  u_deny_mode = (~u_mode) & (g_mode | o_mode);
+  g_deny_mode = (~g_mode) & o_mode;
+  build_access_struct(&ea[3], psidOwner, TRUSTEE_IS_USER,  u_deny_mode, DENY_ACCESS);
+  build_access_struct(&ea[4], psidGroup, TRUSTEE_IS_GROUP, g_deny_mode, DENY_ACCESS);
+
+  /* Next, add explicit allows for (owner, group, other) */
+  build_access_struct(&ea[5], psidOwner,    TRUSTEE_IS_USER,  u_mode, SET_ACCESS);
+  build_access_struct(&ea[6], psidGroup,    TRUSTEE_IS_GROUP, g_mode, SET_ACCESS);
+  build_access_struct(&ea[7], psidEveryone, TRUSTEE_IS_GROUP, o_mode, SET_ACCESS);
+
+  /*
+   * Iterate over all old ACEs, looking for groups that we belong to, and setting
+   * the appropriate access bits for those groups (as g_mode)
+   */
+  ea_write_idx = 8;
+  for (ea_idx=0; ea_idx<numOldEAs; ++ea_idx) {
+    BOOL isMember = FALSE;
+    PSID pEASid = (PSID)pOldEAs[ea_idx].Trustee.ptstrName;
+    /* Skip this EA if it isn't an SID, or it is "Everyone" or our actual group */
+    if (pOldEAs[ea_idx].Trustee.TrusteeForm != TRUSTEE_IS_SID ||
+        EqualSid(pEASid, psidEveryone) ||
+        EqualSid(pEASid, psidGroup)) {
+      continue;
+    }
+
+    /* Check to see if our user is a member of this group */
+    if (!CheckTokenMembership(hImpersonatedToken, pEASid, &isMember)) {
+      SET_REQ_WIN32_ERROR(req, GetLastError());
+      goto chmod_cleanup;
+    }
+
+    /*
+     * If we're a member, then count it.  We limit our `ea_write_idx` to avoid
+     * the unlikely event that we have been added to a group since we first
+     * calculated `numOtherGroups`.
+     */
+    if (isMember && ea_write_idx < numNewEAs) {
+      build_access_struct(&ea[ea_write_idx], pEASid, TRUSTEE_IS_GROUP, 0, REVOKE_ACCESS);
+      build_access_struct(&ea[ea_write_idx + 1], pEASid, TRUSTEE_IS_GROUP, g_deny_mode, DENY_ACCESS);
+      build_access_struct(&ea[ea_write_idx + 2], pEASid, TRUSTEE_IS_GROUP, g_mode, SET_ACCESS);
+      ea_write_idx += 3;
+    }
+  }
+
+  /* Set entries in the ACL object */
+  if (ERROR_SUCCESS != SetEntriesInAclW(numNewEAs, &ea[0], pOldDACL, &pNewDACL)) {
+    SET_REQ_WIN32_ERROR(req, GetLastError());
+    goto chmod_cleanup;
+  }
+
+  /* If none of the write bits are set, we want to mark the file as read-only.
+   * Alternatively, if it was marked as read-only, unmark it if we have at least
+   * one writable group set. */
+  attr = GetFileAttributesW(req->file.pathw);
+  if (attr == INVALID_FILE_ATTRIBUTES) {
+    SET_REQ_WIN32_ERROR(req, GetLastError());
+    goto chmod_cleanup;
+  }
+  new_attr = attr;
+  if ((req->fs.info.mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0) {
+    new_attr |= FILE_ATTRIBUTE_READONLY;
+  }
+  if ((req->fs.info.mode & (S_IWUSR | S_IWGRP | S_IWOTH)) != 0) {
+    new_attr &= ~FILE_ATTRIBUTE_READONLY;
+  }
+
+  /*
+   * Now we actually do the setting.  We only call SetFileAttributes() if the
+   * attributes have actually changed.
+   */
+  if (new_attr != attr) {
+    if (!SetFileAttributesW(req->file.pathw, new_attr)) {
+      SET_REQ_WIN32_ERROR(req, GetLastError());
+      goto chmod_cleanup;
+    }
+  }
+  if (ERROR_SUCCESS != SetNamedSecurityInfoW(
+              req->file.pathw,
+              SE_FILE_OBJECT,
+              DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
+              NULL, NULL, pNewDACL, NULL)) {
+    SET_REQ_WIN32_ERROR(req, GetLastError());
+    goto chmod_cleanup;
+  }
+
+  SET_REQ_SUCCESS(req);
+
+chmod_cleanup:
+  if (pSD != NULL) {
+    LocalFree(pSD);
+  }
+  if (pNewDACL != NULL) {
+    LocalFree(pNewDACL);
+  }
+  if (psidEveryone != NULL) {
+    FreeSid(psidEveryone);
+  }
+  if (psidNull != NULL) {
+    FreeSid(psidNull);
+  }
+  if (psidCreatorGroup != NULL) {
+    FreeSid(psidCreatorGroup);
+  }
+  if (pOldEAs != NULL) {
+    LocalFree(pOldEAs);
+  }
+  if (ea != NULL) {
+    free(ea);
+  }
 }
 
 
 static void fs__fchmod(uv_fs_t* req) {
-  int fd = req->file.fd;
+  HANDLE handle = req->file.hFile;
   int clear_archive_flag;
-  HANDLE handle;
   NTSTATUS nt_status;
   IO_STATUS_BLOCK io_status;
   FILE_BASIC_INFORMATION file_info;
 
-  VERIFY_FD(fd, req);
+  VERIFY_HANDLE(handle, req);
 
-  handle = ReOpenFile(uv__get_osfhandle(fd), FILE_WRITE_ATTRIBUTES, 0, 0);
+  handle = ReOpenFile(handle, FILE_WRITE_ATTRIBUTES, 0, 0);
   if (handle == INVALID_HANDLE_VALUE) {
     SET_REQ_WIN32_ERROR(req, GetLastError());
     return;
@@ -2255,13 +2645,28 @@ fchmod_cleanup:
 }
 
 
-INLINE static int fs__utime_handle(HANDLE handle, double atime, double mtime) {
-  FILETIME filetime_a, filetime_m;
+INLINE static int fs__utime_handle(HANDLE handle,
+                                   double btime,
+                                   double atime,
+                                   double mtime) {
+  FILETIME filetime_b;
+  FILETIME filetime_a;
+  FILETIME filetime_m;
+
+  if (isnan(btime)) {
+    filetime_b.dwHighDateTime = 0;
+    filetime_b.dwLowDateTime = 0;
+  } else {
+    TIME_T_TO_FILETIME(btime, &filetime_b);
+  }
 
   TIME_T_TO_FILETIME(atime, &filetime_a);
   TIME_T_TO_FILETIME(mtime, &filetime_m);
 
-  if (!SetFileTime(handle, NULL, &filetime_a, &filetime_m)) {
+  if (!SetFileTime(handle,
+                   &filetime_b,
+                   &filetime_a,
+                   &filetime_m)) {
     return -1;
   }
 
@@ -2269,6 +2674,7 @@ INLINE static int fs__utime_handle(HANDLE handle, double atime, double mtime) {
 }
 
 INLINE static DWORD fs__utime_impl_from_path(WCHAR* path,
+                                             double btime,
                                              double atime,
                                              double mtime,
                                              int do_lutime) {
@@ -2291,7 +2697,7 @@ INLINE static DWORD fs__utime_impl_from_path(WCHAR* path,
 
   if (handle == INVALID_HANDLE_VALUE) {
     ret = GetLastError();
-  } else if (fs__utime_handle(handle, atime, mtime) != 0) {
+  } else if (fs__utime_handle(handle, btime, atime, mtime) != 0) {
     ret = GetLastError();
   } else {
     ret = 0;
@@ -2305,6 +2711,7 @@ INLINE static void fs__utime_impl(uv_fs_t* req, int do_lutime) {
   DWORD error;
 
   error = fs__utime_impl_from_path(req->file.pathw,
+                                   req->fs.time.btime,
                                    req->fs.time.atime,
                                    req->fs.time.mtime,
                                    do_lutime);
@@ -2332,18 +2739,13 @@ static void fs__utime(uv_fs_t* req) {
 
 
 static void fs__futime(uv_fs_t* req) {
-  int fd = req->file.fd;
-  HANDLE handle;
-  VERIFY_FD(fd, req);
-
-  handle = uv__get_osfhandle(fd);
+  HANDLE handle = req->file.hFile;
+  VERIFY_HANDLE(handle, req);
 
-  if (handle == INVALID_HANDLE_VALUE) {
-    SET_REQ_WIN32_ERROR(req, ERROR_INVALID_HANDLE);
-    return;
-  }
-
-  if (fs__utime_handle(handle, req->fs.time.atime, req->fs.time.mtime) != 0) {
+  if (fs__utime_handle(handle,
+                       req->fs.time.btime,
+                       req->fs.time.atime,
+                       req->fs.time.mtime) != 0) {
     SET_REQ_WIN32_ERROR(req, GetLastError());
     return;
   }
@@ -2623,8 +3025,10 @@ static ssize_t fs__realpath_handle(HANDLE handle, char** realpath_ptr) {
   }
   w_realpath_ptr = w_realpath_buf;
 
-  if (GetFinalPathNameByHandleW(
-          handle, w_realpath_ptr, w_realpath_len, VOLUME_NAME_DOS) == 0) {
+  if (GetFinalPathNameByHandleW(handle,
+                                w_realpath_ptr,
+                                w_realpath_len,
+                                VOLUME_NAME_DOS) == 0) {
     uv__free(w_realpath_buf);
     SetLastError(ERROR_INVALID_HANDLE);
     return -1;
@@ -2862,7 +3266,8 @@ void uv_fs_req_cleanup(uv_fs_t* req) {
       uv__free(req->ptr);
   }
 
-  if (req->fs.info.bufs != req->fs.info.bufsml)
+  if (req->fs.info.bufs != req->fs.info.bufsml &&
+      ARRAY_SIZE(req->fs.info.bufs) > 0)
     uv__free(req->fs.info.bufs);
 
   req->path = NULL;
@@ -2888,20 +3293,20 @@ int uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,
 
   req->fs.info.file_flags = flags;
   req->fs.info.mode = mode;
-  POST;
+  POST0;
 }
 
 
-int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file fd, uv_fs_cb cb) {
+int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t handle, uv_fs_cb cb) {
   INIT(UV_FS_CLOSE);
-  req->file.fd = fd;
+  req->file.hFile = handle;
   POST;
 }
 
 
 int uv_fs_read(uv_loop_t* loop,
                uv_fs_t* req,
-               uv_file fd,
+               uv_os_fd_t handle,
                const uv_buf_t bufs[],
                unsigned int nbufs,
                int64_t offset,
@@ -2913,7 +3318,7 @@ int uv_fs_read(uv_loop_t* loop,
     return UV_EINVAL;
   }
 
-  req->file.fd = fd;
+  req->file.hFile = handle;
 
   req->fs.info.nbufs = nbufs;
   req->fs.info.bufs = req->fs.info.bufsml;
@@ -2934,7 +3339,7 @@ int uv_fs_read(uv_loop_t* loop,
 
 int uv_fs_write(uv_loop_t* loop,
                 uv_fs_t* req,
-                uv_file fd,
+                uv_os_fd_t handle,
                 const uv_buf_t bufs[],
                 unsigned int nbufs,
                 int64_t offset,
@@ -2946,7 +3351,7 @@ int uv_fs_write(uv_loop_t* loop,
     return UV_EINVAL;
   }
 
-  req->file.fd = fd;
+  req->file.hFile = handle;
 
   req->fs.info.nbufs = nbufs;
   req->fs.info.bufs = req->fs.info.bufsml;
@@ -3026,7 +3431,7 @@ int uv_fs_mkstemp(uv_loop_t* loop,
     return req->result;
   }
 
-  POST;
+  POST0;
 }
 
 
@@ -3186,7 +3591,7 @@ int uv_fs_chown(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_uid_t uid,
 }
 
 
-int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_file fd, uv_uid_t uid,
+int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t hFile, uv_uid_t uid,
     uv_gid_t gid, uv_fs_cb cb) {
   INIT(UV_FS_FCHOWN);
   POST;
@@ -3236,9 +3641,9 @@ int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {
 }
 
 
-int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file fd, uv_fs_cb cb) {
+int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t handle, uv_fs_cb cb) {
   INIT(UV_FS_FSTAT);
-  req->file.fd = fd;
+  req->file.hFile = handle;
   POST;
 }
 
@@ -3258,24 +3663,24 @@ int uv_fs_rename(uv_loop_t* loop, uv_fs_t* req, const char* path,
 }
 
 
-int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file fd, uv_fs_cb cb) {
+int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t handle, uv_fs_cb cb) {
   INIT(UV_FS_FSYNC);
-  req->file.fd = fd;
+  req->file.hFile = handle;
   POST;
 }
 
 
-int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file fd, uv_fs_cb cb) {
+int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t handle, uv_fs_cb cb) {
   INIT(UV_FS_FDATASYNC);
-  req->file.fd = fd;
+  req->file.hFile = handle;
   POST;
 }
 
 
-int uv_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req, uv_file fd,
+int uv_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t handle,
     int64_t offset, uv_fs_cb cb) {
   INIT(UV_FS_FTRUNCATE);
-  req->file.fd = fd;
+  req->file.hFile = handle;
   req->fs.info.offset = offset;
   POST;
 }
@@ -3309,11 +3714,11 @@ int uv_fs_copyfile(uv_loop_t* loop,
 }
 
 
-int uv_fs_sendfile(uv_loop_t* loop, uv_fs_t* req, uv_file fd_out,
-    uv_file fd_in, int64_t in_offset, size_t length, uv_fs_cb cb) {
+int uv_fs_sendfile(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t fd_out,
+    uv_os_fd_t fd_in, int64_t in_offset, size_t length, uv_fs_cb cb) {
   INIT(UV_FS_SENDFILE);
-  req->file.fd = fd_in;
-  req->fs.info.fd_out = fd_out;
+  req->file.hFile = fd_in;
+  req->fs.info.hFile_out = fd_out;
   req->fs.info.offset = in_offset;
   req->fs.info.bufsml[0].len = length;
   POST;
@@ -3355,17 +3760,22 @@ int uv_fs_chmod(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode,
 }
 
 
-int uv_fs_fchmod(uv_loop_t* loop, uv_fs_t* req, uv_file fd, int mode,
-    uv_fs_cb cb) {
+int uv_fs_fchmod(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t handle, int mode,
+                 uv_fs_cb cb) {
   INIT(UV_FS_FCHMOD);
-  req->file.fd = fd;
+  req->file.hFile = handle;
   req->fs.info.mode = mode;
   POST;
 }
 
 
 int uv_fs_utime(uv_loop_t* loop, uv_fs_t* req, const char* path, double atime,
-    double mtime, uv_fs_cb cb) {
+                double mtime, uv_fs_cb cb) {
+  return uv_fs_utime_ex(loop, req, path, NAN, atime, mtime, cb);
+}
+
+int uv_fs_utime_ex(uv_loop_t* loop, uv_fs_t* req, const char* path,
+                   double btime, double atime, double mtime, uv_fs_cb cb) {
   int err;
 
   INIT(UV_FS_UTIME);
@@ -3375,16 +3785,24 @@ int uv_fs_utime(uv_loop_t* loop, uv_fs_t* req, const char* path, double atime,
     return req->result;
   }
 
+  req->fs.time.btime = btime;
   req->fs.time.atime = atime;
   req->fs.time.mtime = mtime;
   POST;
 }
 
 
-int uv_fs_futime(uv_loop_t* loop, uv_fs_t* req, uv_file fd, double atime,
-    double mtime, uv_fs_cb cb) {
+int uv_fs_futime(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t handle, double atime,
+                 double mtime, uv_fs_cb cb) {
+  return uv_fs_futime_ex(loop, req, handle, NAN, atime, mtime, cb);
+}
+
+
+int uv_fs_futime_ex(uv_loop_t* loop, uv_fs_t* req, uv_os_fd_t handle,
+                    double btime, double atime, double mtime, uv_fs_cb cb) {
   INIT(UV_FS_FUTIME);
-  req->file.fd = fd;
+  req->file.hFile = handle;
+  req->fs.time.btime = btime;
   req->fs.time.atime = atime;
   req->fs.time.mtime = mtime;
   POST;
diff --git a/src/win/getaddrinfo.c b/src/win/getaddrinfo.c
index dfab860a..d7df685c 100644
--- a/src/win/getaddrinfo.c
+++ b/src/win/getaddrinfo.c
@@ -20,6 +20,7 @@
  */
 
 #include <assert.h>
+#include <stdio.h> /* printf */
 
 #include "uv.h"
 #include "internal.h"
@@ -48,30 +49,6 @@ int uv__getaddrinfo_translate_error(int sys_err) {
 }
 
 
-/*
- * MinGW is missing this
- */
-#if !defined(_MSC_VER) && !defined(__MINGW64_VERSION_MAJOR)
-  typedef struct addrinfoW {
-    int ai_flags;
-    int ai_family;
-    int ai_socktype;
-    int ai_protocol;
-    size_t ai_addrlen;
-    WCHAR* ai_canonname;
-    struct sockaddr* ai_addr;
-    struct addrinfoW* ai_next;
-  } ADDRINFOW, *PADDRINFOW;
-
-  DECLSPEC_IMPORT int WSAAPI GetAddrInfoW(const WCHAR* node,
-                                          const WCHAR* service,
-                                          const ADDRINFOW* hints,
-                                          PADDRINFOW* result);
-
-  DECLSPEC_IMPORT void WSAAPI FreeAddrInfoW(PADDRINFOW pAddrInfo);
-#endif
-
-
 /* Adjust size value to be multiple of 4. Use to keep pointer aligned.
  * Do we need different versions of this for different architectures? */
 #define ALIGNED_SIZE(X)     ((((X) + 3) >> 2) << 2)
@@ -272,10 +249,9 @@ int uv_getaddrinfo(uv_loop_t* loop,
     return UV_EINVAL;
   }
 
-  UV_REQ_INIT(req, UV_GETADDRINFO);
+  UV_REQ_INIT(loop, req, UV_GETADDRINFO);
   req->getaddrinfo_cb = getaddrinfo_cb;
   req->addrinfo = NULL;
-  req->loop = loop;
   req->retcode = 0;
 
   /* calculate required memory size for all input values */
diff --git a/src/win/getnameinfo.c b/src/win/getnameinfo.c
index b3773380..c102d64f 100644
--- a/src/win/getnameinfo.c
+++ b/src/win/getnameinfo.c
@@ -20,7 +20,6 @@
 */
 
 #include <assert.h>
-#include <stdio.h>
 
 #include "uv.h"
 #include "internal.h"
@@ -134,12 +133,11 @@ int uv_getnameinfo(uv_loop_t* loop,
     return UV_EINVAL;
   }
 
-  UV_REQ_INIT(req, UV_GETNAMEINFO);
+  UV_REQ_INIT(loop, req, UV_GETNAMEINFO);
   uv__req_register(loop, req);
 
   req->getnameinfo_cb = getnameinfo_cb;
   req->flags = flags;
-  req->loop = loop;
   req->retcode = 0;
 
   if (getnameinfo_cb) {
diff --git a/src/win/handle-inl.h b/src/win/handle-inl.h
index 82c657d5..96470e7f 100644
--- a/src/win/handle-inl.h
+++ b/src/win/handle-inl.h
@@ -23,7 +23,6 @@
 #define UV_WIN_HANDLE_INL_H_
 
 #include <assert.h>
-#include <io.h>
 
 #include "uv.h"
 #include "internal.h"
@@ -126,14 +125,12 @@ INLINE static void uv_process_endgames(uv_loop_t* loop) {
         break;
 
       case UV_TIMER:
-        uv__timer_close((uv_timer_t*) handle);
-        uv__handle_close(handle);
-        break;
-
       case UV_PREPARE:
       case UV_CHECK:
       case UV_IDLE:
-        uv_loop_watcher_endgame(loop, handle);
+        assert(handle->flags & UV_HANDLE_CLOSING);
+        assert(!(handle->flags & UV_HANDLE_CLOSED));
+        uv__handle_close(handle);
         break;
 
       case UV_ASYNC:
@@ -163,18 +160,4 @@ INLINE static void uv_process_endgames(uv_loop_t* loop) {
   }
 }
 
-INLINE static HANDLE uv__get_osfhandle(int fd)
-{
-  /* _get_osfhandle() raises an assert in debug builds if the FD is invalid.
-   * But it also correctly checks the FD and returns INVALID_HANDLE_VALUE for
-   * invalid FDs in release builds (or if you let the assert continue). So this
-   * wrapper function disables asserts when calling _get_osfhandle. */
-
-  HANDLE handle;
-  UV_BEGIN_DISABLE_CRT_ASSERT();
-  handle = (HANDLE) _get_osfhandle(fd);
-  UV_END_DISABLE_CRT_ASSERT();
-  return handle;
-}
-
 #endif /* UV_WIN_HANDLE_INL_H_ */
diff --git a/src/win/handle.c b/src/win/handle.c
index 61e4df61..8e408d33 100644
--- a/src/win/handle.c
+++ b/src/win/handle.c
@@ -20,7 +20,6 @@
  */
 
 #include <assert.h>
-#include <io.h>
 #include <stdlib.h>
 
 #include "uv.h"
@@ -28,16 +27,13 @@
 #include "handle-inl.h"
 
 
-uv_handle_type uv_guess_handle(uv_file file) {
-  HANDLE handle;
+uv_handle_type uv_guess_handle(uv_os_fd_t handle) {
   DWORD mode;
 
-  if (file < 0) {
+  if (handle == INVALID_HANDLE_VALUE) {
     return UV_UNKNOWN_HANDLE;
   }
 
-  handle = uv__get_osfhandle(file);
-
   switch (GetFileType(handle)) {
     case FILE_TYPE_CHAR:
       if (GetConsoleMode(handle, &mode)) {
@@ -97,25 +93,25 @@ void uv_close(uv_handle_t* handle, uv_close_cb cb) {
       return;
 
     case UV_TIMER:
-      uv_timer_stop((uv_timer_t*)handle);
+      uv__timer_close((uv_timer_t*)handle);
       uv__handle_closing(handle);
       uv_want_endgame(loop, handle);
       return;
 
     case UV_PREPARE:
-      uv_prepare_stop((uv_prepare_t*)handle);
+      uv__prepare_close((uv_prepare_t*) handle);
       uv__handle_closing(handle);
       uv_want_endgame(loop, handle);
       return;
 
     case UV_CHECK:
-      uv_check_stop((uv_check_t*)handle);
+      uv__check_close((uv_check_t*) handle);
       uv__handle_closing(handle);
       uv_want_endgame(loop, handle);
       return;
 
     case UV_IDLE:
-      uv_idle_stop((uv_idle_t*)handle);
+      uv__idle_close((uv_idle_t*) handle);
       uv__handle_closing(handle);
       uv_want_endgame(loop, handle);
       return;
@@ -151,12 +147,3 @@ void uv_close(uv_handle_t* handle, uv_close_cb cb) {
 int uv_is_closing(const uv_handle_t* handle) {
   return !!(handle->flags & (UV_HANDLE_CLOSING | UV_HANDLE_CLOSED));
 }
-
-
-uv_os_fd_t uv_get_osfhandle(int fd) {
-  return uv__get_osfhandle(fd);
-}
-
-int uv_open_osfhandle(uv_os_fd_t os_fd) {
-  return _open_osfhandle((intptr_t) os_fd, 0);
-}
diff --git a/src/win/internal.h b/src/win/internal.h
index b096255e..d4cb9d8b 100644
--- a/src/win/internal.h
+++ b/src/win/internal.h
@@ -38,24 +38,8 @@
 #endif
 
 
-#ifdef _DEBUG
+int uv__dup(uv_os_fd_t fd, uv_os_fd_t* dupfd);
 
-extern UV_THREAD_LOCAL int uv__crt_assert_enabled;
-
-#define UV_BEGIN_DISABLE_CRT_ASSERT()                           \
-  {                                                             \
-    int uv__saved_crt_assert_enabled = uv__crt_assert_enabled;  \
-    uv__crt_assert_enabled = FALSE;
-
-
-#define UV_END_DISABLE_CRT_ASSERT()                             \
-    uv__crt_assert_enabled = uv__saved_crt_assert_enabled;      \
-  }
-
-#else
-#define UV_BEGIN_DISABLE_CRT_ASSERT()
-#define UV_END_DISABLE_CRT_ASSERT()
-#endif
 
 /*
  * TCP
@@ -115,8 +99,8 @@ void uv_udp_endgame(uv_loop_t* loop, uv_udp_t* handle);
 /*
  * Pipes
  */
-int uv_stdio_pipe_server(uv_loop_t* loop, uv_pipe_t* handle, DWORD access,
-    char* name, size_t nameSize);
+int uv__create_stdio_pipe_pair(uv_loop_t* loop,
+    uv_pipe_t* parent_pipe, HANDLE* child_pipe_ptr, unsigned int flags);
 
 int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb);
 int uv_pipe_accept(uv_pipe_t* server, uv_stream_t* client);
@@ -194,11 +178,10 @@ void uv_poll_endgame(uv_loop_t* loop, uv_poll_t* handle);
 /*
  * Loop watchers
  */
-void uv_loop_watcher_endgame(uv_loop_t* loop, uv_handle_t* handle);
-
-void uv_prepare_invoke(uv_loop_t* loop);
-void uv_check_invoke(uv_loop_t* loop);
-void uv_idle_invoke(uv_loop_t* loop);
+void uv__loop_watcher_endgame(uv_loop_t* loop, uv_handle_t* handle);
+void uv__run_prepare(uv_loop_t* loop);
+void uv__run_check(uv_loop_t* loop);
+void uv__run_idle(uv_loop_t* loop);
 
 void uv__once_init(void);
 
@@ -209,8 +192,7 @@ void uv__once_init(void);
 void uv_async_close(uv_loop_t* loop, uv_async_t* handle);
 void uv_async_endgame(uv_loop_t* loop, uv_async_t* handle);
 
-void uv_process_async_wakeup_req(uv_loop_t* loop, uv_async_t* handle,
-    uv_req_t* req);
+void uv_process_async_wakeup_req(uv_loop_t* loop, uv_req_t* req);
 
 
 /*
diff --git a/src/win/loop-watcher.c b/src/win/loop-watcher.c
deleted file mode 100644
index ad7fbea1..00000000
--- a/src/win/loop-watcher.c
+++ /dev/null
@@ -1,122 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#include <assert.h>
-
-#include "uv.h"
-#include "internal.h"
-#include "handle-inl.h"
-
-
-void uv_loop_watcher_endgame(uv_loop_t* loop, uv_handle_t* handle) {
-  if (handle->flags & UV_HANDLE_CLOSING) {
-    assert(!(handle->flags & UV_HANDLE_CLOSED));
-    handle->flags |= UV_HANDLE_CLOSED;
-    uv__handle_close(handle);
-  }
-}
-
-
-#define UV_LOOP_WATCHER_DEFINE(name, NAME)                                    \
-  int uv_##name##_init(uv_loop_t* loop, uv_##name##_t* handle) {              \
-    uv__handle_init(loop, (uv_handle_t*) handle, UV_##NAME);                  \
-                                                                              \
-    return 0;                                                                 \
-  }                                                                           \
-                                                                              \
-                                                                              \
-  int uv_##name##_start(uv_##name##_t* handle, uv_##name##_cb cb) {           \
-    uv_loop_t* loop = handle->loop;                                           \
-    uv_##name##_t* old_head;                                                  \
-                                                                              \
-    assert(handle->type == UV_##NAME);                                        \
-                                                                              \
-    if (uv__is_active(handle))                                                \
-      return 0;                                                               \
-                                                                              \
-    if (cb == NULL)                                                           \
-      return UV_EINVAL;                                                       \
-                                                                              \
-    old_head = loop->name##_handles;                                          \
-                                                                              \
-    handle->name##_next = old_head;                                           \
-    handle->name##_prev = NULL;                                               \
-                                                                              \
-    if (old_head) {                                                           \
-      old_head->name##_prev = handle;                                         \
-    }                                                                         \
-                                                                              \
-    loop->name##_handles = handle;                                            \
-                                                                              \
-    handle->name##_cb = cb;                                                   \
-    uv__handle_start(handle);                                                 \
-                                                                              \
-    return 0;                                                                 \
-  }                                                                           \
-                                                                              \
-                                                                              \
-  int uv_##name##_stop(uv_##name##_t* handle) {                               \
-    uv_loop_t* loop = handle->loop;                                           \
-                                                                              \
-    assert(handle->type == UV_##NAME);                                        \
-                                                                              \
-    if (!uv__is_active(handle))                                               \
-      return 0;                                                               \
-                                                                              \
-    /* Update loop head if needed */                                          \
-    if (loop->name##_handles == handle) {                                     \
-      loop->name##_handles = handle->name##_next;                             \
-    }                                                                         \
-                                                                              \
-    /* Update the iterator-next pointer of needed */                          \
-    if (loop->next_##name##_handle == handle) {                               \
-      loop->next_##name##_handle = handle->name##_next;                       \
-    }                                                                         \
-                                                                              \
-    if (handle->name##_prev) {                                                \
-      handle->name##_prev->name##_next = handle->name##_next;                 \
-    }                                                                         \
-    if (handle->name##_next) {                                                \
-      handle->name##_next->name##_prev = handle->name##_prev;                 \
-    }                                                                         \
-                                                                              \
-    uv__handle_stop(handle);                                                  \
-                                                                              \
-    return 0;                                                                 \
-  }                                                                           \
-                                                                              \
-                                                                              \
-  void uv_##name##_invoke(uv_loop_t* loop) {                                  \
-    uv_##name##_t* handle;                                                    \
-                                                                              \
-    (loop)->next_##name##_handle = (loop)->name##_handles;                    \
-                                                                              \
-    while ((loop)->next_##name##_handle != NULL) {                            \
-      handle = (loop)->next_##name##_handle;                                  \
-      (loop)->next_##name##_handle = handle->name##_next;                     \
-                                                                              \
-      handle->name##_cb(handle);                                              \
-    }                                                                         \
-  }
-
-UV_LOOP_WATCHER_DEFINE(prepare, PREPARE)
-UV_LOOP_WATCHER_DEFINE(check, CHECK)
-UV_LOOP_WATCHER_DEFINE(idle, IDLE)
diff --git a/src/win/pipe.c b/src/win/pipe.c
index f81245ec..df8bcba1 100644
--- a/src/win/pipe.c
+++ b/src/win/pipe.c
@@ -20,9 +20,8 @@
  */
 
 #include <assert.h>
-#include <io.h>
-#include <stdio.h>
 #include <stdlib.h>
+#include <stdio.h> /* printf */
 #include <string.h>
 
 #include "handle-inl.h"
@@ -191,28 +190,22 @@ static HANDLE open_named_pipe(const WCHAR* name, DWORD* duplex_flags) {
 
 
 static void close_pipe(uv_pipe_t* pipe) {
-  assert(pipe->u.fd == -1 || pipe->u.fd > 2);
-  if (pipe->u.fd == -1)
-    CloseHandle(pipe->handle);
-  else
-    close(pipe->u.fd);
-
-  pipe->u.fd = -1;
+  CloseHandle(pipe->handle);
   pipe->handle = INVALID_HANDLE_VALUE;
 }
 
 
-int uv_stdio_pipe_server(uv_loop_t* loop, uv_pipe_t* handle, DWORD access,
-    char* name, size_t nameSize) {
+static int uv__pipe_server(
+    HANDLE* pipeHandle_ptr, DWORD access,
+    char* name, size_t nameSize, char* random) {
   HANDLE pipeHandle;
   int err;
-  char* ptr = (char*)handle;
 
   for (;;) {
-    uv_unique_pipe_name(ptr, name, nameSize);
+    uv_unique_pipe_name(random, name, nameSize);
 
     pipeHandle = CreateNamedPipeA(name,
-      access | FILE_FLAG_OVERLAPPED | FILE_FLAG_FIRST_PIPE_INSTANCE | WRITE_DAC,
+      access | FILE_FLAG_FIRST_PIPE_INSTANCE,
       PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT, 1, 65536, 65536, 0,
       NULL);
 
@@ -226,26 +219,195 @@ int uv_stdio_pipe_server(uv_loop_t* loop, uv_pipe_t* handle, DWORD access,
       goto error;
     }
 
-    /* Pipe name collision.  Increment the pointer and try again. */
-    ptr++;
+    /* Pipe name collision.  Increment the random number and try again. */
+    random++;
+  }
+
+  *pipeHandle_ptr = pipeHandle;
+
+  return 0;
+
+ error:
+  if (pipeHandle != INVALID_HANDLE_VALUE)
+    CloseHandle(pipeHandle);
+
+  return err;
+}
+
+
+static int uv__create_pipe_pair(
+    HANDLE* server_pipe_ptr, HANDLE* client_pipe_ptr,
+    unsigned int server_flags, unsigned int client_flags,
+    int inherit_client, char* random) {
+  /* allowed flags are: UV_READABLE_PIPE | UV_WRITABLE_PIPE | UV_NONBLOCK_PIPE */
+  char pipe_name[64];
+  SECURITY_ATTRIBUTES sa;
+  DWORD server_access;
+  DWORD client_access;
+  HANDLE server_pipe;
+  HANDLE client_pipe;
+  int err;
+
+  server_pipe = INVALID_HANDLE_VALUE;
+  client_pipe = INVALID_HANDLE_VALUE;
+
+  server_access = 0;
+  if (server_flags & UV_READABLE_PIPE)
+    server_access |= PIPE_ACCESS_INBOUND;
+  if (server_flags & UV_WRITABLE_PIPE)
+    server_access |= PIPE_ACCESS_OUTBOUND;
+  if (server_flags & UV_NONBLOCK_PIPE)
+    server_access |= FILE_FLAG_OVERLAPPED;
+  server_access |= WRITE_DAC;
+
+  client_access = 0;
+  if (client_flags & UV_READABLE_PIPE)
+    client_access |= GENERIC_READ;
+  else
+    client_access |= FILE_READ_ATTRIBUTES;
+  if (client_flags & UV_WRITABLE_PIPE)
+    client_access |= GENERIC_WRITE;
+  else
+    client_access |= FILE_WRITE_ATTRIBUTES;
+  client_access |= WRITE_DAC;
+
+  /* Create server pipe handle. */
+  err = uv__pipe_server(&server_pipe,
+                        server_access,
+                        pipe_name,
+                        sizeof(pipe_name),
+                        random);
+  if (err)
+    goto error;
+
+  /* Create client pipe handle. */
+  sa.nLength = sizeof sa;
+  sa.lpSecurityDescriptor = NULL;
+  sa.bInheritHandle = inherit_client;
+
+  client_pipe = CreateFileA(pipe_name,
+                            client_access,
+                            0,
+                            &sa,
+                            OPEN_EXISTING,
+                            (client_flags & UV_NONBLOCK_PIPE) ? FILE_FLAG_OVERLAPPED : 0,
+                            NULL);
+  if (client_pipe == INVALID_HANDLE_VALUE) {
+    err = GetLastError();
+    goto error;
   }
 
-  if (CreateIoCompletionPort(pipeHandle,
+#ifndef NDEBUG
+  /* Validate that the pipe was opened in the right mode. */
+  {
+    DWORD mode;
+    BOOL r;
+    r = GetNamedPipeHandleState(client_pipe, &mode, NULL, NULL, NULL, NULL, 0);
+    if (r == TRUE) {
+      assert(mode == (PIPE_READMODE_BYTE | PIPE_WAIT));
+    } else {
+      fprintf(stderr, "libuv assertion failure: GetNamedPipeHandleState failed\n");
+    }
+  }
+#endif
+
+  /* Do a blocking ConnectNamedPipe.  This should not block because we have
+   * both ends of the pipe created. */
+  if (!ConnectNamedPipe(server_pipe, NULL)) {
+    if (GetLastError() != ERROR_PIPE_CONNECTED) {
+      err = GetLastError();
+      goto error;
+    }
+  }
+
+  *client_pipe_ptr = client_pipe;
+  *server_pipe_ptr = server_pipe;
+  return 0;
+
+ error:
+  if (server_pipe != INVALID_HANDLE_VALUE)
+    CloseHandle(server_pipe);
+
+  if (client_pipe != INVALID_HANDLE_VALUE)
+    CloseHandle(client_pipe);
+
+  return err;
+}
+
+
+int uv_pipe(uv_os_fd_t fds[2], int read_flags, int write_flags) {
+  /* Make the server side the inbound (read) end, */
+  /* so that both ends will have FILE_READ_ATTRIBUTES permission. */
+  /* TODO: better source of local randomness than &fds? */
+  read_flags |= UV_READABLE_PIPE;
+  write_flags |= UV_WRITABLE_PIPE;
+  return uv__create_pipe_pair(&fds[0], &fds[1], read_flags, write_flags, 0, (char*) &fds[0]);
+}
+
+
+int uv__create_stdio_pipe_pair(uv_loop_t* loop,
+    uv_pipe_t* parent_pipe, HANDLE* child_pipe_ptr, unsigned int flags) {
+  /* The parent_pipe is always the server_pipe and kept by libuv.
+   * The child_pipe is always the client_pipe and is passed to the child.
+   * The flags are specified with respect to their usage in the child. */
+  HANDLE server_pipe;
+  HANDLE client_pipe;
+  unsigned int server_flags;
+  unsigned int client_flags;
+  int err;
+
+  server_pipe = INVALID_HANDLE_VALUE;
+  client_pipe = INVALID_HANDLE_VALUE;
+
+  server_flags = 0;
+  client_flags = 0;
+  if (flags & UV_READABLE_PIPE) {
+    /* The server needs inbound (read) access too, otherwise CreateNamedPipe()
+     * won't give us the FILE_READ_ATTRIBUTES permission. We need that to probe
+     * the state of the write buffer when we're trying to shutdown the pipe. */
+    server_flags |= UV_READABLE_PIPE | UV_WRITABLE_PIPE;
+    client_flags |= UV_READABLE_PIPE;
+  }
+  if (flags & UV_WRITABLE_PIPE) {
+    server_flags |= UV_READABLE_PIPE;
+    client_flags |= UV_WRITABLE_PIPE;
+  }
+  server_flags |= UV_NONBLOCK_PIPE;
+  if (flags & UV_NONBLOCK_PIPE || parent_pipe->ipc) {
+    client_flags |= UV_NONBLOCK_PIPE;
+  }
+
+  err = uv__create_pipe_pair(&server_pipe, &client_pipe,
+          server_flags, client_flags, 1, (char*) server_pipe);
+  if (err)
+    goto error;
+
+  if (CreateIoCompletionPort(server_pipe,
                              loop->iocp,
-                             (ULONG_PTR)handle,
+                             (ULONG_PTR) parent_pipe,
                              0) == NULL) {
     err = GetLastError();
     goto error;
   }
 
-  uv_pipe_connection_init(handle);
-  handle->handle = pipeHandle;
+  uv_pipe_connection_init(parent_pipe);
+  parent_pipe->handle = server_pipe;
+  *child_pipe_ptr = client_pipe;
+
+  /* The server end is now readable and/or writable. */
+  if (flags & UV_READABLE_PIPE)
+    parent_pipe->flags |= UV_HANDLE_WRITABLE;
+  if (flags & UV_WRITABLE_PIPE)
+    parent_pipe->flags |= UV_HANDLE_READABLE;
 
   return 0;
 
  error:
-  if (pipeHandle != INVALID_HANDLE_VALUE)
-    CloseHandle(pipeHandle);
+  if (server_pipe != INVALID_HANDLE_VALUE)
+    CloseHandle(server_pipe);
+
+  if (client_pipe != INVALID_HANDLE_VALUE)
+    CloseHandle(client_pipe);
 
   return err;
 }
@@ -254,7 +416,6 @@ int uv_stdio_pipe_server(uv_loop_t* loop, uv_pipe_t* handle, DWORD access,
 static int uv_set_pipe_handle(uv_loop_t* loop,
                               uv_pipe_t* handle,
                               HANDLE pipeHandle,
-                              int fd,
                               DWORD duplex_flags) {
   NTSTATUS nt_status;
   IO_STATUS_BLOCK io_status;
@@ -319,7 +480,6 @@ static int uv_set_pipe_handle(uv_loop_t* loop,
   }
 
   handle->handle = pipeHandle;
-  handle->u.fd = fd;
   handle->flags |= duplex_flags;
 
   return 0;
@@ -545,7 +705,7 @@ int uv_pipe_bind(uv_pipe_t* handle, const char* name) {
 
   for (i = 0; i < handle->pipe.serv.pending_instances; i++) {
     req = &handle->pipe.serv.accept_reqs[i];
-    UV_REQ_INIT(req, UV_ACCEPT);
+    UV_REQ_INIT(loop, req, UV_ACCEPT);
     req->data = handle;
     req->pipeHandle = INVALID_HANDLE_VALUE;
     req->next_pending = NULL;
@@ -627,7 +787,7 @@ static DWORD WINAPI pipe_connect_thread_proc(void* parameter) {
   }
 
   if (pipeHandle != INVALID_HANDLE_VALUE &&
-      !uv_set_pipe_handle(loop, handle, pipeHandle, -1, duplex_flags)) {
+      !uv_set_pipe_handle(loop, handle, pipeHandle, duplex_flags)) {
     SET_REQ_SUCCESS(req);
   } else {
     SET_REQ_ERROR(req, GetLastError());
@@ -647,7 +807,7 @@ void uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle,
   HANDLE pipeHandle = INVALID_HANDLE_VALUE;
   DWORD duplex_flags;
 
-  UV_REQ_INIT(req, UV_CONNECT);
+  UV_REQ_INIT(loop, req, UV_CONNECT);
   req->handle = (uv_stream_t*) handle;
   req->cb = cb;
 
@@ -694,7 +854,6 @@ void uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle,
   if (uv_set_pipe_handle(loop,
                          (uv_pipe_t*) req->handle,
                          pipeHandle,
-                         -1,
                          duplex_flags)) {
     err = GetLastError();
     goto error;
@@ -712,9 +871,8 @@ error:
     handle->name = NULL;
   }
 
-  if (pipeHandle != INVALID_HANDLE_VALUE) {
+  if (pipeHandle != INVALID_HANDLE_VALUE)
     CloseHandle(pipeHandle);
-  }
 
   /* Make this req pending reporting an error. */
   SET_REQ_ERROR(req, err);
@@ -1322,7 +1480,7 @@ static int uv__pipe_write_data(uv_loop_t* loop,
 
   assert(handle->handle != INVALID_HANDLE_VALUE);
 
-  UV_REQ_INIT(req, UV_WRITE);
+  UV_REQ_INIT(loop, req, UV_WRITE);
   req->handle = (uv_stream_t*) handle;
   req->send_handle = NULL;
   req->cb = cb;
@@ -2078,8 +2236,7 @@ static void eof_timer_close_cb(uv_handle_t* handle) {
 }
 
 
-int uv_pipe_open(uv_pipe_t* pipe, uv_file file) {
-  HANDLE os_handle = uv__get_osfhandle(file);
+int uv_pipe_open(uv_pipe_t* pipe, uv_os_fd_t os_handle) {
   NTSTATUS nt_status;
   IO_STATUS_BLOCK io_status;
   FILE_ACCESS_INFORMATION access;
@@ -2088,23 +2245,13 @@ int uv_pipe_open(uv_pipe_t* pipe, uv_file file) {
   if (os_handle == INVALID_HANDLE_VALUE)
     return UV_EBADF;
 
-  uv__once_init();
-  /* In order to avoid closing a stdio file descriptor 0-2, duplicate the
-   * underlying OS handle and forget about the original fd.
-   * We could also opt to use the original OS handle and just never close it,
-   * but then there would be no reliable way to cancel pending read operations
-   * upon close.
+  /* In order to avoid closing a stdio pseudo-handle, or having it get replaced under us,
+   * duplicate the underlying OS handle and forget about the original one.
    */
-  if (file <= 2) {
-    if (!DuplicateHandle(INVALID_HANDLE_VALUE,
-                         os_handle,
-                         INVALID_HANDLE_VALUE,
-                         &os_handle,
-                         0,
-                         FALSE,
-                         DUPLICATE_SAME_ACCESS))
-      return uv_translate_sys_error(GetLastError());
-    file = -1;
+  if (os_handle == UV_STDIN_FD || os_handle == UV_STDOUT_FD || os_handle == UV_STDERR_FD) {
+    int dup_err = uv__dup(os_handle, &os_handle);
+    if (dup_err)
+      return dup_err;
   }
 
   /* Determine what kind of permissions we have on this handle.
@@ -2135,7 +2282,6 @@ int uv_pipe_open(uv_pipe_t* pipe, uv_file file) {
       uv_set_pipe_handle(pipe->loop,
                          pipe,
                          os_handle,
-                         file,
                          duplex_flags) == -1) {
     return UV_EINVAL;
   }
diff --git a/src/win/poll.c b/src/win/poll.c
index 87858590..47aea1b3 100644
--- a/src/win/poll.c
+++ b/src/win/poll.c
@@ -20,7 +20,6 @@
  */
 
 #include <assert.h>
-#include <io.h>
 
 #include "uv.h"
 #include "internal.h"
@@ -405,12 +404,7 @@ static void uv__slow_poll_process_poll_req(uv_loop_t* loop, uv_poll_t* handle,
 }
 
 
-int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd) {
-  return uv_poll_init_socket(loop, handle, (SOCKET) uv__get_osfhandle(fd));
-}
-
-
-int uv_poll_init_socket(uv_loop_t* loop, uv_poll_t* handle,
+int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle,
     uv_os_sock_t socket) {
   WSAPROTOCOL_INFOW protocol_info;
   int len;
@@ -422,10 +416,8 @@ int uv_poll_init_socket(uv_loop_t* loop, uv_poll_t* handle,
   if (ioctlsocket(socket, FIONBIO, &yes) == SOCKET_ERROR)
     return uv_translate_sys_error(WSAGetLastError());
 
-/* Try to obtain a base handle for the socket. This increases this chances that
- * we find an AFD handle and are able to use the fast poll mechanism. This will
- * always fail on windows XP/2k3, since they don't support the. SIO_BASE_HANDLE
- * ioctl. */
+  /* Try to obtain a base handle for the socket. This increases this chances
+   * that we find an AFD handle and are able to use the fast poll mechanism. */
 #ifndef NDEBUG
   base_socket = INVALID_SOCKET;
 #endif
@@ -472,11 +464,11 @@ int uv_poll_init_socket(uv_loop_t* loop, uv_poll_t* handle,
 
   /* Initialize 2 poll reqs. */
   handle->submitted_events_1 = 0;
-  UV_REQ_INIT(&handle->poll_req_1, UV_POLL_REQ);
+  UV_REQ_INIT(loop, &handle->poll_req_1, UV_POLL_REQ);
   handle->poll_req_1.data = handle;
 
   handle->submitted_events_2 = 0;
-  UV_REQ_INIT(&handle->poll_req_2, UV_POLL_REQ);
+  UV_REQ_INIT(loop, &handle->poll_req_2, UV_POLL_REQ);
   handle->poll_req_2.data = handle;
 
   return 0;
diff --git a/src/win/process-stdio.c b/src/win/process-stdio.c
index 355d6188..0f07ff3b 100644
--- a/src/win/process-stdio.c
+++ b/src/win/process-stdio.c
@@ -20,8 +20,6 @@
  */
 
 #include <assert.h>
-#include <io.h>
-#include <stdio.h>
 #include <stdlib.h>
 
 #include "uv.h"
@@ -95,128 +93,34 @@ void uv_disable_stdio_inheritance(void) {
 }
 
 
-static int uv__create_stdio_pipe_pair(uv_loop_t* loop,
-    uv_pipe_t* server_pipe, HANDLE* child_pipe_ptr, unsigned int flags) {
-  char pipe_name[64];
-  SECURITY_ATTRIBUTES sa;
-  DWORD server_access = 0;
-  DWORD client_access = 0;
-  HANDLE child_pipe = INVALID_HANDLE_VALUE;
-  int err;
-  int overlap;
-
-  if (flags & UV_READABLE_PIPE) {
-    /* The server needs inbound access too, otherwise CreateNamedPipe() won't
-     * give us the FILE_READ_ATTRIBUTES permission. We need that to probe the
-     * state of the write buffer when we're trying to shutdown the pipe. */
-    server_access |= PIPE_ACCESS_OUTBOUND | PIPE_ACCESS_INBOUND;
-    client_access |= GENERIC_READ | FILE_WRITE_ATTRIBUTES;
-  }
-  if (flags & UV_WRITABLE_PIPE) {
-    server_access |= PIPE_ACCESS_INBOUND;
-    client_access |= GENERIC_WRITE | FILE_READ_ATTRIBUTES;
-  }
-
-  /* Create server pipe handle. */
-  err = uv_stdio_pipe_server(loop,
-                             server_pipe,
-                             server_access,
-                             pipe_name,
-                             sizeof(pipe_name));
-  if (err)
-    goto error;
-
-  /* Create child pipe handle. */
-  sa.nLength = sizeof sa;
-  sa.lpSecurityDescriptor = NULL;
-  sa.bInheritHandle = TRUE;
-
-  overlap = server_pipe->ipc || (flags & UV_OVERLAPPED_PIPE);
-  child_pipe = CreateFileA(pipe_name,
-                           client_access,
-                           0,
-                           &sa,
-                           OPEN_EXISTING,
-                           overlap ? FILE_FLAG_OVERLAPPED : 0,
-                           NULL);
-  if (child_pipe == INVALID_HANDLE_VALUE) {
-    err = GetLastError();
-    goto error;
-  }
-
-#ifndef NDEBUG
-  /* Validate that the pipe was opened in the right mode. */
-  {
-    DWORD mode;
-    BOOL r = GetNamedPipeHandleState(child_pipe,
-                                     &mode,
-                                     NULL,
-                                     NULL,
-                                     NULL,
-                                     NULL,
-                                     0);
-    assert(r == TRUE);
-    assert(mode == (PIPE_READMODE_BYTE | PIPE_WAIT));
-  }
-#endif
-
-  /* Do a blocking ConnectNamedPipe. This should not block because we have both
-   * ends of the pipe created. */
-  if (!ConnectNamedPipe(server_pipe->handle, NULL)) {
-    if (GetLastError() != ERROR_PIPE_CONNECTED) {
-      err = GetLastError();
-      goto error;
-    }
-  }
-
-  /* The server end is now readable and/or writable. */
-  if (flags & UV_READABLE_PIPE)
-    server_pipe->flags |= UV_HANDLE_WRITABLE;
-  if (flags & UV_WRITABLE_PIPE)
-    server_pipe->flags |= UV_HANDLE_READABLE;
-
-  *child_pipe_ptr = child_pipe;
-  return 0;
-
- error:
-  if (server_pipe->handle != INVALID_HANDLE_VALUE) {
-    uv_pipe_cleanup(loop, server_pipe);
-  }
-
-  if (child_pipe != INVALID_HANDLE_VALUE) {
-    CloseHandle(child_pipe);
-  }
-
-  return err;
-}
-
-
-static int uv__duplicate_handle(uv_loop_t* loop, HANDLE handle, HANDLE* dup) {
+int uv__dup(HANDLE fd, HANDLE* dupfd) {
   HANDLE current_process;
 
+  if (fd == UV_STDIN_FD || fd == UV_STDOUT_FD || fd == UV_STDERR_FD)
+    fd = GetStdHandle((DWORD)(uintptr_t) fd);
 
   /* _get_osfhandle will sometimes return -2 in case of an error. This seems to
    * happen when fd <= 2 and the process' corresponding stdio handle is set to
    * NULL. Unfortunately DuplicateHandle will happily duplicate (HANDLE) -2, so
    * this situation goes unnoticed until someone tries to use the duplicate.
    * Therefore we filter out known-invalid handles here. */
-  if (handle == INVALID_HANDLE_VALUE ||
-      handle == NULL ||
-      handle == (HANDLE) -2) {
-    *dup = INVALID_HANDLE_VALUE;
+  if (fd == INVALID_HANDLE_VALUE ||
+      fd == NULL ||
+      fd == (HANDLE) -2) {
+    *dupfd = INVALID_HANDLE_VALUE;
     return ERROR_INVALID_HANDLE;
   }
 
   current_process = GetCurrentProcess();
 
   if (!DuplicateHandle(current_process,
-                       handle,
+                       fd,
                        current_process,
-                       dup,
+                       dupfd,
                        0,
                        TRUE,
                        DUPLICATE_SAME_ACCESS)) {
-    *dup = INVALID_HANDLE_VALUE;
+    *dupfd = INVALID_HANDLE_VALUE;
     return GetLastError();
   }
 
@@ -224,19 +128,6 @@ static int uv__duplicate_handle(uv_loop_t* loop, HANDLE handle, HANDLE* dup) {
 }
 
 
-static int uv__duplicate_fd(uv_loop_t* loop, int fd, HANDLE* dup) {
-  HANDLE handle;
-
-  if (fd == -1) {
-    *dup = INVALID_HANDLE_VALUE;
-    return ERROR_INVALID_HANDLE;
-  }
-
-  handle = uv__get_osfhandle(fd);
-  return uv__duplicate_handle(loop, handle, dup);
-}
-
-
 int uv__create_nul_handle(HANDLE* handle_ptr,
     DWORD access) {
   HANDLE handle;
@@ -353,11 +244,14 @@ int uv__stdio_create(uv_loop_t* loop,
         HANDLE child_handle;
 
         /* Make an inheritable duplicate of the handle. */
-        err = uv__duplicate_fd(loop, fdopt.data.fd, &child_handle);
+        err = uv__dup(fdopt.data.file, &child_handle);
         if (err) {
-          /* If fdopt. data. fd is not valid and fd <= 2, then ignore the
-           * error. */
-          if (fdopt.data.fd <= 2 && err == ERROR_INVALID_HANDLE) {
+          /* If fdopt.data.file is pointing at one of the pseudo stdio handles,
+           * but it is not valid ignore the error. */
+          if ((fdopt.data.file == UV_STDIN_FD ||
+               fdopt.data.file == UV_STDOUT_FD ||
+               fdopt.data.file == UV_STDERR_FD) &&
+              err == ERROR_INVALID_HANDLE) {
             CHILD_STDIO_CRT_FLAGS(buffer, i) = 0;
             CHILD_STDIO_HANDLE(buffer, i) = INVALID_HANDLE_VALUE;
             break;
@@ -426,7 +320,7 @@ int uv__stdio_create(uv_loop_t* loop,
         }
 
         /* Make an inheritable copy of the handle. */
-        err = uv__duplicate_handle(loop, stream_handle, &child_handle);
+        err = uv__dup(stream_handle, &child_handle);
         if (err)
           goto error;
 
diff --git a/src/win/process.c b/src/win/process.c
index 73543c6e..a4ebf204 100644
--- a/src/win/process.c
+++ b/src/win/process.c
@@ -20,8 +20,6 @@
  */
 
 #include <assert.h>
-#include <io.h>
-#include <stdio.h>
 #include <stdlib.h>
 #include <signal.h>
 #include <limits.h>
@@ -34,9 +32,6 @@
 #include "req-inl.h"
 
 
-#define SIGKILL         9
-
-
 typedef struct env_var {
   const WCHAR* const wide;
   const WCHAR* const wide_eq;
@@ -147,7 +142,7 @@ static void uv_process_init(uv_loop_t* loop, uv_process_t* handle) {
   handle->child_stdio_buffer = NULL;
   handle->exit_cb_pending = 0;
 
-  UV_REQ_INIT(&handle->exit_req, UV_PROCESS_EXIT);
+  UV_REQ_INIT(loop, &handle->exit_req, UV_PROCESS_EXIT);
   handle->exit_req.data = handle;
 }
 
@@ -882,10 +877,6 @@ void uv_process_proc_exit(uv_loop_t* loop, uv_process_t* handle) {
     handle->wait_handle = INVALID_HANDLE_VALUE;
   }
 
-  /* Set the handle to inactive: no callbacks will be made after the exit
-   * callback. */
-  uv__handle_stop(handle);
-
   if (GetExitCodeProcess(handle->process_handle, &status)) {
     exit_code = status;
   } else {
@@ -893,6 +884,15 @@ void uv_process_proc_exit(uv_loop_t* loop, uv_process_t* handle) {
     exit_code = uv_translate_sys_error(GetLastError());
   }
 
+  /* Clean-up the process handle. */
+  CloseHandle(handle->process_handle);
+  handle->process_handle = INVALID_HANDLE_VALUE;
+  handle->pid = 0;
+
+  /* Set the handle to inactive: no callbacks will be made after the exit
+   * callback. */
+  uv__handle_stop(handle);
+
   /* Fire the exit callback. */
   if (handle->exit_cb) {
     handle->exit_cb(handle, exit_code, handle->exit_signal);
@@ -927,7 +927,8 @@ void uv_process_endgame(uv_loop_t* loop, uv_process_t* handle) {
   assert(!(handle->flags & UV_HANDLE_CLOSED));
 
   /* Clean-up the process handle. */
-  CloseHandle(handle->process_handle);
+  if (handle->process_handle != INVALID_HANDLE_VALUE)
+    CloseHandle(handle->process_handle);
 
   uv__handle_close(handle);
 }
@@ -958,6 +959,12 @@ int uv_spawn(uv_loop_t* loop,
     return UV_EINVAL;
   }
 
+  if (options->cpumask != NULL) {
+    if (options->cpumask_size < (size_t)uv_cpumask_size()) {
+      return UV_EINVAL;
+    }
+  }
+
   assert(options->file != NULL);
   assert(!(options->flags & ~(UV_PROCESS_DETACHED |
                               UV_PROCESS_SETGID |
@@ -1095,7 +1102,13 @@ int uv_spawn(uv_loop_t* loop,
      * CreateProcess call fail if we're under job control that doesn't allow
      * breakaway.
      */
-    process_flags |= DETACHED_PROCESS | CREATE_NEW_PROCESS_GROUP;
+    process_flags |= CREATE_NEW_PROCESS_GROUP;
+  }
+
+  if (options->cpumask != NULL) {
+    /* Create the child in a suspended state so we have a chance to set
+       its process affinity before it runs.  */
+    process_flags |= CREATE_SUSPENDED;
   }
 
   if (!CreateProcessW(application_path,
@@ -1113,6 +1126,50 @@ int uv_spawn(uv_loop_t* loop,
     goto done;
   }
 
+  if (options->cpumask != NULL) {
+    /* The child is currently suspended.  Set its process affinity
+       or terminate it if we can't.  */
+    int i;
+    int cpumasksize;
+    DWORD_PTR sysmask;
+    DWORD_PTR oldmask;
+    DWORD_PTR newmask;
+
+    cpumasksize = uv_cpumask_size();
+
+    if (!GetProcessAffinityMask(info.hProcess, &oldmask, &sysmask)) {
+      err = GetLastError();
+      TerminateProcess(info.hProcess, 1);
+      goto done;
+    }
+
+    newmask = 0;
+    for (i = 0; i < cpumasksize; i++) {
+      if (options->cpumask[i]) {
+        if (oldmask & (((DWORD_PTR)1) << i)) {
+          newmask |= ((DWORD_PTR)1) << i;
+        } else {
+          err = UV_EINVAL;
+          TerminateProcess(info.hProcess, 1);
+          goto done;
+        }
+      }
+    }
+
+    if (!SetProcessAffinityMask(info.hProcess, newmask)) {
+      err = GetLastError();
+      TerminateProcess(info.hProcess, 1);
+      goto done;
+    }
+
+    /* The process affinity of the child is set.  Let it run.  */
+    if (ResumeThread(info.hThread) == ((DWORD)-1)) {
+      err = GetLastError();
+      TerminateProcess(info.hProcess, 1);
+      goto done;
+    }
+  }
+
   /* Spawn succeeded. Beyond this point, failure is reported asynchronously. */
 
   process->process_handle = info.hProcess;
diff --git a/src/win/req-inl.h b/src/win/req-inl.h
index f2513b7d..7c941db3 100644
--- a/src/win/req-inl.h
+++ b/src/win/req-inl.h
@@ -82,11 +82,6 @@
   }
 
 
-INLINE static uv_req_t* uv_overlapped_to_req(OVERLAPPED* overlapped) {
-  return CONTAINING_RECORD(overlapped, uv_req_t, u.io.overlapped);
-}
-
-
 INLINE static void uv_insert_pending_req(uv_loop_t* loop, uv_req_t* req) {
   req->next_req = NULL;
   if (loop->pending_reqs_tail) {
@@ -191,7 +186,7 @@ INLINE static int uv_process_reqs(uv_loop_t* loop) {
         break;
 
       case UV_WAKEUP:
-        uv_process_async_wakeup_req(loop, (uv_async_t*) req->data, req);
+        uv_process_async_wakeup_req(loop, req);
         break;
 
       case UV_SIGNAL_REQ:
diff --git a/src/win/signal.c b/src/win/signal.c
index 3d9f92cf..92223d7c 100644
--- a/src/win/signal.c
+++ b/src/win/signal.c
@@ -150,7 +150,7 @@ int uv_signal_init(uv_loop_t* loop, uv_signal_t* handle) {
   handle->signum = 0;
   handle->signal_cb = NULL;
 
-  UV_REQ_INIT(&handle->signal_req, UV_SIGNAL_REQ);
+  UV_REQ_INIT(loop, &handle->signal_req, UV_SIGNAL_REQ);
   handle->signal_req.data = handle;
 
   return 0;
diff --git a/src/win/snprintf.c b/src/win/snprintf.c
deleted file mode 100644
index 776c0e39..00000000
--- a/src/win/snprintf.c
+++ /dev/null
@@ -1,42 +0,0 @@
-/* Copyright the libuv project contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#if defined(_MSC_VER) && _MSC_VER < 1900
-
-#include <stdio.h>
-#include <stdarg.h>
-
-/* Emulate snprintf() on MSVC<2015, _snprintf() doesn't zero-terminate the buffer
- * on overflow...
- */
-int snprintf(char* buf, size_t len, const char* fmt, ...) {
-  int n;
-  va_list ap;
-  va_start(ap, fmt);
-
-  n = _vscprintf(fmt, ap);
-  vsnprintf_s(buf, len, _TRUNCATE, fmt, ap);
-
-  va_end(ap);
-  return n;
-}
-
-#endif
diff --git a/src/win/stream-inl.h b/src/win/stream-inl.h
index 40f5ddd5..cc3641aa 100644
--- a/src/win/stream-inl.h
+++ b/src/win/stream-inl.h
@@ -39,7 +39,7 @@ INLINE static void uv_stream_init(uv_loop_t* loop,
   handle->stream.conn.shutdown_req = NULL;
   handle->stream.conn.write_reqs_pending = 0;
 
-  UV_REQ_INIT(&handle->read_req, UV_READ);
+  UV_REQ_INIT(loop, &handle->read_req, UV_READ);
   handle->read_req.event_handle = NULL;
   handle->read_req.wait_handle = INVALID_HANDLE_VALUE;
   handle->read_req.data = handle;
diff --git a/src/win/stream.c b/src/win/stream.c
index 46a0709a..3c299ffd 100644
--- a/src/win/stream.c
+++ b/src/win/stream.c
@@ -204,7 +204,7 @@ int uv_shutdown(uv_shutdown_t* req, uv_stream_t* handle, uv_shutdown_cb cb) {
     return UV_ENOTCONN;
   }
 
-  UV_REQ_INIT(req, UV_SHUTDOWN);
+  UV_REQ_INIT(loop, req, UV_SHUTDOWN);
   req->handle = handle;
   req->cb = cb;
 
diff --git a/src/win/tcp.c b/src/win/tcp.c
index 0dcaa97d..9176241e 100644
--- a/src/win/tcp.c
+++ b/src/win/tcp.c
@@ -29,21 +29,11 @@
 #include "req-inl.h"
 
 
-/*
- * Threshold of active tcp streams for which to preallocate tcp read buffers.
- * (Due to node slab allocator performing poorly under this pattern,
- *  the optimization is temporarily disabled (threshold=0).  This will be
- *  revisited once node allocator is improved.)
- */
-const unsigned int uv_active_tcp_streams_threshold = 0;
-
 /*
  * Number of simultaneous pending AcceptEx calls.
  */
 const unsigned int uv_simultaneous_server_accepts = 32;
 
-/* A zero-size buffer for use by uv_tcp_read */
-static char uv_zero_[] = "";
 
 static int uv__tcp_nodelay(uv_tcp_t* handle, SOCKET socket, int enable) {
   if (setsockopt(socket,
@@ -275,7 +265,6 @@ void uv_tcp_endgame(uv_loop_t* loop, uv_tcp_t* handle) {
     }
 
     uv__handle_close(handle);
-    loop->active_tcp_streams--;
   }
 }
 
@@ -324,8 +313,7 @@ static int uv_tcp_try_bind(uv_tcp_t* handle,
     on = (flags & UV_TCP_IPV6ONLY) != 0;
 
     /* TODO: how to handle errors? This may fail if there is no ipv4 stack
-     * available, or when run on XP/2003 which have no support for dualstack
-     * sockets. For now we're silently ignoring the error. */
+     * available. For now we're silently ignoring the error. */
     setsockopt(handle->socket,
                IPPROTO_IPV6,
                IPV6_V6ONLY,
@@ -485,27 +473,8 @@ static void uv_tcp_queue_read(uv_loop_t* loop, uv_tcp_t* handle) {
 
   req = &handle->read_req;
   memset(&req->u.io.overlapped, 0, sizeof(req->u.io.overlapped));
-
-  /*
-   * Preallocate a read buffer if the number of active streams is below
-   * the threshold.
-  */
-  if (loop->active_tcp_streams < uv_active_tcp_streams_threshold) {
-    handle->flags &= ~UV_HANDLE_ZERO_READ;
-    handle->tcp.conn.read_buffer = uv_buf_init(NULL, 0);
-    handle->alloc_cb((uv_handle_t*) handle, 65536, &handle->tcp.conn.read_buffer);
-    if (handle->tcp.conn.read_buffer.base == NULL ||
-        handle->tcp.conn.read_buffer.len == 0) {
-      handle->read_cb((uv_stream_t*) handle, UV_ENOBUFS, &handle->tcp.conn.read_buffer);
-      return;
-    }
-    assert(handle->tcp.conn.read_buffer.base != NULL);
-    buf = handle->tcp.conn.read_buffer;
-  } else {
-    handle->flags |= UV_HANDLE_ZERO_READ;
-    buf.base = (char*) &uv_zero_;
-    buf.len = 0;
-  }
+  buf.base = "";
+  buf.len = 0;
 
   /* Prepare the overlapped structure. */
   memset(&(req->u.io.overlapped), 0, sizeof(req->u.io.overlapped));
@@ -620,7 +589,7 @@ int uv_tcp_listen(uv_tcp_t* handle, int backlog, uv_connection_cb cb) {
 
     for (i = 0; i < simultaneous_accepts; i++) {
       req = &handle->tcp.serv.accept_reqs[i];
-      UV_REQ_INIT(req, UV_ACCEPT);
+      UV_REQ_INIT(handle->loop, req, UV_ACCEPT);
       req->accept_socket = INVALID_SOCKET;
       req->data = handle;
 
@@ -642,7 +611,7 @@ int uv_tcp_listen(uv_tcp_t* handle, int backlog, uv_connection_cb cb) {
      * {uv_simultaneous_server_accepts} requests. */
     for (i = simultaneous_accepts; i < uv_simultaneous_server_accepts; i++) {
       req = &handle->tcp.serv.accept_reqs[i];
-      UV_REQ_INIT(req, UV_ACCEPT);
+      UV_REQ_INIT(handle->loop, req, UV_ACCEPT);
       req->accept_socket = INVALID_SOCKET;
       req->data = handle;
       req->wait_handle = INVALID_HANDLE_VALUE;
@@ -655,7 +624,6 @@ int uv_tcp_listen(uv_tcp_t* handle, int backlog, uv_connection_cb cb) {
 
 
 int uv_tcp_accept(uv_tcp_t* server, uv_tcp_t* client) {
-  uv_loop_t* loop = server->loop;
   int err = 0;
   int family;
 
@@ -717,8 +685,6 @@ int uv_tcp_accept(uv_tcp_t* server, uv_tcp_t* client) {
     }
   }
 
-  loop->active_tcp_streams++;
-
   return err;
 }
 
@@ -844,7 +810,7 @@ static int uv_tcp_try_connect(uv_connect_t* req,
              NULL);
   }
 
-  UV_REQ_INIT(req, UV_CONNECT);
+  UV_REQ_INIT(loop, req, UV_CONNECT);
   req->handle = (uv_stream_t*) handle;
   req->cb = cb;
   memset(&req->u.io.overlapped, 0, sizeof(req->u.io.overlapped));
@@ -907,7 +873,7 @@ int uv_tcp_write(uv_loop_t* loop,
   int result;
   DWORD bytes;
 
-  UV_REQ_INIT(req, UV_WRITE);
+  UV_REQ_INIT(loop, req, UV_WRITE);
   req->handle = (uv_stream_t*) handle;
   req->cb = cb;
 
@@ -1001,12 +967,10 @@ void uv_process_tcp_read_req(uv_loop_t* loop, uv_tcp_t* handle,
 
   if (!REQ_SUCCESS(req)) {
     /* An error occurred doing the read. */
-    if ((handle->flags & UV_HANDLE_READING) ||
-        !(handle->flags & UV_HANDLE_ZERO_READ)) {
+    if ((handle->flags & UV_HANDLE_READING) != 0) {
       handle->flags &= ~UV_HANDLE_READING;
       DECREASE_ACTIVE_COUNT(loop, handle);
-      buf = (handle->flags & UV_HANDLE_ZERO_READ) ?
-            uv_buf_init(NULL, 0) : handle->tcp.conn.read_buffer;
+      buf = uv_buf_init(NULL, 0);
 
       err = GET_REQ_SOCK_ERROR(req);
 
@@ -1021,32 +985,6 @@ void uv_process_tcp_read_req(uv_loop_t* loop, uv_tcp_t* handle,
                       &buf);
     }
   } else {
-    if (!(handle->flags & UV_HANDLE_ZERO_READ)) {
-      /* The read was done with a non-zero buffer length. */
-      if (req->u.io.overlapped.InternalHigh > 0) {
-        /* Successful read */
-        handle->read_cb((uv_stream_t*)handle,
-                        req->u.io.overlapped.InternalHigh,
-                        &handle->tcp.conn.read_buffer);
-        /* Read again only if bytes == buf.len */
-        if (req->u.io.overlapped.InternalHigh < handle->tcp.conn.read_buffer.len) {
-          goto done;
-        }
-      } else {
-        /* Connection closed */
-        if (handle->flags & UV_HANDLE_READING) {
-          handle->flags &= ~UV_HANDLE_READING;
-          DECREASE_ACTIVE_COUNT(loop, handle);
-        }
-        handle->flags &= ~UV_HANDLE_READABLE;
-
-        buf.base = 0;
-        buf.len = 0;
-        handle->read_cb((uv_stream_t*)handle, UV_EOF, &handle->tcp.conn.read_buffer);
-        goto done;
-      }
-    }
-
     /* Do nonblocking reads until the buffer is empty */
     count = 32;
     while ((handle->flags & UV_HANDLE_READING) && (count-- > 0)) {
@@ -1105,7 +1043,6 @@ void uv_process_tcp_read_req(uv_loop_t* loop, uv_tcp_t* handle,
       }
     }
 
-done:
     /* Post another read if still reading and not closing. */
     if ((handle->flags & UV_HANDLE_READING) &&
         !(handle->flags & UV_HANDLE_READ_PENDING)) {
@@ -1226,7 +1163,6 @@ void uv_process_tcp_connect_req(uv_loop_t* loop, uv_tcp_t* handle,
                           0) == 0) {
       uv_connection_init((uv_stream_t*)handle);
       handle->flags |= UV_HANDLE_READABLE | UV_HANDLE_WRITABLE;
-      loop->active_tcp_streams++;
     } else {
       err = WSAGetLastError();
     }
@@ -1309,7 +1245,6 @@ int uv__tcp_xfer_import(uv_tcp_t* tcp,
     tcp->flags |= UV_HANDLE_READABLE | UV_HANDLE_WRITABLE;
   }
 
-  tcp->loop->active_tcp_streams++;
   return 0;
 }
 
@@ -1394,8 +1329,8 @@ static int uv_tcp_try_cancel_io(uv_tcp_t* tcp) {
   non_ifs_lsp = (tcp->flags & UV_HANDLE_IPV6) ? uv_tcp_non_ifs_lsp_ipv6 :
                                                 uv_tcp_non_ifs_lsp_ipv4;
 
-  /* If there are non-ifs LSPs then try to obtain a base handle for the socket.
-   * This will always fail on Windows XP/3k. */
+  /* If there are non-ifs LSPs then try to obtain a base handle for the
+   * socket. */
   if (non_ifs_lsp) {
     DWORD bytes;
     if (WSAIoctl(socket,
@@ -1571,3 +1506,118 @@ int uv__tcp_connect(uv_connect_t* req,
 
   return 0;
 }
+
+#ifndef WSA_FLAG_NO_HANDLE_INHERIT
+/* Added in Windows 7 SP1. Specify this to avoid race conditions, */
+/* but also manually clear the inherit flag in case this failed. */
+#define WSA_FLAG_NO_HANDLE_INHERIT 0x80
+#endif
+
+int uv_socketpair(int type, int protocol, uv_os_sock_t fds[2], int flags0, int flags1) {
+  SOCKET server = INVALID_SOCKET;
+  SOCKET client0 = INVALID_SOCKET;
+  SOCKET client1 = INVALID_SOCKET;
+  SOCKADDR_IN name;
+  LPFN_ACCEPTEX func_acceptex;
+  WSAOVERLAPPED overlap;
+  char accept_buffer[sizeof(struct sockaddr_storage) * 2 + 32];
+  int namelen;
+  int err;
+  DWORD bytes;
+  DWORD flags;
+  DWORD client0_flags = WSA_FLAG_NO_HANDLE_INHERIT;
+  DWORD client1_flags = WSA_FLAG_NO_HANDLE_INHERIT;
+
+  if (flags0 & UV_NONBLOCK_PIPE)
+      client0_flags |= WSA_FLAG_OVERLAPPED;
+  if (flags1 & UV_NONBLOCK_PIPE)
+      client1_flags |= WSA_FLAG_OVERLAPPED;
+
+  server = WSASocketW(AF_INET, type, protocol, NULL, 0,
+                      WSA_FLAG_OVERLAPPED | WSA_FLAG_NO_HANDLE_INHERIT);
+  if (server == INVALID_SOCKET)
+    goto wsaerror;
+  if (!SetHandleInformation((HANDLE) server, HANDLE_FLAG_INHERIT, 0))
+    goto error;
+  name.sin_family = AF_INET;
+  name.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+  name.sin_port = 0;
+  if (bind(server, (SOCKADDR*) &name, sizeof(name)) != 0)
+    goto wsaerror;
+  if (listen(server, 1) != 0)
+    goto wsaerror;
+  namelen = sizeof(name);
+  if (getsockname(server, (SOCKADDR*) &name, &namelen) != 0)
+    goto wsaerror;
+  client0 = WSASocketW(AF_INET, type, protocol, NULL, 0, client0_flags);
+  if (client0 == INVALID_SOCKET)
+    goto wsaerror;
+  if (!SetHandleInformation((HANDLE) client0, HANDLE_FLAG_INHERIT, 0))
+    goto error;
+  if (connect(client0, (SOCKADDR*) &name, sizeof(name)) != 0)
+    goto wsaerror;
+  client1 = WSASocketW(AF_INET, type, protocol, NULL, 0, client1_flags);
+  if (client1 == INVALID_SOCKET)
+    goto wsaerror;
+  if (!SetHandleInformation((HANDLE) client1, HANDLE_FLAG_INHERIT, 0))
+    goto error;
+  if (!uv_get_acceptex_function(server, &func_acceptex)) {
+    err = WSAEAFNOSUPPORT;
+    goto cleanup;
+  }
+  memset(&overlap, 0, sizeof(overlap));
+  if (!func_acceptex(server,
+                     client1,
+                     accept_buffer,
+                     0,
+                     sizeof(struct sockaddr_storage),
+                     sizeof(struct sockaddr_storage),
+                     &bytes,
+                     &overlap)) {
+    err = WSAGetLastError();
+    if (err == ERROR_IO_PENDING) {
+      /* Result should complete immediately, since we already called connect,
+       * but emperically, we sometimes have to poll the kernel a couple times
+       * until it notices that. */
+      while (!WSAGetOverlappedResult(client1, &overlap, &bytes, FALSE, &flags)) {
+        err = WSAGetLastError();
+        if (err != WSA_IO_INCOMPLETE)
+          goto cleanup;
+        SwitchToThread();
+      }
+    }
+    else {
+      goto cleanup;
+    }
+  }
+  if (setsockopt(client1, SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT,
+                  (char*) &server, sizeof(server)) != 0) {
+    goto wsaerror;
+  }
+
+  closesocket(server);
+
+  fds[0] = client0;
+  fds[1] = client1;
+
+  return 0;
+
+ wsaerror:
+    err = WSAGetLastError();
+    goto cleanup;
+
+ error:
+    err = GetLastError();
+    goto cleanup;
+
+ cleanup:
+    if (server != INVALID_SOCKET)
+      closesocket(server);
+    if (client0 != INVALID_SOCKET)
+      closesocket(client0);
+    if (client1 != INVALID_SOCKET)
+      closesocket(client1);
+
+    assert(err);
+    return uv_translate_sys_error(err);
+}
diff --git a/src/win/thread.c b/src/win/thread.c
index 89c53ada..6e7c53b5 100644
--- a/src/win/thread.c
+++ b/src/win/thread.c
@@ -22,6 +22,8 @@
 #include <assert.h>
 #include <limits.h>
 #include <stdlib.h>
+#include <process.h> /* _beginthreadex */
+#include <errno.h> /* _beginthreadex errors */
 
 #if defined(__MINGW64_VERSION_MAJOR)
 /* MemoryBarrier expands to __mm_mfence in some cases (x86+sse2), which may
@@ -32,6 +34,7 @@
 #include "uv.h"
 #include "internal.h"
 
+
 static void uv__once_inner(uv_once_t* guard, void (*callback)(void)) {
   DWORD result;
   HANDLE existing_event, created_event;
@@ -181,6 +184,87 @@ int uv_thread_create_ex(uv_thread_t* tid,
 }
 
 
+int uv_thread_setaffinity(uv_thread_t* tid,
+                          char* cpumask,
+                          char* oldmask,
+                          size_t mask_size) {
+  int i;
+  HANDLE hproc;
+  DWORD_PTR procmask;
+  DWORD_PTR sysmask;
+  DWORD_PTR threadmask;
+  DWORD_PTR oldthreadmask;
+  int cpumasksize;
+
+  cpumasksize = uv_cpumask_size();
+  assert(cpumasksize > 0);
+  if (mask_size < (size_t)cpumasksize)
+    return UV_EINVAL;
+
+  hproc = GetCurrentProcess();
+  if (!GetProcessAffinityMask(hproc, &procmask, &sysmask))
+    return uv_translate_sys_error(GetLastError());
+
+  threadmask = 0;
+  for (i = 0; i < cpumasksize; i++) {
+    if (cpumask[i]) {
+      if (procmask & (1 << i))
+        threadmask |= 1 << i;
+      else
+        return UV_EINVAL;
+    }
+  }
+
+  oldthreadmask = SetThreadAffinityMask(*tid, threadmask);
+  if (oldthreadmask == 0)
+    return uv_translate_sys_error(GetLastError());
+
+  if (oldmask != NULL) {
+    for (i = 0; i < cpumasksize; i++)
+      oldmask[i] = (oldthreadmask >> i) & 1;
+  }
+
+  return 0;
+}
+
+
+int uv_thread_getaffinity(uv_thread_t* tid,
+                          char* cpumask,
+                          size_t mask_size) {
+  int i;
+  HANDLE hproc;
+  DWORD_PTR procmask;
+  DWORD_PTR sysmask;
+  DWORD_PTR threadmask;
+  int cpumasksize;
+
+  cpumasksize = uv_cpumask_size();
+  assert(cpumasksize > 0);
+  if (mask_size < (size_t)cpumasksize)
+    return UV_EINVAL;
+
+  hproc = GetCurrentProcess();
+  if (!GetProcessAffinityMask(hproc, &procmask, &sysmask))
+    return uv_translate_sys_error(GetLastError());
+
+  threadmask = SetThreadAffinityMask(*tid, procmask);
+  if (threadmask == 0 || SetThreadAffinityMask(*tid, threadmask) == 0)
+    return uv_translate_sys_error(GetLastError());
+
+  for (i = 0; i < cpumasksize; i++)
+    cpumask[i] = (threadmask >> i) & 1;
+
+  return 0;
+}
+
+
+int uv_thread_detach(uv_thread_t* tid) {
+  CloseHandle(*tid);
+  *tid = 0;
+  return 0;
+}
+
+
 uv_thread_t uv_thread_self(void) {
   uv_once(&uv__current_thread_init_guard, uv__init_current_thread_key);
   return (uv_thread_t) uv_key_get(&uv__current_thread_key);
@@ -243,57 +327,57 @@ int uv_rwlock_init(uv_rwlock_t* rwlock) {
   HANDLE handle = CreateSemaphoreW(NULL, 1, 1, NULL);
   if (handle == NULL)
     return uv_translate_sys_error(GetLastError());
-  rwlock->state_.write_semaphore_ = handle;
+  rwlock->write_semaphore_ = handle;
 
   /* Initialize the critical section protecting the reader count. */
-  InitializeCriticalSection(&rwlock->state_.num_readers_lock_);
+  InitializeCriticalSection(&rwlock->num_readers_lock_);
 
   /* Initialize the reader count. */
-  rwlock->state_.num_readers_ = 0;
+  rwlock->num_readers_ = 0;
 
   return 0;
 }
 
 
 void uv_rwlock_destroy(uv_rwlock_t* rwlock) {
-  DeleteCriticalSection(&rwlock->state_.num_readers_lock_);
-  CloseHandle(rwlock->state_.write_semaphore_);
+  DeleteCriticalSection(&rwlock->num_readers_lock_);
+  CloseHandle(rwlock->write_semaphore_);
 }
 
 
 void uv_rwlock_rdlock(uv_rwlock_t* rwlock) {
   /* Acquire the lock that protects the reader count. */
-  EnterCriticalSection(&rwlock->state_.num_readers_lock_);
+  EnterCriticalSection(&rwlock->num_readers_lock_);
 
   /* Increase the reader count, and lock for write if this is the first
    * reader.
    */
-  if (++rwlock->state_.num_readers_ == 1) {
-    DWORD r = WaitForSingleObject(rwlock->state_.write_semaphore_, INFINITE);
+  if (++rwlock->num_readers_ == 1) {
+    DWORD r = WaitForSingleObject(rwlock->write_semaphore_, INFINITE);
     if (r != WAIT_OBJECT_0)
       uv_fatal_error(GetLastError(), "WaitForSingleObject");
   }
 
   /* Release the lock that protects the reader count. */
-  LeaveCriticalSection(&rwlock->state_.num_readers_lock_);
+  LeaveCriticalSection(&rwlock->num_readers_lock_);
 }
 
 
 int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock) {
   int err;
 
-  if (!TryEnterCriticalSection(&rwlock->state_.num_readers_lock_))
+  if (!TryEnterCriticalSection(&rwlock->num_readers_lock_))
     return UV_EBUSY;
 
   err = 0;
 
-  if (rwlock->state_.num_readers_ == 0) {
+  if (rwlock->num_readers_ == 0) {
     /* Currently there are no other readers, which means that the write lock
      * needs to be acquired.
      */
-    DWORD r = WaitForSingleObject(rwlock->state_.write_semaphore_, 0);
+    DWORD r = WaitForSingleObject(rwlock->write_semaphore_, 0);
     if (r == WAIT_OBJECT_0)
-      rwlock->state_.num_readers_++;
+      rwlock->num_readers_++;
     else if (r == WAIT_TIMEOUT)
       err = UV_EBUSY;
     else if (r == WAIT_FAILED)
@@ -303,35 +387,35 @@ int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock) {
     /* The write lock has already been acquired because there are other
      * active readers.
      */
-    rwlock->state_.num_readers_++;
+    rwlock->num_readers_++;
   }
 
-  LeaveCriticalSection(&rwlock->state_.num_readers_lock_);
+  LeaveCriticalSection(&rwlock->num_readers_lock_);
   return err;
 }
 
 
 void uv_rwlock_rdunlock(uv_rwlock_t* rwlock) {
-  EnterCriticalSection(&rwlock->state_.num_readers_lock_);
+  EnterCriticalSection(&rwlock->num_readers_lock_);
 
-  if (--rwlock->state_.num_readers_ == 0) {
-    if (!ReleaseSemaphore(rwlock->state_.write_semaphore_, 1, NULL))
+  if (--rwlock->num_readers_ == 0) {
+    if (!ReleaseSemaphore(rwlock->write_semaphore_, 1, NULL))
       uv_fatal_error(GetLastError(), "ReleaseSemaphore");
   }
 
-  LeaveCriticalSection(&rwlock->state_.num_readers_lock_);
+  LeaveCriticalSection(&rwlock->num_readers_lock_);
 }
 
 
 void uv_rwlock_wrlock(uv_rwlock_t* rwlock) {
-  DWORD r = WaitForSingleObject(rwlock->state_.write_semaphore_, INFINITE);
+  DWORD r = WaitForSingleObject(rwlock->write_semaphore_, INFINITE);
   if (r != WAIT_OBJECT_0)
     uv_fatal_error(GetLastError(), "WaitForSingleObject");
 }
 
 
 int uv_rwlock_trywrlock(uv_rwlock_t* rwlock) {
-  DWORD r = WaitForSingleObject(rwlock->state_.write_semaphore_, 0);
+  DWORD r = WaitForSingleObject(rwlock->write_semaphore_, 0);
   if (r == WAIT_OBJECT_0)
     return 0;
   else if (r == WAIT_TIMEOUT)
@@ -342,7 +426,7 @@ int uv_rwlock_trywrlock(uv_rwlock_t* rwlock) {
 
 
 void uv_rwlock_wrunlock(uv_rwlock_t* rwlock) {
-  if (!ReleaseSemaphore(rwlock->state_.write_semaphore_, 1, NULL))
+  if (!ReleaseSemaphore(rwlock->write_semaphore_, 1, NULL))
     uv_fatal_error(GetLastError(), "ReleaseSemaphore");
 }
 
@@ -389,34 +473,37 @@ int uv_sem_trywait(uv_sem_t* sem) {
 
 
 int uv_cond_init(uv_cond_t* cond) {
-  InitializeConditionVariable(&cond->cond_var);
+  InitializeConditionVariable(cond);
   return 0;
 }
 
 
 void uv_cond_destroy(uv_cond_t* cond) {
-  /* nothing to do */
+  /* Nothing to do. */
   (void) &cond;
 }
 
 
 void uv_cond_signal(uv_cond_t* cond) {
-  WakeConditionVariable(&cond->cond_var);
+  WakeConditionVariable(cond);
 }
 
 
 void uv_cond_broadcast(uv_cond_t* cond) {
-  WakeAllConditionVariable(&cond->cond_var);
+  WakeAllConditionVariable(cond);
 }
 
 
 void uv_cond_wait(uv_cond_t* cond, uv_mutex_t* mutex) {
-  if (!SleepConditionVariableCS(&cond->cond_var, mutex, INFINITE))
+  if (!SleepConditionVariableCS(cond, mutex, INFINITE))
     abort();
 }
 
-int uv_cond_timedwait(uv_cond_t* cond, uv_mutex_t* mutex, uint64_t timeout) {
-  if (SleepConditionVariableCS(&cond->cond_var, mutex, (DWORD)(timeout / 1e6)))
+
+int uv_cond_timedwait(uv_cond_t* cond,
+                      uv_mutex_t* mutex,
+                      uint64_t timeout) {
+  if (SleepConditionVariableCS(cond, mutex, (DWORD)(timeout / 1e6)))
     return 0;
   if (GetLastError() != ERROR_TIMEOUT)
     abort();
diff --git a/src/win/tty.c b/src/win/tty.c
index 4604fb0c..bbf46466 100644
--- a/src/win/tty.c
+++ b/src/win/tty.c
@@ -20,15 +20,8 @@
  */
 
 #include <assert.h>
-#include <io.h>
-#include <string.h>
 #include <stdlib.h>
-
-#if defined(_MSC_VER) && _MSC_VER < 1600
-# include "uv/stdint-msvc2008.h"
-#else
-# include <stdint.h>
-#endif
+#include <stdint.h>
 
 #ifndef COMMON_LVB_REVERSE_VIDEO
 # define COMMON_LVB_REVERSE_VIDEO 0x4000
@@ -187,35 +180,23 @@ void uv_console_init(void) {
 }
 
 
-int uv_tty_init(uv_loop_t* loop, uv_tty_t* tty, uv_file fd, int unused) {
+int uv_tty_init(uv_loop_t* loop, uv_tty_t* tty, uv_os_fd_t handle, int unused) {
   BOOL readable;
   DWORD NumberOfEvents;
-  HANDLE handle;
   CONSOLE_SCREEN_BUFFER_INFO screen_buffer_info;
   CONSOLE_CURSOR_INFO cursor_info;
   (void)unused;
 
-  uv__once_init();
-  handle = (HANDLE) uv__get_osfhandle(fd);
   if (handle == INVALID_HANDLE_VALUE)
     return UV_EBADF;
 
-  if (fd <= 2) {
-    /* In order to avoid closing a stdio file descriptor 0-2, duplicate the
-     * underlying OS handle and forget about the original fd.
-     * We could also opt to use the original OS handle and just never close it,
-     * but then there would be no reliable way to cancel pending read operations
-     * upon close.
+  if (handle == UV_STDIN_FD || handle == UV_STDOUT_FD || handle == UV_STDERR_FD) {
+    /* In order to avoid closing a stdio pseudo-handle, or having it get replaced under us,
+     * duplicate the underlying OS handle and forget about the original one.
      */
-    if (!DuplicateHandle(INVALID_HANDLE_VALUE,
-                         handle,
-                         INVALID_HANDLE_VALUE,
-                         &handle,
-                         0,
-                         FALSE,
-                         DUPLICATE_SAME_ACCESS))
-      return uv_translate_sys_error(GetLastError());
-    fd = -1;
+    int dup_err = uv__dup(handle, &handle);
+    if (dup_err)
+      return dup_err;
   }
 
   readable = GetNumberOfConsoleInputEvents(handle, &NumberOfEvents);
@@ -250,15 +231,12 @@ int uv_tty_init(uv_loop_t* loop, uv_tty_t* tty, uv_file fd, int unused) {
   uv_connection_init((uv_stream_t*) tty);
 
   tty->handle = handle;
-  tty->u.fd = fd;
   tty->reqs_pending = 0;
   tty->flags |= UV_HANDLE_BOUND;
 
   if (readable) {
     /* Initialize TTY input specific fields. */
     tty->flags |= UV_HANDLE_TTY_READABLE | UV_HANDLE_READABLE;
-    /* TODO: remove me in v2.x. */
-    tty->tty.rd.unused_ = NULL;
     tty->tty.rd.read_line_buffer = uv_null_buf_;
     tty->tty.rd.read_raw_wait = NULL;
 
@@ -701,7 +679,7 @@ void uv_process_tty_read_raw_req(uv_loop_t* loop, uv_tty_t* handle,
 
   DWORD records_left, records_read;
   uv_buf_t buf;
-  off_t buf_used;
+  ssize_t buf_used;
 
   assert(handle->type == UV_TTY);
   assert(handle->flags & UV_HANDLE_TTY_READABLE);
@@ -2122,13 +2100,6 @@ static int uv_tty_write_bufs(uv_tty_t* handle,
         abort();
       }
 
-      /* We wouldn't mind emitting utf-16 surrogate pairs. Too bad, the windows
-       * console doesn't really support UTF-16, so just emit the replacement
-       * character. */
-      if (utf8_codepoint > 0xffff) {
-        utf8_codepoint = UNICODE_REPLACEMENT_CHARACTER;
-      }
-
       if (utf8_codepoint == 0x0a || utf8_codepoint == 0x0d) {
         /* EOL conversion - emit \r\n when we see \n. */
 
@@ -2155,6 +2126,12 @@ static int uv_tty_write_bufs(uv_tty_t* handle,
         ENSURE_BUFFER_SPACE(1);
         utf16_buf[utf16_buf_used++] = (WCHAR) utf8_codepoint;
         previous_eol = 0;
+      } else {
+        ENSURE_BUFFER_SPACE(2);
+        utf8_codepoint -= 0x10000;
+        utf16_buf[utf16_buf_used++] = (WCHAR) (utf8_codepoint / 0x400 + 0xD800);
+        utf16_buf[utf16_buf_used++] = (WCHAR) (utf8_codepoint % 0x400 + 0xDC00);
+        previous_eol = 0;
       }
     }
   }
@@ -2188,7 +2165,7 @@ int uv_tty_write(uv_loop_t* loop,
                  uv_write_cb cb) {
   DWORD error;
 
-  UV_REQ_INIT(req, UV_WRITE);
+  UV_REQ_INIT(loop, req, UV_WRITE);
   req->handle = (uv_stream_t*) handle;
   req->cb = cb;
 
@@ -2248,16 +2225,10 @@ void uv_process_tty_write_req(uv_loop_t* loop, uv_tty_t* handle,
 
 
 void uv_tty_close(uv_tty_t* handle) {
-  assert(handle->u.fd == -1 || handle->u.fd > 2);
   if (handle->flags & UV_HANDLE_READING)
     uv_tty_read_stop(handle);
 
-  if (handle->u.fd == -1)
-    CloseHandle(handle->handle);
-  else
-    close(handle->u.fd);
-
-  handle->u.fd = -1;
+  CloseHandle(handle->handle);
   handle->handle = INVALID_HANDLE_VALUE;
   handle->flags &= ~(UV_HANDLE_READABLE | UV_HANDLE_WRITABLE);
   uv__handle_closing(handle);
diff --git a/src/win/udp.c b/src/win/udp.c
index 7032b685..2548e67e 100644
--- a/src/win/udp.c
+++ b/src/win/udp.c
@@ -34,8 +34,6 @@
  */
 const unsigned int uv_active_udp_streams_threshold = 0;
 
-/* A zero-size buffer for use by uv_udp_read */
-static char uv_zero_[] = "";
 int uv_udp_getpeername(const uv_udp_t* handle,
                        struct sockaddr* name,
                        int* namelen) {
@@ -94,9 +92,11 @@ static int uv_udp_set_socket(uv_loop_t* loop, uv_udp_t* handle, SOCKET socket,
    * the default UDP driver (AFD) and has no other. LSPs stacked on top. Here
    * we check whether that is the case. */
   opt_len = (int) sizeof info;
-  if (getsockopt(
-          socket, SOL_SOCKET, SO_PROTOCOL_INFOW, (char*) &info, &opt_len) ==
-      SOCKET_ERROR) {
+  if (getsockopt(socket,
+                 SOL_SOCKET,
+                 SO_PROTOCOL_INFOW,
+                 (char*) &info,
+                 &opt_len) == SOCKET_ERROR) {
     return GetLastError();
   }
 
@@ -137,7 +137,7 @@ int uv__udp_init_ex(uv_loop_t* loop,
   handle->func_wsarecvfrom = WSARecvFrom;
   handle->send_queue_size = 0;
   handle->send_queue_count = 0;
-  UV_REQ_INIT(&handle->recv_req, UV_UDP_RECV);
+  UV_REQ_INIT(loop, &handle->recv_req, UV_UDP_RECV);
   handle->recv_req.data = handle;
 
   /* If anything fails beyond this point we need to remove the handle from
@@ -244,8 +244,7 @@ static int uv_udp_maybe_bind(uv_udp_t* handle,
      * libuv turns it off. */
 
     /* TODO: how to handle errors? This may fail if there is no ipv4 stack
-     * available, or when run on XP/2003 which have no support for dualstack
-     * sockets. For now we're silently ignoring the error. */
+       available. For now we're silently ignoring the error. */
     setsockopt(handle->socket,
                IPPROTO_IPV6,
                IPV6_V6ONLY,
@@ -275,85 +274,33 @@ static void uv_udp_queue_recv(uv_loop_t* loop, uv_udp_t* handle) {
 
   req = &handle->recv_req;
   memset(&req->u.io.overlapped, 0, sizeof(req->u.io.overlapped));
+  buf.base = "";
+  buf.len = 0;
+  flags = MSG_PEEK;
+
+  result = handle->func_wsarecv(handle->socket,
+                                (WSABUF*) &buf,
+                                1,
+                                &bytes,
+                                &flags,
+                                &req->u.io.overlapped,
+                                NULL);
 
-  /*
-   * Preallocate a read buffer if the number of active streams is below
-   * the threshold.
-  */
-  if (loop->active_udp_streams < uv_active_udp_streams_threshold) {
-    handle->flags &= ~UV_HANDLE_ZERO_READ;
-
-    handle->recv_buffer = uv_buf_init(NULL, 0);
-    handle->alloc_cb((uv_handle_t*) handle, 65536, &handle->recv_buffer);
-    if (handle->recv_buffer.base == NULL || handle->recv_buffer.len == 0) {
-      handle->recv_cb(handle, UV_ENOBUFS, &handle->recv_buffer, NULL, 0);
-      return;
-    }
-    assert(handle->recv_buffer.base != NULL);
-
-    buf = handle->recv_buffer;
-    memset(&handle->recv_from, 0, sizeof handle->recv_from);
-    handle->recv_from_len = sizeof handle->recv_from;
-    flags = 0;
-
-    result = handle->func_wsarecvfrom(handle->socket,
-                                      (WSABUF*) &buf,
-                                      1,
-                                      &bytes,
-                                      &flags,
-                                      (struct sockaddr*) &handle->recv_from,
-                                      &handle->recv_from_len,
-                                      &req->u.io.overlapped,
-                                      NULL);
-
-    if (UV_SUCCEEDED_WITHOUT_IOCP(result == 0)) {
-      /* Process the req without IOCP. */
-      handle->flags |= UV_HANDLE_READ_PENDING;
-      req->u.io.overlapped.InternalHigh = bytes;
-      handle->reqs_pending++;
-      uv_insert_pending_req(loop, req);
-    } else if (UV_SUCCEEDED_WITH_IOCP(result == 0)) {
-      /* The req will be processed with IOCP. */
-      handle->flags |= UV_HANDLE_READ_PENDING;
-      handle->reqs_pending++;
-    } else {
-      /* Make this req pending reporting an error. */
-      SET_REQ_ERROR(req, WSAGetLastError());
-      uv_insert_pending_req(loop, req);
-      handle->reqs_pending++;
-    }
-
+  if (UV_SUCCEEDED_WITHOUT_IOCP(result == 0)) {
+    /* Process the req without IOCP. */
+    handle->flags |= UV_HANDLE_READ_PENDING;
+    req->u.io.overlapped.InternalHigh = bytes;
+    handle->reqs_pending++;
+    uv_insert_pending_req(loop, req);
+  } else if (UV_SUCCEEDED_WITH_IOCP(result == 0)) {
+    /* The req will be processed with IOCP. */
+    handle->flags |= UV_HANDLE_READ_PENDING;
+    handle->reqs_pending++;
   } else {
-    handle->flags |= UV_HANDLE_ZERO_READ;
-
-    buf.base = (char*) uv_zero_;
-    buf.len = 0;
-    flags = MSG_PEEK;
-
-    result = handle->func_wsarecv(handle->socket,
-                                  (WSABUF*) &buf,
-                                  1,
-                                  &bytes,
-                                  &flags,
-                                  &req->u.io.overlapped,
-                                  NULL);
-
-    if (UV_SUCCEEDED_WITHOUT_IOCP(result == 0)) {
-      /* Process the req without IOCP. */
-      handle->flags |= UV_HANDLE_READ_PENDING;
-      req->u.io.overlapped.InternalHigh = bytes;
-      handle->reqs_pending++;
-      uv_insert_pending_req(loop, req);
-    } else if (UV_SUCCEEDED_WITH_IOCP(result == 0)) {
-      /* The req will be processed with IOCP. */
-      handle->flags |= UV_HANDLE_READ_PENDING;
-      handle->reqs_pending++;
-    } else {
-      /* Make this req pending reporting an error. */
-      SET_REQ_ERROR(req, WSAGetLastError());
-      uv_insert_pending_req(loop, req);
-      handle->reqs_pending++;
-    }
+    /* Make this req pending reporting an error. */
+    SET_REQ_ERROR(req, WSAGetLastError());
+    uv_insert_pending_req(loop, req);
+    handle->reqs_pending++;
   }
 }
 
@@ -376,7 +323,6 @@ int uv__udp_recv_start(uv_udp_t* handle, uv_alloc_cb alloc_cb,
 
   handle->flags |= UV_HANDLE_READING;
   INCREASE_ACTIVE_COUNT(loop, handle);
-  loop->active_udp_streams++;
 
   handle->recv_cb = recv_cb;
   handle->alloc_cb = alloc_cb;
@@ -393,7 +339,6 @@ int uv__udp_recv_start(uv_udp_t* handle, uv_alloc_cb alloc_cb,
 int uv__udp_recv_stop(uv_udp_t* handle) {
   if (handle->flags & UV_HANDLE_READING) {
     handle->flags &= ~UV_HANDLE_READING;
-    handle->loop->active_udp_streams--;
     DECREASE_ACTIVE_COUNT(loop, handle);
   }
 
@@ -411,7 +356,7 @@ static int uv__send(uv_udp_send_t* req,
   uv_loop_t* loop = handle->loop;
   DWORD result, bytes;
 
-  UV_REQ_INIT(req, UV_UDP_SEND);
+  UV_REQ_INIT(loop, req, UV_UDP_SEND);
   req->handle = handle;
   req->cb = cb;
   memset(&req->u.io.overlapped, 0, sizeof(req->u.io.overlapped));
@@ -453,7 +398,6 @@ static int uv__send(uv_udp_send_t* req,
 void uv_process_udp_recv_req(uv_loop_t* loop, uv_udp_t* handle,
     uv_req_t* req) {
   uv_buf_t buf;
-  int partial;
 
   assert(handle->type == UV_UDP);
 
@@ -465,35 +409,22 @@ void uv_process_udp_recv_req(uv_loop_t* loop, uv_udp_t* handle,
       /* Not a real error, it just indicates that the received packet was
        * bigger than the receive buffer. */
     } else if (err == WSAECONNRESET || err == WSAENETRESET) {
-      /* A previous sendto operation failed; ignore this error. If zero-reading
-       * we need to call WSARecv/WSARecvFrom _without_ the. MSG_PEEK flag to
-       * clear out the error queue. For nonzero reads, immediately queue a new
-       * receive. */
-      if (!(handle->flags & UV_HANDLE_ZERO_READ)) {
-        goto done;
-      }
+      /* A previous sendto operation failed; ignore this error.
+       * We need to call WSARecv/WSARecvFrom _without_ the MSG_PEEK flag to
+       * clear out the error queue. */
     } else {
       /* A real error occurred. Report the error to the user only if we're
        * currently reading. */
       if (handle->flags & UV_HANDLE_READING) {
         uv_udp_recv_stop(handle);
-        buf = (handle->flags & UV_HANDLE_ZERO_READ) ?
-              uv_buf_init(NULL, 0) : handle->recv_buffer;
+        buf = uv_buf_init(NULL, 0);
         handle->recv_cb(handle, uv_translate_sys_error(err), &buf, NULL, 0);
       }
       goto done;
     }
   }
 
-  if (!(handle->flags & UV_HANDLE_ZERO_READ)) {
-    /* Successful read */
-    partial = !REQ_SUCCESS(req);
-    handle->recv_cb(handle,
-                    req->u.io.overlapped.InternalHigh,
-                    &handle->recv_buffer,
-                    (const struct sockaddr*) &handle->recv_from,
-                    partial ? UV_UDP_PARTIAL : 0);
-  } else if (handle->flags & UV_HANDLE_READING) {
+  if (handle->flags & UV_HANDLE_READING) {
     DWORD bytes, err, flags;
     struct sockaddr_storage from;
     int from_len;
diff --git a/src/win/util.c b/src/win/util.c
index aad8f1a1..87bbb97c 100644
--- a/src/win/util.c
+++ b/src/win/util.c
@@ -22,10 +22,8 @@
 #include <assert.h>
 #include <direct.h>
 #include <limits.h>
+#include <wchar.h> /* wmemcmp */
 #include <stdio.h>
-#include <string.h>
-#include <time.h>
-#include <wchar.h>
 
 #include "uv.h"
 #include "internal.h"
@@ -41,6 +39,10 @@
 #include <userenv.h>
 #include <math.h>
 
+#define SECURITY_WIN32
+#include <security.h>
+
+
 /*
  * Max title length; the only thing MSDN tells us about the maximum length
  * of the console title is that it is smaller than 64K. However in practice
@@ -684,7 +686,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos_ptr, int* cpu_count_ptr) {
     DWORD cpu_brand_size = sizeof(cpu_brand);
     size_t len;
 
-    len = _snwprintf(key_name,
+    len = swprintf(key_name,
                      ARRAY_SIZE(key_name),
                      L"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\%d",
                      i);
@@ -756,71 +758,6 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos_ptr, int* cpu_count_ptr) {
 }
 
 
-static int is_windows_version_or_greater(DWORD os_major,
-                                         DWORD os_minor,
-                                         WORD service_pack_major,
-                                         WORD service_pack_minor) {
-  OSVERSIONINFOEX osvi;
-  DWORDLONG condition_mask = 0;
-  int op = VER_GREATER_EQUAL;
-
-  /* Initialize the OSVERSIONINFOEX structure. */
-  ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
-  osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
-  osvi.dwMajorVersion = os_major;
-  osvi.dwMinorVersion = os_minor;
-  osvi.wServicePackMajor = service_pack_major;
-  osvi.wServicePackMinor = service_pack_minor;
-
-  /* Initialize the condition mask. */
-  VER_SET_CONDITION(condition_mask, VER_MAJORVERSION, op);
-  VER_SET_CONDITION(condition_mask, VER_MINORVERSION, op);
-  VER_SET_CONDITION(condition_mask, VER_SERVICEPACKMAJOR, op);
-  VER_SET_CONDITION(condition_mask, VER_SERVICEPACKMINOR, op);
-
-  /* Perform the test. */
-  return (int) VerifyVersionInfo(
-    &osvi,
-    VER_MAJORVERSION | VER_MINORVERSION |
-    VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
-    condition_mask);
-}
-
-
-static int address_prefix_match(int family,
-                                struct sockaddr* address,
-                                struct sockaddr* prefix_address,
-                                int prefix_len) {
-  uint8_t* address_data;
-  uint8_t* prefix_address_data;
-  int i;
-
-  assert(address->sa_family == family);
-  assert(prefix_address->sa_family == family);
-
-  if (family == AF_INET6) {
-    address_data = (uint8_t*) &(((struct sockaddr_in6 *) address)->sin6_addr);
-    prefix_address_data =
-      (uint8_t*) &(((struct sockaddr_in6 *) prefix_address)->sin6_addr);
-  } else {
-    address_data = (uint8_t*) &(((struct sockaddr_in *) address)->sin_addr);
-    prefix_address_data =
-      (uint8_t*) &(((struct sockaddr_in *) prefix_address)->sin_addr);
-  }
-
-  for (i = 0; i < prefix_len >> 3; i++) {
-    if (address_data[i] != prefix_address_data[i])
-      return 0;
-  }
-
-  if (prefix_len % 8)
-    return prefix_address_data[i] ==
-      (address_data[i] & (0xff << (8 - prefix_len % 8)));
-
-  return 1;
-}
-
-
 int uv_interface_addresses(uv_interface_address_t** addresses_ptr,
     int* count_ptr) {
   IP_ADAPTER_ADDRESSES* win_address_buf;
@@ -833,26 +770,14 @@ int uv_interface_addresses(uv_interface_address_t** addresses_ptr,
   uv_interface_address_t* uv_address;
 
   int count;
-
-  int is_vista_or_greater;
   ULONG flags;
 
   *addresses_ptr = NULL;
   *count_ptr = 0;
 
-  is_vista_or_greater = is_windows_version_or_greater(6, 0, 0, 0);
-  if (is_vista_or_greater) {
-    flags = GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_MULTICAST |
-      GAA_FLAG_SKIP_DNS_SERVER;
-  } else {
-    /* We need at least XP SP1. */
-    if (!is_windows_version_or_greater(5, 1, 1, 0))
-      return UV_ENOTSUP;
-
-    flags = GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_MULTICAST |
-      GAA_FLAG_SKIP_DNS_SERVER | GAA_FLAG_INCLUDE_PREFIX;
-  }
-
+  flags = GAA_FLAG_SKIP_ANYCAST |
+          GAA_FLAG_SKIP_MULTICAST |
+          GAA_FLAG_SKIP_DNS_SERVER;
 
   /* Fetch the size of the adapters reported by windows, and then get the list
    * itself. */
@@ -1016,37 +941,8 @@ int uv_interface_addresses(uv_interface_address_t** addresses_ptr,
 
       sa = unicast_address->Address.lpSockaddr;
 
-      /* XP has no OnLinkPrefixLength field. */
-      if (is_vista_or_greater) {
-        prefix_len =
-          ((IP_ADAPTER_UNICAST_ADDRESS_LH*) unicast_address)->OnLinkPrefixLength;
-      } else {
-        /* Prior to Windows Vista the FirstPrefix pointed to the list with
-         * single prefix for each IP address assigned to the adapter.
-         * Order of FirstPrefix does not match order of FirstUnicastAddress,
-         * so we need to find corresponding prefix.
-         */
-        IP_ADAPTER_PREFIX* prefix;
-        prefix_len = 0;
-
-        for (prefix = adapter->FirstPrefix; prefix; prefix = prefix->Next) {
-          /* We want the longest matching prefix. */
-          if (prefix->Address.lpSockaddr->sa_family != sa->sa_family ||
-              prefix->PrefixLength <= prefix_len)
-            continue;
-
-          if (address_prefix_match(sa->sa_family, sa,
-              prefix->Address.lpSockaddr, prefix->PrefixLength)) {
-            prefix_len = prefix->PrefixLength;
-          }
-        }
-
-        /* If there is no matching prefix information, return a single-host
-         * subnet mask (e.g. 255.255.255.255 for IPv4).
-         */
-        if (!prefix_len)
-          prefix_len = (sa->sa_family == AF_INET6) ? 128 : 32;
-      }
+      prefix_len =
+        ((IP_ADAPTER_UNICAST_ADDRESS_LH*) unicast_address)->OnLinkPrefixLength;
 
       memset(uv_address, 0, sizeof *uv_address);
 
@@ -1265,8 +1161,10 @@ void uv_os_free_passwd(uv_passwd_t* pwd) {
 
   uv__free(pwd->username);
   uv__free(pwd->homedir);
+  uv__free(pwd->gecos);
   pwd->username = NULL;
   pwd->homedir = NULL;
+  pwd->gecos = NULL;
 }
 
 
@@ -1371,6 +1269,9 @@ int uv__getpwuid_r(uv_passwd_t* pwd) {
   wchar_t username[UNLEN + 1];
   wchar_t *path;
   DWORD bufsize;
+  wchar_t* gecosbuf;
+  ULONG gecos_size;
+  EXTENDED_NAME_FORMAT name_format;
   int r;
 
   if (pwd == NULL)
@@ -1416,19 +1317,61 @@ int uv__getpwuid_r(uv_passwd_t* pwd) {
     return uv_translate_sys_error(r);
   }
 
+  /* Set all of the pointers to NULL in case an error is encountered. */
   pwd->homedir = NULL;
+  pwd->username = NULL;
+  pwd->gecos = NULL;
+  gecosbuf = NULL;
+
+  /* Get the gecos using GetUserNameExW() */
+  gecos_size = 0;
+  /* Try using the display name first. */
+  GetUserNameExW(NameDisplay, NULL, &gecos_size);
+  if (GetLastError() == ERROR_MORE_DATA) {
+    name_format = NameDisplay;
+  } else {
+    /* NameDisplay not available, so try NameSamCompatible. */
+    GetUserNameExW(NameSamCompatible, NULL, &gecos_size);
+    if (GetLastError() == ERROR_MORE_DATA) {
+      name_format = NameSamCompatible;
+    } else {
+      /* Unsupported */
+      gecos_size = 0;
+    }
+  }
+
+  if (gecos_size > 0) {
+    gecosbuf = uv__malloc(sizeof(wchar_t) * gecos_size);
+    if (gecosbuf == NULL) {
+      r = UV_ENOMEM;
+      goto error;
+    }
+
+    if (GetUserNameExW(name_format, gecosbuf, &gecos_size) == 0) {
+      r = uv_translate_sys_error(GetLastError());
+      goto error;
+    }
+  }
+
+  /* Populate the uv_passwd_t structure. */
   r = uv__convert_utf16_to_utf8(path, -1, &pwd->homedir);
   uv__free(path);
 
   if (r != 0)
-    return r;
+    goto error;
 
-  pwd->username = NULL;
   r = uv__convert_utf16_to_utf8(username, -1, &pwd->username);
 
-  if (r != 0) {
-    uv__free(pwd->homedir);
-    return r;
+  if (r != 0)
+    goto error;
+
+  if (gecosbuf != NULL) {
+    r = uv__convert_utf16_to_utf8(gecosbuf, -1, &pwd->gecos);
+
+    if (r != 0)
+      goto error;
+
+    uv__free(gecosbuf);
   }
 
   pwd->shell = NULL;
@@ -1436,6 +1379,13 @@ int uv__getpwuid_r(uv_passwd_t* pwd) {
   pwd->gid = -1;
 
   return 0;
+
+error:
+  uv__free(gecosbuf);
+  uv__free(pwd->homedir);
+  uv__free(pwd->username);
+  uv__free(pwd->gecos);
+  return r;
 }
 
 
diff --git a/src/win/winapi.h b/src/win/winapi.h
index 0b66b563..8611d5f7 100644
--- a/src/win/winapi.h
+++ b/src/win/winapi.h
@@ -4125,40 +4125,35 @@ typedef const UNICODE_STRING *PCUNICODE_STRING;
 # define DEVICE_TYPE DWORD
 #endif
 
-/* MinGW already has a definition for REPARSE_DATA_BUFFER, but mingw-w64 does
- * not.
- */
-#if defined(_MSC_VER) || defined(__MINGW64_VERSION_MAJOR)
-  typedef struct _REPARSE_DATA_BUFFER {
-    ULONG  ReparseTag;
-    USHORT ReparseDataLength;
-    USHORT Reserved;
-    union {
-      struct {
-        USHORT SubstituteNameOffset;
-        USHORT SubstituteNameLength;
-        USHORT PrintNameOffset;
-        USHORT PrintNameLength;
-        ULONG Flags;
-        WCHAR PathBuffer[1];
-      } SymbolicLinkReparseBuffer;
-      struct {
-        USHORT SubstituteNameOffset;
-        USHORT SubstituteNameLength;
-        USHORT PrintNameOffset;
-        USHORT PrintNameLength;
-        WCHAR PathBuffer[1];
-      } MountPointReparseBuffer;
-      struct {
-        UCHAR  DataBuffer[1];
-      } GenericReparseBuffer;
-      struct {
-        ULONG StringCount;
-        WCHAR StringList[1];
-      } AppExecLinkReparseBuffer;
-    };
-  } REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;
-#endif
+typedef struct _REPARSE_DATA_BUFFER {
+  ULONG  ReparseTag;
+  USHORT ReparseDataLength;
+  USHORT Reserved;
+  union {
+    struct {
+      USHORT SubstituteNameOffset;
+      USHORT SubstituteNameLength;
+      USHORT PrintNameOffset;
+      USHORT PrintNameLength;
+      ULONG Flags;
+      WCHAR PathBuffer[1];
+    } SymbolicLinkReparseBuffer;
+    struct {
+      USHORT SubstituteNameOffset;
+      USHORT SubstituteNameLength;
+      USHORT PrintNameOffset;
+      USHORT PrintNameLength;
+      WCHAR PathBuffer[1];
+    } MountPointReparseBuffer;
+    struct {
+      UCHAR  DataBuffer[1];
+    } GenericReparseBuffer;
+    struct {
+      ULONG StringCount;
+      WCHAR StringList[1];
+    } AppExecLinkReparseBuffer;
+  };
+} REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;
 
 typedef struct _IO_STATUS_BLOCK {
   union {
@@ -4611,15 +4606,6 @@ typedef NTSTATUS (NTAPI *sNtQueryInformationProcess)
 # define SYMBOLIC_LINK_FLAG_DIRECTORY 0x1
 #endif
 
-#if defined(__MINGW32__) && !defined(__MINGW64_VERSION_MAJOR)
-  typedef struct _OVERLAPPED_ENTRY {
-      ULONG_PTR lpCompletionKey;
-      LPOVERLAPPED lpOverlapped;
-      ULONG_PTR Internal;
-      DWORD dwNumberOfBytesTransferred;
-  } OVERLAPPED_ENTRY, *LPOVERLAPPED_ENTRY;
-#endif
-
 /* from wincon.h */
 #ifndef ENABLE_INSERT_MODE
 # define ENABLE_INSERT_MODE 0x20
diff --git a/src/win/winsock.h b/src/win/winsock.h
index 2af95887..0bfeaf42 100644
--- a/src/win/winsock.h
+++ b/src/win/winsock.h
@@ -34,26 +34,10 @@
 /*
  * MinGW is missing these too
  */
-#ifndef SO_UPDATE_CONNECT_CONTEXT
-# define SO_UPDATE_CONNECT_CONTEXT 0x7010
-#endif
-
 #ifndef TCP_KEEPALIVE
 # define TCP_KEEPALIVE 3
 #endif
 
-#ifndef IPV6_V6ONLY
-# define IPV6_V6ONLY 27
-#endif
-
-#ifndef IPV6_HOPLIMIT
-# define IPV6_HOPLIMIT 21
-#endif
-
-#ifndef SIO_BASE_HANDLE
-# define SIO_BASE_HANDLE 0x48000022
-#endif
-
 #ifndef MCAST_JOIN_SOURCE_GROUP
 # define MCAST_JOIN_SOURCE_GROUP 45
 #endif
diff --git a/test/run-tests.c b/test/run-tests.c
index e5e75e17..bcfe7221 100644
--- a/test/run-tests.c
+++ b/test/run-tests.c
@@ -27,6 +27,13 @@
 # include <io.h>
 #else
 # include <unistd.h>
+# include <sched.h>
+#endif
+
+#if defined(__FreeBSD__)
+# include <sys/param.h>
+# include <sys/cpuset.h>
+# include <pthread_np.h>
 #endif
 
 #include "uv.h"
@@ -50,6 +57,10 @@ int spawn_tcp_server_helper(void);
 
 static int maybe_run_test(int argc, char **argv);
 
+#ifdef _WIN32
+typedef BOOL (WINAPI *sCompareObjectHandles)(_In_ HANDLE, _In_ HANDLE);
+#endif
+
 
 int main(int argc, char **argv) {
 #ifndef _WIN32
@@ -202,22 +213,36 @@ static int maybe_run_test(int argc, char **argv) {
     return 1;
   }
 
-#ifndef _WIN32
   if (strcmp(argv[1], "spawn_helper8") == 0) {
-    int fd;
-
+    uv_os_fd_t closed_fd;
+    uv_os_fd_t open_fd;
+#ifdef _WIN32
+    DWORD flags;
+    HMODULE kernelbase_module;
+    sCompareObjectHandles pCompareObjectHandles; /* function introduced in Windows 10 */
+#endif
     notify_parent_process();
-    ASSERT(sizeof(fd) == read(0, &fd, sizeof(fd)));
-    ASSERT(fd > 2);
+    ASSERT(sizeof(closed_fd) == read(0, &closed_fd, sizeof(closed_fd)));
+    ASSERT(sizeof(open_fd) == read(0, &open_fd, sizeof(open_fd)));
+#ifdef _WIN32
+    ASSERT((intptr_t) closed_fd > 0);
+    ASSERT((intptr_t) open_fd > 0);
+    ASSERT(0 != GetHandleInformation(open_fd, &flags));
+    kernelbase_module = GetModuleHandleA("kernelbase.dll");
+    pCompareObjectHandles = (sCompareObjectHandles)
+        GetProcAddress(kernelbase_module, "CompareObjectHandles");
+    ASSERT(!pCompareObjectHandles || !pCompareObjectHandles(open_fd, closed_fd));
+#else
+    ASSERT(open_fd > 2);
+    ASSERT(closed_fd > 2);
 # if defined(__PASE__)  /* On IBMi PASE, write() returns 1 */
-    ASSERT(1 == write(fd, "x", 1));
+    ASSERT(1 == write(closed_fd, "x", 1));
 # else
-    ASSERT(-1 == write(fd, "x", 1));
+    ASSERT(-1 == write(closed_fd, "x", 1));
 # endif  /* !__PASE__ */
-
+#endif
     return 1;
   }
-#endif  /* !_WIN32 */
 
   if (strcmp(argv[1], "spawn_helper9") == 0) {
     notify_parent_process();
@@ -238,6 +263,48 @@ static int maybe_run_test(int argc, char **argv) {
   }
 #endif  /* !_WIN32 */
 
+#if !defined(NO_CPU_AFFINITY)
+  if (strcmp(argv[1], "spawn_helper_affinity") == 0) {
+    int i;
+    int r;
+    int cpu;
+    int cpumask_size;
+#ifdef _WIN32
+    DWORD_PTR procmask;
+    DWORD_PTR sysmask;
+#elif defined(__linux__)
+    cpu_set_t cpuset;
+#else
+    cpuset_t cpuset;
+#endif
+
+    cpumask_size = uv_cpumask_size();
+    ASSERT(cpumask_size > 0);
+
+    cpu = atoi(argv[2]);
+    ASSERT(cpu >= 0);
+    ASSERT(cpu < cpumask_size);
+
+    /* verify the mask has the cpu we expect */
+#ifdef _WIN32
+    r = GetProcessAffinityMask(GetCurrentProcess(), &procmask, &sysmask);
+    ASSERT(r != 0);
+    for (i = 0; i < cpumask_size; ++i) {
+      ASSERT(((procmask & (((DWORD_PTR)1) << i)) != 0) == (i == cpu));
+    }
+#else
+    CPU_ZERO(&cpuset);
+    r = pthread_getaffinity_np(pthread_self(), sizeof(cpuset), &cpuset);
+    ASSERT(r == 0);
+    for (i = 0; i < cpumask_size; ++i) {
+      ASSERT(CPU_ISSET(i, &cpuset) == (i == cpu));
+    }
+#endif
+
+    return 1;
+  }
+#endif
+
   if (strcmp(argv[1], "process_title_big_argv_helper") == 0) {
     notify_parent_process();
     process_title_big_argv();
diff --git a/test/runner-win.c b/test/runner-win.c
index 8c2a00b8..975cc478 100644
--- a/test/runner-win.c
+++ b/test/runner-win.c
@@ -24,34 +24,23 @@
 #include <malloc.h>
 #include <stdio.h>
 #include <process.h>
-#if !defined(__MINGW32__)
-# include <crtdbg.h>
-#endif
+#include <crtdbg.h>
 
 
 #include "task.h"
 #include "runner.h"
 
 
-/*
- * Define the stuff that MinGW doesn't have
- */
-#ifndef GetFileSizeEx
-  WINBASEAPI BOOL WINAPI GetFileSizeEx(HANDLE hFile,
-                                       PLARGE_INTEGER lpFileSize);
-#endif
-
-
 /* Do platform-specific initialization. */
 void platform_init(int argc, char **argv) {
   /* Disable the "application crashed" popup. */
   SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX |
       SEM_NOOPENFILEERRORBOX);
-#if !defined(__MINGW32__)
   _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
   _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_DEBUG);
-#endif
 
+  /* make output mode sane */
+  _fmode = _O_BINARY;
   _setmode(0, _O_BINARY);
   _setmode(1, _O_BINARY);
   _setmode(2, _O_BINARY);
@@ -123,7 +112,7 @@ int process_start(char *name, char *part, process_info_t *p, int is_helper) {
     goto error;
 
   if (part) {
-    if (_snwprintf((WCHAR*)args,
+    if (swprintf((WCHAR*)args,
                    sizeof(args) / sizeof(WCHAR),
                    L"\"%s\" %S %S",
                    image,
@@ -132,7 +121,7 @@ int process_start(char *name, char *part, process_info_t *p, int is_helper) {
       goto error;
     }
   } else {
-    if (_snwprintf((WCHAR*)args,
+    if (swprintf((WCHAR*)args,
                    sizeof(args) / sizeof(WCHAR),
                    L"\"%s\" %S",
                    image,
diff --git a/test/runner-win.h b/test/runner-win.h
index 975eed79..d80e39a6 100644
--- a/test/runner-win.h
+++ b/test/runner-win.h
@@ -19,19 +19,16 @@
  * IN THE SOFTWARE.
  */
 
+
 /* Don't complain about write(), fileno() etc. being deprecated. */
 #ifdef _MSC_VER
 #pragma warning(disable : 4996)
 #endif
 
-
 #include <winsock2.h>
 #include <windows.h>
 #include <stdio.h>
 
-#if !defined(snprintf) && defined(_MSC_VER) && _MSC_VER < 1900
-extern int snprintf(char*, size_t, const char*, ...);
-#endif
 
 typedef struct {
   HANDLE process;
diff --git a/test/task.h b/test/task.h
index 8250f949..5f4d60fa 100644
--- a/test/task.h
+++ b/test/task.h
@@ -27,29 +27,15 @@
 #include <stdio.h>
 #include <stddef.h>
 #include <stdlib.h>
+#include <stdint.h>
 #include <string.h>
 #include <inttypes.h>
 
-#if defined(_MSC_VER) && _MSC_VER < 1600
-# include "uv/stdint-msvc2008.h"
-#else
-# include <stdint.h>
-#endif
-
 #if !defined(_WIN32)
 # include <sys/time.h>
 # include <sys/resource.h>  /* setrlimit() */
 #endif
 
-#ifdef __clang__
-# pragma clang diagnostic ignored "-Wvariadic-macros"
-# pragma clang diagnostic ignored "-Wc99-extensions"
-#endif
-
-#ifdef __GNUC__
-# pragma GCC diagnostic ignored "-Wvariadic-macros"
-#endif
-
 #define TEST_PORT 9123
 #define TEST_PORT_2 9124
 
@@ -64,7 +50,7 @@
 #endif
 
 #ifdef _WIN32
-# include <io.h>
+# include <sys/stat.h>
 # ifndef S_IRUSR
 #  define S_IRUSR _S_IREAD
 # endif
@@ -304,10 +290,6 @@ enum test_status {
 
 #endif
 
-#if !defined(snprintf) && defined(_MSC_VER) && _MSC_VER < 1900
-extern int snprintf(char*, size_t, const char*, ...);
-#endif
-
 #if defined(__clang__) ||                                \
     defined(__GNUC__) ||                                 \
     defined(__INTEL_COMPILER)
@@ -370,4 +352,11 @@ UNUSED static int can_ipv6(void) {
   "Cygwin runtime hangs on listen+connect in same process."
 #endif
 
+#if !defined(__linux__) && \
+    !defined(__FreeBSD__) && \
+    !defined(_WIN32)
+# define NO_CPU_AFFINITY \
+  "affinity not supported on this platform."
+#endif
+
 #endif /* TASK_H_ */
diff --git a/test/test-async-multi.c b/test/test-async-multi.c
new file mode 100644
index 00000000..316d2190
--- /dev/null
+++ b/test/test-async-multi.c
@@ -0,0 +1,86 @@
+/* Copyright libuv project contributors. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include "uv.h"
+#include "task.h"
+#include <stdio.h>
+#include <stdlib.h>
+
+static uv_pipe_t pipe_dummy;
+static uv_connect_t connect_req;
+static uv_prepare_t prepare;
+
+static int async_cb_called;
+static int close_cb_called;
+
+
+void close_cb(uv_handle_t* handle) {
+  close_cb_called++;
+}
+
+
+void connect_cb(uv_connect_t* req, int status) {
+  ASSERT(status == UV_ENOENT);
+  uv_close((uv_handle_t*) req->handle, close_cb);
+}
+
+
+void async_cb(uv_async_t* handle) {
+  async_cb_called++;
+  uv_close((uv_handle_t*) handle, close_cb);
+}
+
+
+void prepare_cb(uv_prepare_t* handle) {
+  uv_pipe_connect(&connect_req,
+                  &pipe_dummy,
+                  "nonexistent_file_path",
+                  connect_cb);
+  uv_close((uv_handle_t*) handle, close_cb);
+}
+
+
+TEST_IMPL(async_multi) {
+  uv_loop_t* loop;
+  uv_async_t async1;
+  uv_async_t async2;
+
+  loop = uv_default_loop();
+
+  ASSERT(0 == uv_async_init(loop, &async1, async_cb));
+  ASSERT(0 == uv_async_init(loop, &async2, async_cb));
+
+  /* Create a pending notification */
+  ASSERT(0 == uv_pipe_init(loop, &pipe_dummy, 0));
+  ASSERT(0 == uv_prepare_init(loop, &prepare));
+  ASSERT(0 == uv_prepare_start(&prepare, prepare_cb));
+
+  ASSERT(0 == uv_async_send(&async1));
+  ASSERT(0 == uv_async_send(&async2));
+
+  uv_run(loop, UV_RUN_DEFAULT);
+
+  ASSERT(async_cb_called == 2);
+  ASSERT(close_cb_called == 4);
+
+  MAKE_VALGRIND_HAPPY();
+  return 0;
+}
diff --git a/test/test-buf.c b/test/test-buf.c
new file mode 100644
index 00000000..7889df5c
--- /dev/null
+++ b/test/test-buf.c
@@ -0,0 +1,47 @@
+/* Copyright libuv contributors. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "uv.h"
+#include "task.h"
+
+#include <stdint.h>
+
+TEST_IMPL(buf_large) {
+  uv_buf_t buf;
+
+  buf = uv_buf_init(NULL, SIZE_MAX);
+  ASSERT(buf.len == SIZE_MAX);
+#ifdef _WIN32
+  WSABUF* wbuf;
+
+  wbuf = (WSABUF*) &buf;
+  ASSERT(wbuf->len == buf.len);
+#else
+  struct iovec* iobuf;
+
+  iobuf = (struct iovec*) &buf;
+  ASSERT(iobuf->iov_len == buf.len);
+
+  /* Verify that uv_buf_t is ABI-compatible with struct iovec. */
+  ASSERT(sizeof(uv_buf_t) == sizeof(struct iovec));
+  ASSERT(sizeof(&((uv_buf_t*) 0)->base) ==
+         sizeof(((struct iovec*) 0)->iov_base));
+  ASSERT(sizeof(&((uv_buf_t*) 0)->len) == sizeof(((struct iovec*) 0)->iov_len));
+  ASSERT(offsetof(uv_buf_t, base) == offsetof(struct iovec, iov_base));
+  ASSERT(offsetof(uv_buf_t, len) == offsetof(struct iovec, iov_len));
+#endif
+
+  return 0;
+}
diff --git a/test/test-close-fd.c b/test/test-close-fd.c
index cea4a1b0..e57cabf0 100644
--- a/test/test-close-fd.c
+++ b/test/test-close-fd.c
@@ -19,12 +19,11 @@
  * IN THE SOFTWARE.
  */
 
-#if !defined(_WIN32)
-
 #include "uv.h"
 #include "task.h"
-#include <fcntl.h>
+#ifndef _WIN32
 #include <unistd.h>
+#endif
 
 static unsigned int read_cb_called;
 
@@ -51,15 +50,31 @@ static void read_cb(uv_stream_t* handle, ssize_t nread, const uv_buf_t* buf) {
 
 TEST_IMPL(close_fd) {
   uv_pipe_t pipe_handle;
-  int fd[2];
+  uv_fs_t req;
+  uv_buf_t bufs[1];
+  uv_os_fd_t fd[2];
+  bufs[0] = uv_buf_init("", 1);
 
-  ASSERT(0 == pipe(fd));
+  ASSERT(0 == uv_pipe(fd, 0, 0));
   ASSERT(0 == uv_pipe_init(uv_default_loop(), &pipe_handle, 0));
   ASSERT(0 == uv_pipe_open(&pipe_handle, fd[0]));
-  fd[0] = -1;  /* uv_pipe_open() takes ownership of the file descriptor. */
-  ASSERT(1 == write(fd[1], "", 1));
+  /* uv_pipe_open() takes ownership of the file descriptor. */
+#ifdef _WIN32
+  fd[0] = INVALID_HANDLE_VALUE;
+#else
+  fd[0] = -1;
+#endif
+
+  ASSERT(1 == uv_fs_write(NULL, &req, fd[1], bufs, 1, -1, NULL));
+  ASSERT(1 == req.result);
+  uv_fs_req_cleanup(&req);
+#ifdef _WIN32
+  ASSERT(0 != CloseHandle(fd[1]));
+  fd[1] = INVALID_HANDLE_VALUE;
+#else
   ASSERT(0 == close(fd[1]));
   fd[1] = -1;
+#endif
   ASSERT(0 == uv_read_start((uv_stream_t *) &pipe_handle, alloc_cb, read_cb));
   ASSERT(0 == uv_run(uv_default_loop(), UV_RUN_DEFAULT));
   ASSERT(1 == read_cb_called);
@@ -72,9 +87,3 @@ TEST_IMPL(close_fd) {
   MAKE_VALGRIND_HAPPY();
   return 0;
 }
-
-#else
-
-typedef int file_has_no_tests; /* ISO C forbids an empty translation unit. */
-
-#endif /* !_WIN32 */
diff --git a/test/test-embed.c b/test/test-embed.c
index c6ddceb1..6f3cd113 100644
--- a/test/test-embed.c
+++ b/test/test-embed.c
@@ -42,7 +42,7 @@
 # endif
 #endif
 
-#if defined(HAVE_KQUEUE) || defined(HAVE_EPOLL)
+#if defined(HAVE_KQUEUE) || defined(HAVE_EPOLL) || defined(_WIN32)
 
 #if defined(HAVE_KQUEUE)
 # include <sys/types.h>
@@ -63,28 +63,59 @@ static volatile int embed_closed;
 static int embed_timer_called;
 
 
-static void embed_thread_runner(void* arg) {
+#if defined(_WIN32)
+static void embed_thread_poll_win(HANDLE iocp, int timeout) {
+  DWORD bytes;
+  ULONG_PTR key;
+  OVERLAPPED* overlapped;
+
+  GetQueuedCompletionStatus(iocp,
+                            &bytes,
+                            &key,
+                            &overlapped,
+                            timeout);
+
+  /* Give the event back so the loop can deal with it. */
+  if (overlapped != NULL)
+    PostQueuedCompletionStatus(iocp,
+                               bytes,
+                               key,
+                               overlapped);
+}
+#else
+static void embed_thread_poll_unix(int fd, int timeout) {
   int r;
-  int fd;
+  do {
+#if defined(HAVE_KQUEUE)
+    struct timespec ts;
+    ts.tv_sec = timeout / 1000;
+    ts.tv_nsec = (timeout % 1000) * 1000000;
+    r = kevent(fd, NULL, 0, NULL, 0, &ts);
+#elif defined(HAVE_EPOLL)
+    {
+      struct epoll_event ev;
+      r = epoll_wait(fd, &ev, 1, timeout);
+    }
+#endif
+  } while (r == -1 && errno == EINTR);
+}
+#endif /* !_WIN32 */
+
+
+static void embed_thread_runner(void* arg) {
+  uv_os_fd_t fd;
   int timeout;
 
   while (!embed_closed) {
     fd = uv_backend_fd(uv_default_loop());
     timeout = uv_backend_timeout(uv_default_loop());
 
-    do {
-#if defined(HAVE_KQUEUE)
-      struct timespec ts;
-      ts.tv_sec = timeout / 1000;
-      ts.tv_nsec = (timeout % 1000) * 1000000;
-      r = kevent(fd, NULL, 0, NULL, 0, &ts);
-#elif defined(HAVE_EPOLL)
-      {
-        struct epoll_event ev;
-        r = epoll_wait(fd, &ev, 1, timeout);
-      }
+#if defined(_WIN32)
+    embed_thread_poll_win(fd, timeout);
+#else
+    embed_thread_poll_unix(fd, timeout);
 #endif
-    } while (r == -1 && errno == EINTR);
+
     uv_async_send(&embed_async);
     uv_sem_wait(&embed_sem);
   }
@@ -108,7 +139,7 @@ static void embed_timer_cb(uv_timer_t* timer) {
 
 
 TEST_IMPL(embed) {
-#if defined(HAVE_KQUEUE) || defined(HAVE_EPOLL)
+#if defined(HAVE_KQUEUE) || defined(HAVE_EPOLL) || defined(_WIN32)
   uv_loop_t external;
 
   ASSERT(0 == uv_loop_init(&external));
@@ -133,7 +164,9 @@ TEST_IMPL(embed) {
   uv_loop_close(&external);
 
   ASSERT(embed_timer_called == 1);
-#endif
 
   return 0;
+#else
+  RETURN_SKIP("Not supported in the current platform.");
+#endif
 }
diff --git a/test/test-fork.c b/test/test-fork.c
index 9e4684f0..e95d83be 100644
--- a/test/test-fork.c
+++ b/test/test-fork.c
@@ -349,12 +349,12 @@ TEST_IMPL(fork_signal_to_child_closed) {
 
 static void create_file(const char* name) {
   int r;
-  uv_file file;
+  uv_os_fd_t file;
   uv_fs_t req;
 
   r = uv_fs_open(NULL, &req, name, O_WRONLY | O_CREAT, S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
-  file = r;
+  ASSERT(r == 0);
+  file = req.result;
   uv_fs_req_cleanup(&req);
   r = uv_fs_close(NULL, &req, file, NULL);
   ASSERT(r == 0);
@@ -364,13 +364,13 @@ static void create_file(const char* name) {
 
 static void touch_file(const char* name) {
   int r;
-  uv_file file;
+  uv_os_fd_t file;
   uv_fs_t req;
   uv_buf_t buf;
 
   r = uv_fs_open(NULL, &req, name, O_RDWR, 0, NULL);
-  ASSERT(r >= 0);
-  file = r;
+  ASSERT(r == 0);
+  file = req.result;
   uv_fs_req_cleanup(&req);
 
   buf = uv_buf_init("foo", 4);
diff --git a/test/test-fs-copyfile.c b/test/test-fs-copyfile.c
index e6f06e6e..f86fb92a 100644
--- a/test/test-fs-copyfile.c
+++ b/test/test-fs-copyfile.c
@@ -22,6 +22,8 @@
 #include "uv.h"
 #include "task.h"
 
+#include <fcntl.h>
+
 #if defined(__unix__) || defined(__POSIX__) || \
     defined(__APPLE__) || defined(__sun) || \
     defined(_AIX) || defined(__MVS__) || \
@@ -68,7 +70,7 @@ static void handle_result(uv_fs_t* req) {
 
 
 static void touch_file(const char* name, unsigned int size) {
-  uv_file file;
+  uv_os_fd_t file;
   uv_fs_t req;
   uv_buf_t buf;
   int r;
@@ -77,8 +79,8 @@ static void touch_file(const char* name, unsigned int size) {
   r = uv_fs_open(NULL, &req, name, O_WRONLY | O_CREAT | O_TRUNC,
                  S_IWUSR | S_IRUSR, NULL);
   uv_fs_req_cleanup(&req);
-  ASSERT(r >= 0);
-  file = r;
+  ASSERT(r == 0);
+  file = (uv_os_fd_t) req.result;
 
   buf = uv_buf_init("a", 1);
 
diff --git a/test/test-fs-event.c b/test/test-fs-event.c
index 28a6a1eb..cdad15f3 100644
--- a/test/test-fs-event.c
+++ b/test/test-fs-event.c
@@ -84,12 +84,12 @@ static void create_dir(const char* name) {
 
 static void create_file(const char* name) {
   int r;
-  uv_file file;
+  uv_os_fd_t file;
   uv_fs_t req;
 
   r = uv_fs_open(NULL, &req, name, O_WRONLY | O_CREAT, S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
-  file = r;
+  ASSERT(r == 0);
+  file = (uv_os_fd_t)req.result;
   uv_fs_req_cleanup(&req);
   r = uv_fs_close(NULL, &req, file, NULL);
   ASSERT(r == 0);
@@ -98,13 +98,13 @@ static void create_file(const char* name) {
 
 static void touch_file(const char* name) {
   int r;
-  uv_file file;
+  uv_os_fd_t file;
   uv_fs_t req;
   uv_buf_t buf;
 
   r = uv_fs_open(NULL, &req, name, O_RDWR, 0, NULL);
-  ASSERT(r >= 0);
-  file = r;
+  ASSERT(r == 0);
+  file = (uv_os_fd_t)req.result;
   uv_fs_req_cleanup(&req);
 
   buf = uv_buf_init("foo", 4);
diff --git a/test/test-fs-fd-hash.c b/test/test-fs-fd-hash.c
index 8b4bc035..6ebe5c91 100644
--- a/test/test-fs-fd-hash.c
+++ b/test/test-fs-fd-hash.c
@@ -34,31 +34,31 @@
 #define FD_DIFF 9
 
 
-void assert_nonexistent(int fd) {
+void assert_nonexistent(uv_os_fd_t fd) {
   struct uv__fd_info_s info = { 0 };
   ASSERT(!uv__fd_hash_get(fd, &info));
   ASSERT(!uv__fd_hash_remove(fd, &info));
 }
 
-void assert_existent(int fd) {
+void assert_existent(uv_os_fd_t fd) {
   struct uv__fd_info_s info = { 0 };
   ASSERT(uv__fd_hash_get(fd, &info));
-  ASSERT(info.flags == fd + FD_DIFF);
+  ASSERT(info.flags == (intptr_t) fd + FD_DIFF);
 }
 
-void assert_insertion(int fd) {
+void assert_insertion(uv_os_fd_t fd) {
   struct uv__fd_info_s info = { 0 };
   assert_nonexistent(fd);
-  info.flags = fd + FD_DIFF;
+  info.flags = (intptr_t) fd + FD_DIFF;
   uv__fd_hash_add(fd, &info);
   assert_existent(fd);
 }
 
-void assert_removal(int fd) {
+void assert_removal(uv_os_fd_t fd) {
   struct uv__fd_info_s info = { 0 };
   assert_existent(fd);
   uv__fd_hash_remove(fd, &info);
-  ASSERT(info.flags == fd + FD_DIFF);
+  ASSERT(info.flags == (intptr_t) fd + FD_DIFF);
   assert_nonexistent(fd);
 }
 
@@ -67,7 +67,7 @@ void assert_removal(int fd) {
 #define RUN_HASH(function)                                                   \
   do {                                                                       \
     for (fd = 0; fd < HASH_MAX; fd += HASH_INC) {                            \
-      function(fd);                                                          \
+      function((uv_os_fd_t) fd);                                             \
     }                                                                        \
   } while (0)
 
@@ -75,13 +75,13 @@ void assert_removal(int fd) {
 #define RUN_COLLISIONS(function)                                             \
   do {                                                                       \
     for (fd = 1; fd < BUCKET_MAX; fd += BUCKET_INC) {                        \
-      function(fd);                                                          \
+      function((uv_os_fd_t) fd);                                             \
     }                                                                        \
   } while (0)
 
 
 TEST_IMPL(fs_fd_hash) {
-  int fd;
+  uintptr_t fd;
 
   uv__fd_hash_init();
 
@@ -105,7 +105,7 @@ TEST_IMPL(fs_fd_hash) {
   }
   {
     struct uv__fd_info_s info = { 0 };
-    ASSERT(uv__fd_hash_get(0, &info));
+    ASSERT(uv__fd_hash_get((uv_os_fd_t) 0, &info));
     ASSERT(info.flags == FD_DIFF + FD_DIFF);
   }
   {
diff --git a/test/test-fs-open-flags.c b/test/test-fs-open-flags.c
index 5f61007a..6512a8c2 100644
--- a/test/test-fs-open-flags.c
+++ b/test/test-fs-open-flags.c
@@ -58,6 +58,7 @@ static char empty_file[FILE_NAME_SIZE];
 static char dummy_file[FILE_NAME_SIZE];
 static char empty_dir[] = "empty_dir";
 
+
 static void setup(void) {
   int r;
 
@@ -73,8 +74,10 @@ static void setup(void) {
   uv_fs_req_cleanup(&mkdir_req);
 }
 
+
 static void refresh(void) {
   int r;
+  uv_os_fd_t file;
 
   /* absent_file */
   sprintf(absent_file, "test_file_%d", sid++);
@@ -89,11 +92,12 @@ static void refresh(void) {
 
   r = uv_fs_open(NULL, &open_req, empty_file,
     UV_FS_O_TRUNC | UV_FS_O_CREAT | UV_FS_O_WRONLY, S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req.result >= 0);
+  file = (uv_os_fd_t) open_req.result;
   uv_fs_req_cleanup(&open_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
@@ -103,28 +107,31 @@ static void refresh(void) {
 
   r = uv_fs_open(NULL, &open_req, dummy_file,
     UV_FS_O_TRUNC | UV_FS_O_CREAT | UV_FS_O_WRONLY, S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req.result >= 0);
+  file = (uv_os_fd_t) open_req.result;
   uv_fs_req_cleanup(&open_req);
 
   iov = uv_buf_init("a", 1);
-  r = uv_fs_write(NULL, &write_req, open_req.result, &iov, 1, -1, NULL);
+  r = uv_fs_write(NULL, &write_req, file, &iov, 1, -1, NULL);
   ASSERT(r == 1);
   ASSERT(write_req.result == 1);
   uv_fs_req_cleanup(&write_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
 }
 
+
 static void cleanup(void) {
   unlink(absent_file);
   unlink(empty_file);
   unlink(dummy_file);
 }
 
+
 static void openFail(char *file, int error) {
   int r;
 
@@ -144,6 +151,7 @@ static void openFail(char *file, int error) {
   cleanup();
 }
 
+
 static void refreshOpen(char *file) {
   int r;
 
@@ -155,42 +163,46 @@ static void refreshOpen(char *file) {
   uv_fs_req_cleanup(&open_req);
 }
 
+
 static void writeExpect(char *file, char *expected, int size) {
   int r;
+  uv_os_fd_t fd;
 
   refreshOpen(file);
+  fd = (uv_os_fd_t) open_req.result;
 
   iov = uv_buf_init("b", 1);
-  r = uv_fs_write(NULL, &write_req, open_req.result, &iov, 1, -1, NULL);
+  r = uv_fs_write(NULL, &write_req, fd, &iov, 1, -1, NULL);
   ASSERT(r == 1);
   ASSERT(write_req.result == 1);
   uv_fs_req_cleanup(&write_req);
 
   iov = uv_buf_init("c", 1);
-  r = uv_fs_write(NULL, &write_req, open_req.result, &iov, 1, -1, NULL);
+  r = uv_fs_write(NULL, &write_req, fd, &iov, 1, -1, NULL);
   ASSERT(r == 1);
   ASSERT(write_req.result == 1);
   uv_fs_req_cleanup(&write_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req.result, NULL);
+  r = uv_fs_close(NULL, &close_req, fd, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
 
   /* Check contents */
   r = uv_fs_open(NULL, &open_req, file, UV_FS_O_RDONLY, S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req.result >= 0);
+  fd = (uv_os_fd_t) open_req.result;
   uv_fs_req_cleanup(&open_req);
 
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(NULL, &read_req, open_req.result, &iov, 1, -1, NULL);
+  r = uv_fs_read(NULL, &read_req, fd, &iov, 1, -1, NULL);
   ASSERT(r == size);
   ASSERT(read_req.result == size);
   ASSERT(strncmp(buf, expected, size) == 0);
   uv_fs_req_cleanup(&read_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req.result, NULL);
+  r = uv_fs_close(NULL, &close_req, fd, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
@@ -198,24 +210,27 @@ static void writeExpect(char *file, char *expected, int size) {
   cleanup();
 }
 
+
 static void writeFail(char *file, int error) {
   int r;
+  uv_os_fd_t fd;
 
   refreshOpen(file);
+  fd = (uv_os_fd_t) open_req.result;
 
   iov = uv_buf_init("z", 1);
-  r = uv_fs_write(NULL, &write_req, open_req.result, &iov, 1, -1, NULL);
+  r = uv_fs_write(NULL, &write_req, fd, &iov, 1, -1, NULL);
   ASSERT(r == error);
   ASSERT(write_req.result == error);
   uv_fs_req_cleanup(&write_req);
 
   iov = uv_buf_init("z", 1);
-  r = uv_fs_write(NULL, &write_req, open_req.result, &iov, 1, -1, NULL);
+  r = uv_fs_write(NULL, &write_req, fd, &iov, 1, -1, NULL);
   ASSERT(r == error);
   ASSERT(write_req.result == error);
   uv_fs_req_cleanup(&write_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req.result, NULL);
+  r = uv_fs_close(NULL, &close_req, fd, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
@@ -223,19 +238,22 @@ static void writeFail(char *file, int error) {
   cleanup();
 }
 
+
 static void readExpect(char *file, char *expected, int size) {
   int r;
+  uv_os_fd_t fd;
 
   refreshOpen(file);
+  fd = (uv_os_fd_t) open_req.result;
 
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(NULL, &read_req, open_req.result, &iov, 1, -1, NULL);
+  r = uv_fs_read(NULL, &read_req, fd, &iov, 1, -1, NULL);
   ASSERT(r == size);
   ASSERT(read_req.result == size);
   ASSERT(strncmp(buf, expected, size) == 0);
   uv_fs_req_cleanup(&read_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req.result, NULL);
+  r = uv_fs_close(NULL, &close_req, fd, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
@@ -243,24 +261,27 @@ static void readExpect(char *file, char *expected, int size) {
   cleanup();
 }
 
+
 static void readFail(char *file, int error) {
   int r;
+  uv_os_fd_t fd;
 
   refreshOpen(file);
+  fd = (uv_os_fd_t) open_req.result;
 
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(NULL, &read_req, open_req.result, &iov, 1, -1, NULL);
+  r = uv_fs_read(NULL, &read_req, fd, &iov, 1, -1, NULL);
   ASSERT(r == error);
   ASSERT(read_req.result == error);
   uv_fs_req_cleanup(&read_req);
 
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(NULL, &read_req, open_req.result, &iov, 1, -1, NULL);
+  r = uv_fs_read(NULL, &read_req, fd, &iov, 1, -1, NULL);
   ASSERT(r == error);
   ASSERT(read_req.result == error);
   uv_fs_req_cleanup(&read_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req.result, NULL);
+  r = uv_fs_close(NULL, &close_req, fd, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
@@ -268,6 +289,7 @@ static void readFail(char *file, int error) {
   cleanup();
 }
 
+
 static void fs_open_flags(int add_flags) {
   /* Follow the order from
    * https://github.com/nodejs/node/blob/1a96abe849/lib/internal/fs/utils.js#L329-L354
@@ -276,21 +298,21 @@ static void fs_open_flags(int add_flags) {
   /* r */
   flags = add_flags | UV_FS_O_RDONLY;
   openFail(absent_file, UV_ENOENT);
-  writeFail(empty_file, UV_EPERM);
+  writeFail(empty_file, UV_EACCES);
   readExpect(empty_file, "", 0);
-  writeFail(dummy_file, UV_EPERM);
+  writeFail(dummy_file, UV_EACCES);
   readExpect(dummy_file, "a", 1);
-  writeFail(empty_dir, UV_EPERM);
+  writeFail(empty_dir, UV_EACCES);
   readFail(empty_dir, UV_EISDIR);
 
   /* rs */
   flags = add_flags | UV_FS_O_RDONLY | UV_FS_O_SYNC;
   openFail(absent_file, UV_ENOENT);
-  writeFail(empty_file, UV_EPERM);
+  writeFail(empty_file, UV_EACCES);
   readExpect(empty_file, "", 0);
-  writeFail(dummy_file, UV_EPERM);
+  writeFail(dummy_file, UV_EACCES);
   readExpect(dummy_file, "a", 1);
-  writeFail(empty_dir, UV_EPERM);
+  writeFail(empty_dir, UV_EACCES);
   readFail(empty_dir, UV_EISDIR);
 
   /* r+ */
@@ -316,18 +338,18 @@ static void fs_open_flags(int add_flags) {
   /* w */
   flags = add_flags | UV_FS_O_TRUNC | UV_FS_O_CREAT | UV_FS_O_WRONLY;
   writeExpect(absent_file, "bc", 2);
-  readFail(absent_file, UV_EPERM);
+  readFail(absent_file, UV_EACCES);
   writeExpect(empty_file, "bc", 2);
-  readFail(empty_file, UV_EPERM);
+  readFail(empty_file, UV_EACCES);
   writeExpect(dummy_file, "bc", 2);
-  readFail(dummy_file, UV_EPERM);
+  readFail(dummy_file, UV_EACCES);
   openFail(empty_dir, UV_EISDIR);
 
   /* wx */
   flags = add_flags | UV_FS_O_TRUNC | UV_FS_O_CREAT | UV_FS_O_WRONLY |
     UV_FS_O_EXCL;
   writeExpect(absent_file, "bc", 2);
-  readFail(absent_file, UV_EPERM);
+  readFail(absent_file, UV_EACCES);
   openFail(empty_file, UV_EEXIST);
   openFail(dummy_file, UV_EEXIST);
   openFail(empty_dir, UV_EEXIST);
@@ -354,19 +376,19 @@ static void fs_open_flags(int add_flags) {
   /* a */
   flags = add_flags | UV_FS_O_APPEND | UV_FS_O_CREAT | UV_FS_O_WRONLY;
   writeExpect(absent_file, "bc", 2);
-  readFail(absent_file, UV_EPERM);
+  readFail(absent_file, UV_EACCES);
   writeExpect(empty_file, "bc", 2);
-  readFail(empty_file, UV_EPERM);
+  readFail(empty_file, UV_EACCES);
   writeExpect(dummy_file, "abc", 3);
-  readFail(dummy_file, UV_EPERM);
+  readFail(dummy_file, UV_EACCES);
   writeFail(empty_dir, UV_EISDIR);
-  readFail(empty_dir, UV_EPERM);
+  readFail(empty_dir, UV_EACCES);
 
   /* ax */
   flags = add_flags | UV_FS_O_APPEND | UV_FS_O_CREAT | UV_FS_O_WRONLY |
     UV_FS_O_EXCL;
   writeExpect(absent_file, "bc", 2);
-  readFail(absent_file, UV_EPERM);
+  readFail(absent_file, UV_EACCES);
   openFail(empty_file, UV_EEXIST);
   openFail(dummy_file, UV_EEXIST);
   openFail(empty_dir, UV_EEXIST);
@@ -375,13 +397,13 @@ static void fs_open_flags(int add_flags) {
   flags = add_flags | UV_FS_O_APPEND | UV_FS_O_CREAT | UV_FS_O_WRONLY |
     UV_FS_O_SYNC;
   writeExpect(absent_file, "bc", 2);
-  readFail(absent_file, UV_EPERM);
+  readFail(absent_file, UV_EACCES);
   writeExpect(empty_file, "bc", 2);
-  readFail(empty_file, UV_EPERM);
+  readFail(empty_file, UV_EACCES);
   writeExpect(dummy_file, "abc", 3);
-  readFail(dummy_file, UV_EPERM);
+  readFail(dummy_file, UV_EACCES);
   writeFail(empty_dir, UV_EISDIR);
-  readFail(empty_dir, UV_EPERM);
+  readFail(empty_dir, UV_EACCES);
 
   /* a+ */
   flags = add_flags | UV_FS_O_APPEND | UV_FS_O_CREAT | UV_FS_O_RDWR;
@@ -415,6 +437,8 @@ static void fs_open_flags(int add_flags) {
   writeFail(empty_dir, UV_EISDIR);
   readFail(empty_dir, UV_EISDIR);
 }
+
+
 TEST_IMPL(fs_open_flags) {
   setup();
 
diff --git a/test/test-fs-readdir.c b/test/test-fs-readdir.c
index 5efc853c..0bf8846b 100644
--- a/test/test-fs-readdir.c
+++ b/test/test-fs-readdir.c
@@ -348,6 +348,7 @@ TEST_IMPL(fs_readdir_non_empty_dir) {
   uv_fs_t create_req;
   uv_fs_t close_req;
   uv_dir_t* dir;
+  uv_os_fd_t file;
   int r;
 
   cleanup_test_files();
@@ -361,12 +362,11 @@ TEST_IMPL(fs_readdir_non_empty_dir) {
                  "test_dir/file1",
                  O_WRONLY | O_CREAT, S_IWUSR | S_IRUSR,
                  NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
+  ASSERT(create_req.result >= 0);
+  file = (uv_os_fd_t) create_req.result;
   uv_fs_req_cleanup(&create_req);
-  r = uv_fs_close(uv_default_loop(),
-                  &close_req,
-                  create_req.result,
-                  NULL);
+  r = uv_fs_close(uv_default_loop(), &close_req, file, NULL);
   ASSERT(r == 0);
   uv_fs_req_cleanup(&close_req);
 
@@ -375,12 +375,11 @@ TEST_IMPL(fs_readdir_non_empty_dir) {
                  "test_dir/file2",
                  O_WRONLY | O_CREAT, S_IWUSR | S_IRUSR,
                  NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
+  ASSERT(create_req.result >= 0);
+  file = (uv_os_fd_t) create_req.result;
   uv_fs_req_cleanup(&create_req);
-  r = uv_fs_close(uv_default_loop(),
-                  &close_req,
-                  create_req.result,
-                  NULL);
+  r = uv_fs_close(uv_default_loop(), &close_req, file, NULL);
   ASSERT(r == 0);
   uv_fs_req_cleanup(&close_req);
 
diff --git a/test/test-fs.c b/test/test-fs.c
index 63189d01..8e86c5f3 100644
--- a/test/test-fs.c
+++ b/test/test-fs.c
@@ -23,8 +23,9 @@
 #include "task.h"
 
 #include <errno.h>
-#include <string.h> /* memset */
 #include <fcntl.h>
+#include <math.h>
+#include <string.h> /* memset */
 #include <sys/stat.h>
 #include <limits.h> /* INT_MAX, PATH_MAX, IOV_MAX */
 
@@ -55,6 +56,7 @@
 
 typedef struct {
   const char* path;
+  double btime;
   double atime;
   double mtime;
 } utime_check_t;
@@ -129,7 +131,19 @@ static uv_buf_t iov;
 int uv_test_getiovmax(void) {
   return INT32_MAX; /* Emulated by libuv, so no real limit. */
 }
+
+
+uint64_t uv_test_lseek(HANDLE fd, uint64_t offset, int whence) {
+  LARGE_INTEGER offset_;
+  LARGE_INTEGER tell;
+  offset_.QuadPart = offset;
+  if (SetFilePointerEx(fd, offset_, &tell, whence))
+    return tell.QuadPart;
+  return -1;
+}
+
 #else
+
 int uv_test_getiovmax(void) {
 #if defined(IOV_MAX)
   return IOV_MAX;
@@ -148,6 +162,11 @@ int uv_test_getiovmax(void) {
   return 1024;
 #endif
 }
+
+
+off_t uv_test_lseek(int fd, off_t offset, int whence) {
+  return lseek(fd, offset, whence);
+}
 #endif
 
 #ifdef _WIN32
@@ -219,16 +238,6 @@ static void realpath_cb(uv_fs_t* req) {
   char test_file_abs_buf[PATHMAX];
   size_t test_file_abs_size = sizeof(test_file_abs_buf);
   ASSERT(req->fs_type == UV_FS_REALPATH);
-#ifdef _WIN32
-  /*
-   * Windows XP and Server 2003 don't support GetFinalPathNameByHandleW()
-   */
-  if (req->result == UV_ENOSYS) {
-    realpath_cb_count++;
-    uv_fs_req_cleanup(req);
-    return;
-  }
-#endif
   ASSERT(req->result == 0);
 
   uv_cwd(test_file_abs_buf, &test_file_abs_size);
@@ -387,12 +396,13 @@ static void close_cb(uv_fs_t* req) {
 
 static void ftruncate_cb(uv_fs_t* req) {
   int r;
+  uv_os_fd_t file = (uv_os_fd_t) open_req1.result;
   ASSERT(req == &ftruncate_req);
   ASSERT(req->fs_type == UV_FS_FTRUNCATE);
   ASSERT(req->result == 0);
   ftruncate_cb_count++;
   uv_fs_req_cleanup(req);
-  r = uv_fs_close(loop, &close_req, open_req1.result, close_cb);
+  r = uv_fs_close(loop, &close_req, file, close_cb);
   ASSERT(r == 0);
 }
 
@@ -402,6 +412,7 @@ static void fail_cb(uv_fs_t* req) {
 
 static void read_cb(uv_fs_t* req) {
   int r;
+  uv_os_fd_t file = (uv_os_fd_t) open_req1.result;
   ASSERT(req == &read_req);
   ASSERT(req->fs_type == UV_FS_READ);
   ASSERT(req->result >= 0);  /* FIXME(bnoordhuis) Check if requested size? */
@@ -409,11 +420,11 @@ static void read_cb(uv_fs_t* req) {
   uv_fs_req_cleanup(req);
   if (read_cb_count == 1) {
     ASSERT(strcmp(buf, test_buf) == 0);
-    r = uv_fs_ftruncate(loop, &ftruncate_req, open_req1.result, 7,
+    r = uv_fs_ftruncate(loop, &ftruncate_req, file, 7,
         ftruncate_cb);
   } else {
     ASSERT(strcmp(buf, "test-bu") == 0);
-    r = uv_fs_close(loop, &close_req, open_req1.result, close_cb);
+    r = uv_fs_close(loop, &close_req, file, close_cb);
   }
   ASSERT(r == 0);
 }
@@ -421,6 +432,7 @@ static void read_cb(uv_fs_t* req) {
 
 static void open_cb(uv_fs_t* req) {
   int r;
+  uv_os_fd_t file = (uv_os_fd_t) open_req1.result;
   ASSERT(req == &open_req1);
   ASSERT(req->fs_type == UV_FS_OPEN);
   if (req->result < 0) {
@@ -433,7 +445,7 @@ static void open_cb(uv_fs_t* req) {
   uv_fs_req_cleanup(req);
   memset(buf, 0, sizeof(buf));
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(loop, &read_req, open_req1.result, &iov, 1, -1,
+  r = uv_fs_read(loop, &read_req, file, &iov, 1, -1,
       read_cb);
   ASSERT(r == 0);
 }
@@ -453,49 +465,53 @@ static void open_cb_simple(uv_fs_t* req) {
 
 static void fsync_cb(uv_fs_t* req) {
   int r;
+  uv_os_fd_t file = (uv_os_fd_t) open_req1.result;
   ASSERT(req == &fsync_req);
   ASSERT(req->fs_type == UV_FS_FSYNC);
   ASSERT(req->result == 0);
   fsync_cb_count++;
   uv_fs_req_cleanup(req);
-  r = uv_fs_close(loop, &close_req, open_req1.result, close_cb);
+  r = uv_fs_close(loop, &close_req, file, close_cb);
   ASSERT(r == 0);
 }
 
 
 static void fdatasync_cb(uv_fs_t* req) {
   int r;
+  uv_os_fd_t file = (uv_os_fd_t) open_req1.result;
   ASSERT(req == &fdatasync_req);
   ASSERT(req->fs_type == UV_FS_FDATASYNC);
   ASSERT(req->result == 0);
   fdatasync_cb_count++;
   uv_fs_req_cleanup(req);
-  r = uv_fs_fsync(loop, &fsync_req, open_req1.result, fsync_cb);
+  r = uv_fs_fsync(loop, &fsync_req, file, fsync_cb);
   ASSERT(r == 0);
 }
 
 
 static void write_cb(uv_fs_t* req) {
   int r;
+  uv_os_fd_t file = (uv_os_fd_t) open_req1.result;
   ASSERT(req == &write_req);
   ASSERT(req->fs_type == UV_FS_WRITE);
   ASSERT(req->result >= 0);  /* FIXME(bnoordhuis) Check if requested size? */
   write_cb_count++;
   uv_fs_req_cleanup(req);
-  r = uv_fs_fdatasync(loop, &fdatasync_req, open_req1.result, fdatasync_cb);
+  r = uv_fs_fdatasync(loop, &fdatasync_req, file, fdatasync_cb);
   ASSERT(r == 0);
 }
 
 
 static void create_cb(uv_fs_t* req) {
   int r;
+  uv_os_fd_t file = (uv_os_fd_t) open_req1.result;
   ASSERT(req == &open_req1);
   ASSERT(req->fs_type == UV_FS_OPEN);
   ASSERT(req->result >= 0);
   create_cb_count++;
   uv_fs_req_cleanup(req);
   iov = uv_buf_init(test_buf, sizeof(test_buf));
-  r = uv_fs_write(loop, &write_req, req->result, &iov, 1, -1, write_cb);
+  r = uv_fs_write(loop, &write_req, file, &iov, 1, -1, write_cb);
   ASSERT(r == 0);
 }
 
@@ -770,11 +786,10 @@ TEST_IMPL(fs_file_loop) {
   r = uv_fs_symlink(NULL, &req, "test_symlink", "test_symlink", 0, NULL);
 #ifdef _WIN32
   /*
-   * Windows XP and Server 2003 don't support symlinks; we'll get UV_ENOTSUP.
-   * Starting with vista they are supported, but only when elevated, otherwise
-   * we'll see UV_EPERM.
+   * Starting with Windows Vista symlinks are supported, but only when
+   * elevated, otherwise we'll see UV_EPERM.
    */
-  if (r == UV_ENOTSUP || r == UV_EPERM)
+  if (r == UV_EPERM)
     return 0;
 #elif defined(__MSYS__)
   /* MSYS2's approximation of symlinks with copies does not work for broken
@@ -803,10 +818,12 @@ TEST_IMPL(fs_file_loop) {
   return 0;
 }
 
-static void check_utime(const char* path,
-                        double atime,
-                        double mtime,
-                        int test_lutime) {
+
+static void check_utime_ex(const char* path,
+                           double btime,
+                           double atime,
+                           double mtime,
+                           int test_lutime) {
   uv_stat_t* s;
   uv_fs_t req;
   int r;
@@ -817,10 +834,25 @@ static void check_utime(const char* path,
     r = uv_fs_stat(loop, &req, path, NULL);
 
   ASSERT(r == 0);
-
   ASSERT(req.result == 0);
   s = &req.statbuf;
 
+#if defined(__APPLE__) || defined(_WIN32)
+  /* When check_utime_ex is called with a btime of NAN, this means that we are
+   * checking uv_fs_utime and uv_fs_futime results, which SHOULD NOT allow the
+   * caller to alter the btime.  Well some utime implementations, like FreeBSD,
+   * have conditions where btime can be altered via utime even though btime is
+   * not an argument.  The conditions to identify this are impossible to check
+   * at test time so we will not check that btime is unaltered when checking
+   * the results of uv_fs_utime and uv_fs_futime.
+   */
+  if (!isnan(btime)) {
+    /* Make sure the birth/creation time was altered as expected. */
+    ASSERT(s->st_birthtim.tv_sec + (s->st_birthtim.tv_nsec / 1000000000.0) ==
+      btime);
+  }
+#endif
+
   ASSERT(s->st_atim.tv_sec + (s->st_atim.tv_nsec / 1000000000.0) == atime);
   ASSERT(s->st_mtim.tv_sec + (s->st_mtim.tv_nsec / 1000000000.0) == mtime);
 
@@ -828,6 +860,11 @@ static void check_utime(const char* path,
 }
 
 
+static void check_utime(const char* path, double atime, double mtime, int test_lutime) {
+  check_utime_ex(path, NAN, atime, mtime, test_lutime);
+}
+
+
 static void utime_cb(uv_fs_t* req) {
   utime_check_t* c;
 
@@ -937,6 +974,7 @@ TEST_IMPL(fs_file_async) {
 
 static void fs_file_sync(int add_flags) {
   int r;
+  uv_os_fd_t file;
 
   /* Setup. */
   unlink("test_file");
@@ -946,39 +984,41 @@ static void fs_file_sync(int add_flags) {
 
   r = uv_fs_open(loop, &open_req1, "test_file",
       O_WRONLY | O_CREAT | add_flags, S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
   iov = uv_buf_init(test_buf, sizeof(test_buf));
-  r = uv_fs_write(NULL, &write_req, open_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_write(NULL, &write_req, file, &iov, 1, -1, NULL);
   ASSERT(r >= 0);
   ASSERT(write_req.result >= 0);
   uv_fs_req_cleanup(&write_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
 
   r = uv_fs_open(NULL, &open_req1, "test_file", O_RDWR | add_flags, 0, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(NULL, &read_req, open_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_read(NULL, &read_req, file, &iov, 1, -1, NULL);
   ASSERT(r >= 0);
   ASSERT(read_req.result >= 0);
   ASSERT(strcmp(buf, test_buf) == 0);
   uv_fs_req_cleanup(&read_req);
 
-  r = uv_fs_ftruncate(NULL, &ftruncate_req, open_req1.result, 7, NULL);
+  r = uv_fs_ftruncate(NULL, &ftruncate_req, file, 7, NULL);
   ASSERT(r == 0);
   ASSERT(ftruncate_req.result == 0);
   uv_fs_req_cleanup(&ftruncate_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
@@ -990,19 +1030,20 @@ static void fs_file_sync(int add_flags) {
 
   r = uv_fs_open(NULL, &open_req1, "test_file2", O_RDONLY | add_flags, 0,
       NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
   memset(buf, 0, sizeof(buf));
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(NULL, &read_req, open_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_read(NULL, &read_req, file, &iov, 1, -1, NULL);
   ASSERT(r >= 0);
   ASSERT(read_req.result >= 0);
   ASSERT(strcmp(buf, "test-bu") == 0);
   uv_fs_req_cleanup(&read_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
@@ -1027,6 +1068,7 @@ TEST_IMPL(fs_file_sync) {
 
 static void fs_file_write_null_buffer(int add_flags) {
   int r;
+  uv_os_fd_t file;
 
   /* Setup. */
   unlink("test_file");
@@ -1035,17 +1077,18 @@ static void fs_file_write_null_buffer(int add_flags) {
 
   r = uv_fs_open(NULL, &open_req1, "test_file",
       O_WRONLY | O_CREAT | add_flags, S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
   iov = uv_buf_init(NULL, 0);
-  r = uv_fs_write(NULL, &write_req, open_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_write(NULL, &write_req, file, &iov, 1, -1, NULL);
   ASSERT(r == 0);
   ASSERT(write_req.result == 0);
   uv_fs_req_cleanup(&write_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
@@ -1064,6 +1107,7 @@ TEST_IMPL(fs_file_write_null_buffer) {
 TEST_IMPL(fs_async_dir) {
   int r;
   uv_dirent_t dent;
+  uv_os_fd_t file;
 
   /* Setup */
   unlink("test_dir/file1");
@@ -1081,17 +1125,19 @@ TEST_IMPL(fs_async_dir) {
   /* Create 2 files synchronously. */
   r = uv_fs_open(NULL, &open_req1, "test_dir/file1", O_WRONLY | O_CREAT,
       S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   uv_fs_req_cleanup(&close_req);
 
   r = uv_fs_open(NULL, &open_req1, "test_dir/file2", O_WRONLY | O_CREAT,
       S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   uv_fs_req_cleanup(&close_req);
 
@@ -1159,6 +1205,7 @@ TEST_IMPL(fs_async_dir) {
 static int test_sendfile(void (*setup)(int), uv_fs_cb cb, off_t expected_size) {
   int f, r;
   struct stat s1, s2;
+  uv_os_fd_t file1, file2;
 
   loop = uv_default_loop();
 
@@ -1177,27 +1224,29 @@ static int test_sendfile(void (*setup)(int), uv_fs_cb cb, off_t expected_size) {
 
   /* Test starts here. */
   r = uv_fs_open(NULL, &open_req1, "test_file", O_RDWR, 0, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req1.result >= 0);
+  file1 = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
   r = uv_fs_open(NULL, &open_req2, "test_file2", O_WRONLY | O_CREAT,
       S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req2.result >= 0);
+  file2 = (uv_os_fd_t) open_req2.result;
   uv_fs_req_cleanup(&open_req2);
 
-  r = uv_fs_sendfile(loop, &sendfile_req, open_req2.result, open_req1.result,
+  r = uv_fs_sendfile(loop, &sendfile_req, file2, file1,
       0, 131072, cb);
   ASSERT(r == 0);
   uv_run(loop, UV_RUN_DEFAULT);
 
   ASSERT(sendfile_cb_count == 1);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file1, NULL);
   ASSERT(r == 0);
   uv_fs_req_cleanup(&close_req);
-  r = uv_fs_close(NULL, &close_req, open_req2.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file2, NULL);
   ASSERT(r == 0);
   uv_fs_req_cleanup(&close_req);
 
@@ -1265,7 +1314,7 @@ TEST_IMPL(fs_mkdtemp) {
 
 TEST_IMPL(fs_mkstemp) {
   int r;
-  int fd;
+  uv_os_fd_t fd1, fd2;
   const char path_template[] = "test_file_XXXXXX";
   uv_fs_t req;
 
@@ -1279,9 +1328,12 @@ TEST_IMPL(fs_mkstemp) {
 
   /* sync mkstemp */
   r = uv_fs_mkstemp(NULL, &mkstemp_req2, path_template, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   check_mkstemp_result(&mkstemp_req2);
 
+  fd1 = (uv_os_fd_t) mkstemp_req1.result;
+  fd2 = (uv_os_fd_t) mkstemp_req2.result;
+
   /* mkstemp return different values on subsequent calls */
   ASSERT(strcmp(mkstemp_req1.path, mkstemp_req2.path) != 0);
 
@@ -1293,30 +1345,31 @@ TEST_IMPL(fs_mkstemp) {
 
   /* We can write to the opened file */
   iov = uv_buf_init(test_buf, sizeof(test_buf));
-  r = uv_fs_write(NULL, &req, mkstemp_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_write(NULL, &req, fd1, &iov, 1, -1, NULL);
   ASSERT(r == sizeof(test_buf));
   ASSERT(req.result == sizeof(test_buf));
   uv_fs_req_cleanup(&req);
 
   /* Cleanup */
-  uv_fs_close(NULL, &req, mkstemp_req1.result, NULL);
+  uv_fs_close(NULL, &req, fd1, NULL);
   uv_fs_req_cleanup(&req);
-  uv_fs_close(NULL, &req, mkstemp_req2.result, NULL);
+  uv_fs_close(NULL, &req, fd2, NULL);
   uv_fs_req_cleanup(&req);
 
-  fd = uv_fs_open(NULL, &req, mkstemp_req1.path , O_RDONLY, 0, NULL);
-  ASSERT(fd >= 0);
+  r = uv_fs_open(NULL, &req, mkstemp_req1.path, O_RDONLY, 0, NULL);
+  ASSERT(r == 0);
+  fd1 = (uv_os_fd_t) req.result;
   uv_fs_req_cleanup(&req);
 
   memset(buf, 0, sizeof(buf));
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(NULL, &req, fd, &iov, 1, -1, NULL);
+  r = uv_fs_read(NULL, &req, fd1, &iov, 1, -1, NULL);
   ASSERT(r >= 0);
   ASSERT(req.result >= 0);
   ASSERT(strcmp(buf, test_buf) == 0);
   uv_fs_req_cleanup(&req);
 
-  uv_fs_close(NULL, &req, fd, NULL);
+  uv_fs_close(NULL, &req, fd1, NULL);
   uv_fs_req_cleanup(&req);
 
   unlink(mkstemp_req1.path);
@@ -1332,7 +1385,7 @@ TEST_IMPL(fs_mkstemp) {
 TEST_IMPL(fs_fstat) {
   int r;
   uv_fs_t req;
-  uv_file file;
+  uv_os_fd_t file;
   uv_stat_t* s;
 #ifndef _WIN32
   struct stat t;
@@ -1345,9 +1398,9 @@ TEST_IMPL(fs_fstat) {
 
   r = uv_fs_open(NULL, &req, "test_file", O_RDWR | O_CREAT,
       S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(req.result >= 0);
-  file = req.result;
+  file = (uv_os_fd_t) req.result;
   uv_fs_req_cleanup(&req);
 
 #ifndef _WIN32
@@ -1487,7 +1540,7 @@ TEST_IMPL(fs_fstat) {
 TEST_IMPL(fs_access) {
   int r;
   uv_fs_t req;
-  uv_file file;
+  uv_os_fd_t file;
 
   /* Setup. */
   unlink("test_file");
@@ -1511,9 +1564,9 @@ TEST_IMPL(fs_access) {
   /* Create file */
   r = uv_fs_open(NULL, &req, "test_file", O_RDWR | O_CREAT,
                  S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(req.result >= 0);
-  file = req.result;
+  file = (uv_os_fd_t) req.result;
   uv_fs_req_cleanup(&req);
 
   /* File should exist */
@@ -1563,7 +1616,7 @@ TEST_IMPL(fs_access) {
 TEST_IMPL(fs_chmod) {
   int r;
   uv_fs_t req;
-  uv_file file;
+  uv_os_fd_t file;
 
   /* Setup. */
   unlink("test_file");
@@ -1572,9 +1625,9 @@ TEST_IMPL(fs_chmod) {
 
   r = uv_fs_open(NULL, &req, "test_file", O_RDWR | O_CREAT,
       S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(req.result >= 0);
-  file = req.result;
+  file = (uv_os_fd_t) req.result;
   uv_fs_req_cleanup(&req);
 
   iov = uv_buf_init(test_buf, sizeof(test_buf));
@@ -1642,7 +1695,11 @@ TEST_IMPL(fs_chmod) {
   uv_run(loop, UV_RUN_DEFAULT);
   ASSERT(fchmod_cb_count == 1);
 
-  uv_fs_close(loop, &req, file, NULL);
+  /* Close file */
+  r = uv_fs_close(NULL, &req, file, NULL);
+  ASSERT(r == 0);
+  ASSERT(req.result == 0);
+  uv_fs_req_cleanup(&req);
 
   /*
    * Run the loop just to check we don't have make any extraneous uv_ref()
@@ -1661,7 +1718,7 @@ TEST_IMPL(fs_chmod) {
 TEST_IMPL(fs_unlink_readonly) {
   int r;
   uv_fs_t req;
-  uv_file file;
+  uv_os_fd_t file;
 
   /* Setup. */
   unlink("test_file");
@@ -1674,9 +1731,9 @@ TEST_IMPL(fs_unlink_readonly) {
                  O_RDWR | O_CREAT,
                  S_IWUSR | S_IRUSR,
                  NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(req.result >= 0);
-  file = req.result;
+  file = (uv_os_fd_t) req.result;
   uv_fs_req_cleanup(&req);
 
   iov = uv_buf_init(test_buf, sizeof(test_buf));
@@ -1685,7 +1742,11 @@ TEST_IMPL(fs_unlink_readonly) {
   ASSERT(req.result == sizeof(test_buf));
   uv_fs_req_cleanup(&req);
 
-  uv_fs_close(loop, &req, file, NULL);
+  /* Close file */
+  r = uv_fs_close(NULL, &req, file, NULL);
+  ASSERT(r == 0);
+  ASSERT(req.result == 0);
+  uv_fs_req_cleanup(&req);
 
   /* Make the file read-only */
   r = uv_fs_chmod(NULL, &req, "test_file", 0400, NULL);
@@ -1720,7 +1781,7 @@ TEST_IMPL(fs_unlink_readonly) {
 TEST_IMPL(fs_unlink_archive_readonly) {
   int r;
   uv_fs_t req;
-  uv_file file;
+  uv_os_fd_t file;
 
   /* Setup. */
   unlink("test_file");
@@ -1735,7 +1796,7 @@ TEST_IMPL(fs_unlink_archive_readonly) {
                  NULL);
   ASSERT(r >= 0);
   ASSERT(req.result >= 0);
-  file = req.result;
+  file = (uv_os_fd_t) req.result;
   uv_fs_req_cleanup(&req);
 
   iov = uv_buf_init(test_buf, sizeof(test_buf));
@@ -1744,7 +1805,10 @@ TEST_IMPL(fs_unlink_archive_readonly) {
   ASSERT(req.result == sizeof(test_buf));
   uv_fs_req_cleanup(&req);
 
-  uv_fs_close(loop, &req, file, NULL);
+  r = uv_fs_close(NULL, &req, file, NULL);
+  ASSERT(r == 0);
+  ASSERT(req.result == 0);
+  uv_fs_req_cleanup(&req);
 
   /* Make the file read-only and clear archive flag */
   r = SetFileAttributes("test_file", FILE_ATTRIBUTE_READONLY);
@@ -1778,7 +1842,7 @@ TEST_IMPL(fs_unlink_archive_readonly) {
 TEST_IMPL(fs_chown) {
   int r;
   uv_fs_t req;
-  uv_file file;
+  uv_os_fd_t file;
 
   /* Setup. */
   unlink("test_file");
@@ -1788,9 +1852,9 @@ TEST_IMPL(fs_chown) {
 
   r = uv_fs_open(NULL, &req, "test_file", O_RDWR | O_CREAT,
       S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(req.result >= 0);
-  file = req.result;
+  file = (uv_os_fd_t) req.result;
   uv_fs_req_cleanup(&req);
 
   /* sync chown */
@@ -1871,8 +1935,8 @@ TEST_IMPL(fs_chown) {
 TEST_IMPL(fs_link) {
   int r;
   uv_fs_t req;
-  uv_file file;
-  uv_file link;
+  uv_os_fd_t file;
+  uv_os_fd_t link;
 
   /* Setup. */
   unlink("test_file");
@@ -1883,9 +1947,9 @@ TEST_IMPL(fs_link) {
 
   r = uv_fs_open(NULL, &req, "test_file", O_RDWR | O_CREAT,
       S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(req.result >= 0);
-  file = req.result;
+  file = (uv_os_fd_t) req.result;
   uv_fs_req_cleanup(&req);
 
   iov = uv_buf_init(test_buf, sizeof(test_buf));
@@ -1894,7 +1958,11 @@ TEST_IMPL(fs_link) {
   ASSERT(req.result == sizeof(test_buf));
   uv_fs_req_cleanup(&req);
 
-  uv_fs_close(loop, &req, file, NULL);
+  /* Close file */
+  r = uv_fs_close(NULL, &req, file, NULL);
+  ASSERT(r == 0);
+  ASSERT(req.result == 0);
+  uv_fs_req_cleanup(&req);
 
   /* sync link */
   r = uv_fs_link(NULL, &req, "test_file", "test_file_link", NULL);
@@ -1903,9 +1971,9 @@ TEST_IMPL(fs_link) {
   uv_fs_req_cleanup(&req);
 
   r = uv_fs_open(NULL, &req, "test_file_link", O_RDWR, 0, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(req.result >= 0);
-  link = req.result;
+  link = (uv_os_fd_t) req.result;
   uv_fs_req_cleanup(&req);
 
   memset(buf, 0, sizeof(buf));
@@ -1915,7 +1983,11 @@ TEST_IMPL(fs_link) {
   ASSERT(req.result >= 0);
   ASSERT(strcmp(buf, test_buf) == 0);
 
-  close(link);
+  /* Close link */
+  r = uv_fs_close(NULL, &req, link, NULL);
+  ASSERT(r == 0);
+  ASSERT(req.result == 0);
+  uv_fs_req_cleanup(&req);
 
   /* async link */
   r = uv_fs_link(loop, &req, "test_file", "test_file_link2", link_cb);
@@ -1924,9 +1996,9 @@ TEST_IMPL(fs_link) {
   ASSERT(link_cb_count == 1);
 
   r = uv_fs_open(NULL, &req, "test_file_link2", O_RDWR, 0, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(req.result >= 0);
-  link = req.result;
+  link = (uv_os_fd_t) req.result;
   uv_fs_req_cleanup(&req);
 
   memset(buf, 0, sizeof(buf));
@@ -1936,7 +2008,11 @@ TEST_IMPL(fs_link) {
   ASSERT(req.result >= 0);
   ASSERT(strcmp(buf, test_buf) == 0);
 
-  uv_fs_close(loop, &req, link, NULL);
+  /* Close link */
+  r = uv_fs_close(NULL, &req, link, NULL);
+  ASSERT(r == 0);
+  ASSERT(req.result == 0);
+  uv_fs_req_cleanup(&req);
 
   /*
    * Run the loop just to check we don't have make any extraneous uv_ref()
@@ -1983,15 +2059,6 @@ TEST_IMPL(fs_realpath) {
   ASSERT(0 == uv_run(loop, UV_RUN_DEFAULT));
   ASSERT(dummy_cb_count == 1);
   ASSERT(req.ptr == NULL);
-#ifdef _WIN32
-  /*
-   * Windows XP and Server 2003 don't support GetFinalPathNameByHandleW()
-   */
-  if (req.result == UV_ENOSYS) {
-    uv_fs_req_cleanup(&req);
-    RETURN_SKIP("realpath is not supported on Windows XP");
-  }
-#endif
   ASSERT(req.result == UV_ENOENT);
   uv_fs_req_cleanup(&req);
 
@@ -2008,8 +2075,8 @@ TEST_IMPL(fs_realpath) {
 TEST_IMPL(fs_symlink) {
   int r;
   uv_fs_t req;
-  uv_file file;
-  uv_file link;
+  uv_os_fd_t file;
+  uv_os_fd_t link;
   char test_file_abs_buf[PATHMAX];
   size_t test_file_abs_size;
 
@@ -2032,9 +2099,9 @@ TEST_IMPL(fs_symlink) {
 
   r = uv_fs_open(NULL, &req, "test_file", O_RDWR | O_CREAT,
       S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(req.result >= 0);
-  file = req.result;
+  file = (uv_os_fd_t) req.result;
   uv_fs_req_cleanup(&req);
 
   iov = uv_buf_init(test_buf, sizeof(test_buf));
@@ -2043,7 +2110,11 @@ TEST_IMPL(fs_symlink) {
   ASSERT(req.result == sizeof(test_buf));
   uv_fs_req_cleanup(&req);
 
-  uv_fs_close(loop, &req, file, NULL);
+  /* Close file */
+  r = uv_fs_close(NULL, &req, file, NULL);
+  ASSERT(r == 0);
+  ASSERT(req.result == 0);
+  uv_fs_req_cleanup(&req);
 
   /* sync symlink */
   r = uv_fs_symlink(NULL, &req, "test_file", "test_file_symlink", 0, NULL);
@@ -2069,9 +2140,9 @@ TEST_IMPL(fs_symlink) {
   uv_fs_req_cleanup(&req);
 
   r = uv_fs_open(NULL, &req, "test_file_symlink", O_RDWR, 0, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(req.result >= 0);
-  link = req.result;
+  link = (uv_os_fd_t) req.result;
   uv_fs_req_cleanup(&req);
 
   memset(buf, 0, sizeof(buf));
@@ -2081,7 +2152,11 @@ TEST_IMPL(fs_symlink) {
   ASSERT(req.result >= 0);
   ASSERT(strcmp(buf, test_buf) == 0);
 
-  uv_fs_close(loop, &req, link, NULL);
+  /* Close link */
+  r = uv_fs_close(NULL, &req, link, NULL);
+  ASSERT(r == 0);
+  ASSERT(req.result == 0);
+  uv_fs_req_cleanup(&req);
 
   r = uv_fs_symlink(NULL,
                     &req,
@@ -2102,15 +2177,6 @@ TEST_IMPL(fs_symlink) {
   uv_fs_req_cleanup(&req);
 
   r = uv_fs_realpath(NULL, &req, "test_file_symlink_symlink", NULL);
-#ifdef _WIN32
-  /*
-   * Windows XP and Server 2003 don't support GetFinalPathNameByHandleW()
-   */
-  if (r == UV_ENOSYS) {
-    uv_fs_req_cleanup(&req);
-    RETURN_SKIP("realpath is not supported on Windows XP");
-  }
-#endif
   ASSERT(r == 0);
 #ifdef _WIN32
   ASSERT(stricmp(req.ptr, test_file_abs_buf) == 0);
@@ -2131,9 +2197,9 @@ TEST_IMPL(fs_symlink) {
   ASSERT(symlink_cb_count == 1);
 
   r = uv_fs_open(NULL, &req, "test_file_symlink2", O_RDWR, 0, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(req.result >= 0);
-  link = req.result;
+  link = (uv_os_fd_t) req.result;
   uv_fs_req_cleanup(&req);
 
   memset(buf, 0, sizeof(buf));
@@ -2143,7 +2209,11 @@ TEST_IMPL(fs_symlink) {
   ASSERT(req.result >= 0);
   ASSERT(strcmp(buf, test_buf) == 0);
 
-  uv_fs_close(loop, &req, link, NULL);
+  /* Close link */
+  r = uv_fs_close(NULL, &req, link, NULL);
+  ASSERT(r == 0);
+  ASSERT(req.result == 0);
+  uv_fs_req_cleanup(&req);
 
   r = uv_fs_symlink(NULL,
                     &req,
@@ -2160,15 +2230,6 @@ TEST_IMPL(fs_symlink) {
   ASSERT(readlink_cb_count == 1);
 
   r = uv_fs_realpath(loop, &req, "test_file", realpath_cb);
-#ifdef _WIN32
-  /*
-   * Windows XP and Server 2003 don't support GetFinalPathNameByHandleW()
-   */
-  if (r == UV_ENOSYS) {
-    uv_fs_req_cleanup(&req);
-    RETURN_SKIP("realpath is not supported on Windows XP");
-  }
-#endif
   ASSERT(r == 0);
   uv_run(loop, UV_RUN_DEFAULT);
   ASSERT(realpath_cb_count == 1);
@@ -2193,6 +2254,7 @@ TEST_IMPL(fs_symlink) {
 
 int test_symlink_dir_impl(int type) {
   uv_fs_t req;
+  uv_os_fd_t file;
   int r;
   char* test_dir;
   uv_dirent_t dent;
@@ -2269,15 +2331,6 @@ int test_symlink_dir_impl(int type) {
   uv_fs_req_cleanup(&req);
 
   r = uv_fs_realpath(NULL, &req, "test_dir_symlink", NULL);
-#ifdef _WIN32
-  /*
-   * Windows XP and Server 2003 don't support GetFinalPathNameByHandleW()
-   */
-  if (r == UV_ENOSYS) {
-    uv_fs_req_cleanup(&req);
-    RETURN_SKIP("realpath is not supported on Windows XP");
-  }
-#endif
   ASSERT(r == 0);
 #ifdef _WIN32
   ASSERT(strlen(req.ptr) == test_dir_abs_size - 5);
@@ -2289,17 +2342,19 @@ int test_symlink_dir_impl(int type) {
 
   r = uv_fs_open(NULL, &open_req1, "test_dir/file1", O_WRONLY | O_CREAT,
       S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   uv_fs_req_cleanup(&close_req);
 
   r = uv_fs_open(NULL, &open_req1, "test_dir/file2", O_WRONLY | O_CREAT,
       S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   uv_fs_req_cleanup(&close_req);
 
@@ -2508,20 +2563,27 @@ TEST_IMPL(fs_lstat_windows_store_apps) {
 
 TEST_IMPL(fs_utime) {
   utime_check_t checkme;
-  const char* path = "test_file";
+  const char path[] = "test_file";
   double atime;
   double mtime;
   uv_fs_t req;
+  uv_os_fd_t file;
   int r;
 
   /* Setup. */
   loop = uv_default_loop();
   unlink(path);
   r = uv_fs_open(NULL, &req, path, O_RDWR | O_CREAT, S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(req.result >= 0);
+  file = (uv_os_fd_t) req.result;
+  uv_fs_req_cleanup(&req);
+
+  /* Close file */
+  r = uv_fs_close(NULL, &req, file, NULL);
+  ASSERT(r == 0);
+  ASSERT(req.result == 0);
   uv_fs_req_cleanup(&req);
-  uv_fs_close(loop, &req, r, NULL);
 
   atime = mtime = 400497753; /* 1982-09-10 11:22:33 */
 
@@ -2565,6 +2627,74 @@ TEST_IMPL(fs_utime) {
 }
 
 
+TEST_IMPL(fs_utime_ex) {
+  utime_check_t checkme;
+  const char path[] = "test_file";
+  double atime;
+  double btime;
+  double mtime;
+  uv_fs_t req;
+  uv_os_fd_t file;
+  int r;
+
+  /* Setup. */
+  loop = uv_default_loop();
+  unlink(path);
+  r = uv_fs_open(NULL, &req, path, O_RDWR | O_CREAT, S_IWUSR | S_IRUSR, NULL);
+  ASSERT(r == 0);
+  ASSERT(req.result >= 0);
+  file = (uv_os_fd_t) req.result;
+  uv_fs_req_cleanup(&req);
+
+  /* Close file */
+  r = uv_fs_close(NULL, &req, file, NULL);
+  ASSERT(r == 0);
+  ASSERT(req.result == 0);
+  uv_fs_req_cleanup(&req);
+
+  atime = btime = mtime = 400497753; /* 1982-09-10 11:22:33 */
+
+  /*
+   * Test sub-second timestamps only on Windows (assuming NTFS). Some other
+   * platforms support sub-second timestamps, but that support is filesystem-
+   * dependent. Notably OS X (HFS Plus) does NOT support sub-second timestamps.
+   */
+#ifdef _WIN32
+  mtime += 0.444;            /* 1982-09-10 11:22:33.444 */
+#endif
+
+  r = uv_fs_utime_ex(NULL, &req, path, btime, atime, mtime, NULL);
+  ASSERT(r == 0);
+  ASSERT(req.result == 0);
+  uv_fs_req_cleanup(&req);
+
+  r = uv_fs_stat(NULL, &req, path, NULL);
+  ASSERT(r == 0);
+  ASSERT(req.result == 0);
+  check_utime_ex(path, btime, atime, mtime, 0);
+  uv_fs_req_cleanup(&req);
+
+  atime = btime = mtime = 1291404900; /* 2010-12-03 20:35:00 - mees <3 */
+  checkme.path = path;
+  checkme.atime = atime;
+  checkme.btime = btime;
+  checkme.mtime = mtime;
+
+  /* async utime */
+  utime_req.data = &checkme;
+  r = uv_fs_utime_ex(loop, &utime_req, path, btime, atime, mtime, utime_cb);
+  ASSERT(r == 0);
+  uv_run(loop, UV_RUN_DEFAULT);
+  ASSERT(utime_cb_count == 1);
+
+  /* Cleanup. */
+  unlink(path);
+
+  MAKE_VALGRIND_HAPPY();
+  return 0;
+}
+
+
 #ifdef _WIN32
 TEST_IMPL(fs_stat_root) {
   int r;
@@ -2599,10 +2729,10 @@ TEST_IMPL(fs_stat_root) {
 
 TEST_IMPL(fs_futime) {
   utime_check_t checkme;
-  const char* path = "test_file";
+  const char path[] = "test_file";
   double atime;
   double mtime;
-  uv_file file;
+  uv_os_fd_t file;
   uv_fs_t req;
   int r;
 #if defined(_AIX) && !defined(_AIX71)
@@ -2613,10 +2743,16 @@ TEST_IMPL(fs_futime) {
   loop = uv_default_loop();
   unlink(path);
   r = uv_fs_open(NULL, &req, path, O_RDWR | O_CREAT, S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(req.result >= 0);
+  file = (uv_os_fd_t) req.result;
+  uv_fs_req_cleanup(&req);
+
+  /* Close file */
+  r = uv_fs_close(NULL, &req, file, NULL);
+  ASSERT(r == 0);
+  ASSERT(req.result == 0);
   uv_fs_req_cleanup(&req);
-  uv_fs_close(loop, &req, r, NULL);
 
   atime = mtime = 400497753; /* 1982-09-10 11:22:33 */
 
@@ -2630,9 +2766,9 @@ TEST_IMPL(fs_futime) {
 #endif
 
   r = uv_fs_open(NULL, &req, path, O_RDWR, 0, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(req.result >= 0);
-  file = req.result; /* FIXME probably not how it's supposed to be used */
+  file = (uv_os_fd_t) req.result;
   uv_fs_req_cleanup(&req);
 
   r = uv_fs_futime(NULL, &req, file, atime, mtime, NULL);
@@ -2672,6 +2808,90 @@ TEST_IMPL(fs_futime) {
 }
 
 
+TEST_IMPL(fs_futime_ex) {
+#if defined(_AIX) && !defined(_AIX71)
+  RETURN_SKIP("futime is not implemented for AIX versions below 7.1");
+#else
+  utime_check_t checkme;
+  const char path[] = "test_file";
+  double atime;
+  double btime;
+  double mtime;
+  uv_os_fd_t file;
+  uv_fs_t req;
+  int r;
+
+  /* Setup. */
+  loop = uv_default_loop();
+  unlink(path);
+  r = uv_fs_open(NULL, &req, path, O_RDWR | O_CREAT, S_IWUSR | S_IRUSR, NULL);
+  ASSERT(r == 0);
+  ASSERT(req.result >= 0);
+  file = (uv_os_fd_t) req.result;
+  uv_fs_req_cleanup(&req);
+
+  /* Close file */
+  r = uv_fs_close(NULL, &req, file, NULL);
+  ASSERT(r == 0);
+  ASSERT(req.result == 0);
+  uv_fs_req_cleanup(&req);
+
+  atime = btime = mtime = 400497753; /* 1982-09-10 11:22:33 */
+
+  /*
+   * Test sub-second timestamps only on Windows (assuming NTFS). Some other
+   * platforms support sub-second timestamps, but that support is filesystem-
+   * dependent. Notably OS X (HFS Plus) does NOT support sub-second timestamps.
+   */
+
+#ifdef _WIN32
+  mtime += 0.444;            /* 1982-09-10 11:22:33.444 */
+#endif
+
+  r = uv_fs_open(NULL, &req, path, O_RDWR, 0, NULL);
+  ASSERT(r == 0);
+  ASSERT(req.result >= 0);
+  file = (uv_os_fd_t) req.result;
+  uv_fs_req_cleanup(&req);
+
+  r = uv_fs_futime_ex(NULL, &req, file, btime, atime, mtime, NULL);
+#if defined(__CYGWIN__) || defined(__MSYS__)
+  ASSERT(r == UV_ENOSYS);
+  RETURN_SKIP("futime not supported on Cygwin");
+#else
+  ASSERT(r == 0);
+  ASSERT(req.result == 0);
+#endif
+  uv_fs_req_cleanup(&req);
+
+  r = uv_fs_stat(NULL, &req, path, NULL);
+  ASSERT(r == 0);
+  ASSERT(req.result == 0);
+  check_utime_ex(path, btime, atime, mtime, 0);
+  uv_fs_req_cleanup(&req);
+
+  atime = btime = mtime = 1291404900; /* 2010-12-03 20:35:00 - mees <3 */
+
+  checkme.atime = atime;
+  checkme.btime = btime;
+  checkme.mtime = mtime;
+  checkme.path = path;
+
+  /* async futime */
+  futime_req.data = &checkme;
+  r = uv_fs_futime_ex(loop, &futime_req, file, btime, atime, mtime, futime_cb);
+  ASSERT(r == 0);
+  uv_run(loop, UV_RUN_DEFAULT);
+  ASSERT(futime_cb_count == 1);
+
+  /* Cleanup. */
+  unlink(path);
+
+  MAKE_VALGRIND_HAPPY();
+  return 0;
+#endif
+}
+
 TEST_IMPL(fs_lutime) {
   utime_check_t checkme;
   const char* path = "test_file";
@@ -2862,16 +3082,17 @@ TEST_IMPL(fs_scandir_file) {
 TEST_IMPL(fs_open_dir) {
   const char* path;
   uv_fs_t req;
-  int r, file;
+  int r;
+  uv_os_fd_t file;
 
   path = ".";
   loop = uv_default_loop();
 
   r = uv_fs_open(NULL, &req, path, O_RDONLY, 0, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(req.result >= 0);
   ASSERT(req.ptr == NULL);
-  file = r;
+  file = (uv_os_fd_t) req.result;
   uv_fs_req_cleanup(&req);
 
   r = uv_fs_close(NULL, &req, file, NULL);
@@ -2891,6 +3112,7 @@ TEST_IMPL(fs_open_dir) {
 
 static void fs_file_open_append(int add_flags) {
   int r;
+  uv_os_fd_t file;
 
   /* Setup. */
   unlink("test_file");
@@ -2899,17 +3121,18 @@ static void fs_file_open_append(int add_flags) {
 
   r = uv_fs_open(NULL, &open_req1, "test_file",
       O_WRONLY | O_CREAT | add_flags, S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
   iov = uv_buf_init(test_buf, sizeof(test_buf));
-  r = uv_fs_write(NULL, &write_req, open_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_write(NULL, &write_req, file, &iov, 1, -1, NULL);
   ASSERT(r >= 0);
   ASSERT(write_req.result >= 0);
   uv_fs_req_cleanup(&write_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
@@ -2918,27 +3141,29 @@ static void fs_file_open_append(int add_flags) {
       O_RDWR | O_APPEND | add_flags, 0, NULL);
   ASSERT(r >= 0);
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
   iov = uv_buf_init(test_buf, sizeof(test_buf));
-  r = uv_fs_write(NULL, &write_req, open_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_write(NULL, &write_req, file, &iov, 1, -1, NULL);
   ASSERT(r >= 0);
   ASSERT(write_req.result >= 0);
   uv_fs_req_cleanup(&write_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
 
   r = uv_fs_open(NULL, &open_req1, "test_file", O_RDONLY | add_flags,
       S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(NULL, &read_req, open_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_read(NULL, &read_req, file, &iov, 1, -1, NULL);
   printf("read = %d\n", r);
   ASSERT(r == 26);
   ASSERT(read_req.result == 26);
@@ -2947,7 +3172,7 @@ static void fs_file_open_append(int add_flags) {
                 sizeof("test-buffer\n\0test-buffer\n\0") - 1) == 0);
   uv_fs_req_cleanup(&read_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
@@ -2966,6 +3191,7 @@ TEST_IMPL(fs_file_open_append) {
 
 TEST_IMPL(fs_rename_to_existing_file) {
   int r;
+  uv_os_fd_t file;
 
   /* Setup. */
   unlink("test_file");
@@ -2975,28 +3201,30 @@ TEST_IMPL(fs_rename_to_existing_file) {
 
   r = uv_fs_open(NULL, &open_req1, "test_file", O_WRONLY | O_CREAT,
       S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
   iov = uv_buf_init(test_buf, sizeof(test_buf));
-  r = uv_fs_write(NULL, &write_req, open_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_write(NULL, &write_req, file, &iov, 1, -1, NULL);
   ASSERT(r >= 0);
   ASSERT(write_req.result >= 0);
   uv_fs_req_cleanup(&write_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
 
   r = uv_fs_open(NULL, &open_req1, "test_file2", O_WRONLY | O_CREAT,
       S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
@@ -3007,19 +3235,20 @@ TEST_IMPL(fs_rename_to_existing_file) {
   uv_fs_req_cleanup(&rename_req);
 
   r = uv_fs_open(NULL, &open_req1, "test_file2", O_RDONLY, 0, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
   memset(buf, 0, sizeof(buf));
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(NULL, &read_req, open_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_read(NULL, &read_req, file, &iov, 1, -1, NULL);
   ASSERT(r >= 0);
   ASSERT(read_req.result >= 0);
   ASSERT(strcmp(buf, test_buf) == 0);
   uv_fs_req_cleanup(&read_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
@@ -3036,19 +3265,18 @@ TEST_IMPL(fs_rename_to_existing_file) {
 static void fs_read_bufs(int add_flags) {
   char scratch[768];
   uv_buf_t bufs[4];
+  uv_os_fd_t file;
 
-  ASSERT(0 <= uv_fs_open(NULL, &open_req1,
+  ASSERT(0 == uv_fs_open(NULL, &open_req1,
                          "test/fixtures/lorem_ipsum.txt",
                          O_RDONLY | add_flags, 0, NULL));
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
-  ASSERT(UV_EINVAL == uv_fs_read(NULL, &read_req, open_req1.result,
-                                 NULL, 0, 0, NULL));
-  ASSERT(UV_EINVAL == uv_fs_read(NULL, &read_req, open_req1.result,
-                                 NULL, 1, 0, NULL));
-  ASSERT(UV_EINVAL == uv_fs_read(NULL, &read_req, open_req1.result,
-                                 bufs, 0, 0, NULL));
+  ASSERT(UV_EINVAL == uv_fs_read(NULL, &read_req, file, NULL, 0, 0, NULL));
+  ASSERT(UV_EINVAL == uv_fs_read(NULL, &read_req, file, NULL, 1, 0, NULL));
+  ASSERT(UV_EINVAL == uv_fs_read(NULL, &read_req, file, bufs, 0, 0, NULL));
 
   bufs[0] = uv_buf_init(scratch + 0, 256);
   bufs[1] = uv_buf_init(scratch + 256, 256);
@@ -3057,7 +3285,7 @@ static void fs_read_bufs(int add_flags) {
 
   ASSERT(446 == uv_fs_read(NULL,
                            &read_req,
-                           open_req1.result,
+                           file,
                            bufs + 0,
                            2,  /* 2x 256 bytes. */
                            0,  /* Positional read. */
@@ -3067,7 +3295,7 @@ static void fs_read_bufs(int add_flags) {
 
   ASSERT(190 == uv_fs_read(NULL,
                            &read_req,
-                           open_req1.result,
+                           file,
                            bufs + 2,
                            2,  /* 2x 128 bytes. */
                            256,  /* Positional read. */
@@ -3078,7 +3306,7 @@ static void fs_read_bufs(int add_flags) {
   ASSERT(0 == memcmp(bufs[1].base + 0, bufs[2].base, 128));
   ASSERT(0 == memcmp(bufs[1].base + 128, bufs[3].base, 190 - 128));
 
-  ASSERT(0 == uv_fs_close(NULL, &close_req, open_req1.result, NULL));
+  ASSERT(0 == uv_fs_close(NULL, &close_req, file, NULL));
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
 }
@@ -3096,6 +3324,7 @@ static void fs_read_file_eof(int add_flags) {
   RETURN_SKIP("Cygwin pread at EOF may (incorrectly) return data!");
 #endif
   int r;
+  uv_os_fd_t file;
 
   /* Setup. */
   unlink("test_file");
@@ -3104,43 +3333,45 @@ static void fs_read_file_eof(int add_flags) {
 
   r = uv_fs_open(NULL, &open_req1, "test_file",
       O_WRONLY | O_CREAT | add_flags, S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
   iov = uv_buf_init(test_buf, sizeof(test_buf));
-  r = uv_fs_write(NULL, &write_req, open_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_write(NULL, &write_req, file, &iov, 1, -1, NULL);
   ASSERT(r >= 0);
   ASSERT(write_req.result >= 0);
   uv_fs_req_cleanup(&write_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
 
   r = uv_fs_open(NULL, &open_req1, "test_file", O_RDONLY | add_flags, 0,
       NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
   memset(buf, 0, sizeof(buf));
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(NULL, &read_req, open_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_read(NULL, &read_req, file, &iov, 1, -1, NULL);
   ASSERT(r >= 0);
   ASSERT(read_req.result >= 0);
   ASSERT(strcmp(buf, test_buf) == 0);
   uv_fs_req_cleanup(&read_req);
 
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(NULL, &read_req, open_req1.result, &iov, 1,
+  r = uv_fs_read(NULL, &read_req, file, &iov, 1,
                  read_req.result, NULL);
   ASSERT(r == 0);
   ASSERT(read_req.result == 0);
   uv_fs_req_cleanup(&read_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
@@ -3160,6 +3391,7 @@ TEST_IMPL(fs_read_file_eof) {
 static void fs_write_multiple_bufs(int add_flags) {
   uv_buf_t iovs[2];
   int r;
+  uv_os_fd_t file;
 
   /* Setup. */
   unlink("test_file");
@@ -3168,26 +3400,28 @@ static void fs_write_multiple_bufs(int add_flags) {
 
   r = uv_fs_open(NULL, &open_req1, "test_file",
       O_WRONLY | O_CREAT | add_flags, S_IWUSR | S_IRUSR, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
   iovs[0] = uv_buf_init(test_buf, sizeof(test_buf));
   iovs[1] = uv_buf_init(test_buf2, sizeof(test_buf2));
-  r = uv_fs_write(NULL, &write_req, open_req1.result, iovs, 2, 0, NULL);
+  r = uv_fs_write(NULL, &write_req, file, iovs, 2, 0, NULL);
   ASSERT(r >= 0);
   ASSERT(write_req.result >= 0);
   uv_fs_req_cleanup(&write_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
 
   r = uv_fs_open(NULL, &open_req1, "test_file", O_RDONLY | add_flags, 0,
       NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
   memset(buf, 0, sizeof(buf));
@@ -3195,8 +3429,8 @@ static void fs_write_multiple_bufs(int add_flags) {
   /* Read the strings back to separate buffers. */
   iovs[0] = uv_buf_init(buf, sizeof(test_buf));
   iovs[1] = uv_buf_init(buf2, sizeof(test_buf2));
-  ASSERT(lseek(open_req1.result, 0, SEEK_CUR) == 0);
-  r = uv_fs_read(NULL, &read_req, open_req1.result, iovs, 2, -1, NULL);
+  ASSERT(uv_test_lseek(file, 0, SEEK_CUR) == 0);
+  r = uv_fs_read(NULL, &read_req, file, iovs, 2, -1, NULL);
   ASSERT(r >= 0);
   ASSERT(read_req.result == sizeof(test_buf) + sizeof(test_buf2));
   ASSERT(strcmp(buf, test_buf) == 0);
@@ -3204,7 +3438,7 @@ static void fs_write_multiple_bufs(int add_flags) {
   uv_fs_req_cleanup(&read_req);
 
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(NULL, &read_req, open_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_read(NULL, &read_req, file, &iov, 1, -1, NULL);
   ASSERT(r == 0);
   ASSERT(read_req.result == 0);
   uv_fs_req_cleanup(&read_req);
@@ -3212,12 +3446,12 @@ static void fs_write_multiple_bufs(int add_flags) {
   /* Read the strings back to separate buffers. */
   iovs[0] = uv_buf_init(buf, sizeof(test_buf));
   iovs[1] = uv_buf_init(buf2, sizeof(test_buf2));
-  r = uv_fs_read(NULL, &read_req, open_req1.result, iovs, 2, 0, NULL);
+  r = uv_fs_read(NULL, &read_req, file, iovs, 2, 0, NULL);
   ASSERT(r >= 0);
   if (read_req.result == sizeof(test_buf)) {
     /* Infer that preadv is not available. */
     uv_fs_req_cleanup(&read_req);
-    r = uv_fs_read(NULL, &read_req, open_req1.result, &iovs[1], 1, read_req.result, NULL);
+    r = uv_fs_read(NULL, &read_req, file, &iovs[1], 1, read_req.result, NULL);
     ASSERT(r >= 0);
     ASSERT(read_req.result == sizeof(test_buf2));
   } else {
@@ -3228,13 +3462,13 @@ static void fs_write_multiple_bufs(int add_flags) {
   uv_fs_req_cleanup(&read_req);
 
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(NULL, &read_req, open_req1.result, &iov, 1,
+  r = uv_fs_read(NULL, &read_req, file, &iov, 1,
                  sizeof(test_buf) + sizeof(test_buf2), NULL);
   ASSERT(r == 0);
   ASSERT(read_req.result == 0);
   uv_fs_req_cleanup(&read_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
@@ -3258,6 +3492,7 @@ static void fs_write_alotof_bufs(int add_flags) {
   char* buffer;
   size_t index;
   int r;
+  uv_os_fd_t file;
 
   iovcount = 54321;
 
@@ -3276,8 +3511,9 @@ static void fs_write_alotof_bufs(int add_flags) {
                  O_RDWR | O_CREAT | add_flags,
                  S_IWUSR | S_IRUSR,
                  NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
   for (index = 0; index < iovcount; ++index)
@@ -3285,13 +3521,13 @@ static void fs_write_alotof_bufs(int add_flags) {
 
   r = uv_fs_write(NULL,
                   &write_req,
-                  open_req1.result,
+                  file,
                   iovs,
                   iovcount,
                   -1,
                   NULL);
   ASSERT(r >= 0);
-  ASSERT((size_t)write_req.result == sizeof(test_buf) * iovcount);
+  ASSERT((size_t) write_req.result == sizeof(test_buf) * iovcount);
   uv_fs_req_cleanup(&write_req);
 
   /* Read the strings back to separate buffers. */
@@ -3302,22 +3538,23 @@ static void fs_write_alotof_bufs(int add_flags) {
     iovs[index] = uv_buf_init(buffer + index * sizeof(test_buf),
                               sizeof(test_buf));
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
 
   r = uv_fs_open(NULL, &open_req1, "test_file", O_RDONLY | add_flags, 0,
     NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
-  r = uv_fs_read(NULL, &read_req, open_req1.result, iovs, iovcount, -1, NULL);
+  r = uv_fs_read(NULL, &read_req, file, iovs, iovcount, -1, NULL);
   if (iovcount > iovmax)
     iovcount = iovmax;
   ASSERT(r >= 0);
-  ASSERT((size_t)read_req.result == sizeof(test_buf) * iovcount);
+  ASSERT((size_t) read_req.result == sizeof(test_buf) * iovcount);
 
   for (index = 0; index < iovcount; ++index)
     ASSERT(strncmp(buffer + index * sizeof(test_buf),
@@ -3327,11 +3564,11 @@ static void fs_write_alotof_bufs(int add_flags) {
   uv_fs_req_cleanup(&read_req);
   free(buffer);
 
-  ASSERT(lseek(open_req1.result, write_req.result, SEEK_SET) == write_req.result);
+  ASSERT(uv_test_lseek(file, write_req.result, SEEK_SET) == write_req.result);
   iov = uv_buf_init(buf, sizeof(buf));
   r = uv_fs_read(NULL,
                  &read_req,
-                 open_req1.result,
+                 file,
                  &iov,
                  1,
                  -1,
@@ -3340,7 +3577,7 @@ static void fs_write_alotof_bufs(int add_flags) {
   ASSERT(read_req.result == 0);
   uv_fs_req_cleanup(&read_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
@@ -3366,6 +3603,7 @@ static void fs_write_alotof_bufs_with_offset(int add_flags) {
   size_t index;
   int r;
   int64_t offset;
+  uv_os_fd_t file;
   char* filler;
   int filler_len;
 
@@ -3388,29 +3626,30 @@ static void fs_write_alotof_bufs_with_offset(int add_flags) {
                  O_RDWR | O_CREAT | add_flags,
                  S_IWUSR | S_IRUSR,
                  NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
   iov = uv_buf_init(filler, filler_len);
-  r = uv_fs_write(NULL, &write_req, open_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_write(NULL, &write_req, file, &iov, 1, -1, NULL);
   ASSERT(r == filler_len);
   ASSERT(write_req.result == filler_len);
   uv_fs_req_cleanup(&write_req);
-  offset = (int64_t)r;
+  offset = (int64_t) r;
 
   for (index = 0; index < iovcount; ++index)
     iovs[index] = uv_buf_init(test_buf, sizeof(test_buf));
 
   r = uv_fs_write(NULL,
                   &write_req,
-                  open_req1.result,
+                  file,
                   iovs,
                   iovcount,
                   offset,
                   NULL);
   ASSERT(r >= 0);
-  ASSERT((size_t)write_req.result == sizeof(test_buf) * iovcount);
+  ASSERT((size_t) write_req.result == sizeof(test_buf) * iovcount);
   uv_fs_req_cleanup(&write_req);
 
   /* Read the strings back to separate buffers. */
@@ -3421,14 +3660,14 @@ static void fs_write_alotof_bufs_with_offset(int add_flags) {
     iovs[index] = uv_buf_init(buffer + index * sizeof(test_buf),
                               sizeof(test_buf));
 
-  r = uv_fs_read(NULL, &read_req, open_req1.result,
+  r = uv_fs_read(NULL, &read_req, file,
                  iovs, iovcount, offset, NULL);
   ASSERT(r >= 0);
   if (r == sizeof(test_buf))
     iovcount = 1; /* Infer that preadv is not available. */
   else if (iovcount > iovmax)
     iovcount = iovmax;
-  ASSERT((size_t)read_req.result == sizeof(test_buf) * iovcount);
+  ASSERT((size_t) read_req.result == sizeof(test_buf) * iovcount);
 
   for (index = 0; index < iovcount; ++index)
     ASSERT(strncmp(buffer + index * sizeof(test_buf),
@@ -3441,13 +3680,13 @@ static void fs_write_alotof_bufs_with_offset(int add_flags) {
   r = uv_fs_stat(NULL, &stat_req, "test_file", NULL);
   ASSERT(r == 0);
   ASSERT((int64_t)((uv_stat_t*)stat_req.ptr)->st_size ==
-         offset + (int64_t)write_req.result);
+         offset + (int64_t) write_req.result);
   uv_fs_req_cleanup(&stat_req);
 
   iov = uv_buf_init(buf, sizeof(buf));
   r = uv_fs_read(NULL,
                  &read_req,
-                 open_req1.result,
+                 file,
                  &iov,
                  1,
                  offset + write_req.result,
@@ -3456,7 +3695,7 @@ static void fs_write_alotof_bufs_with_offset(int add_flags) {
   ASSERT(read_req.result == 0);
   uv_fs_req_cleanup(&read_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
@@ -3474,6 +3713,7 @@ TEST_IMPL(fs_write_alotof_bufs_with_offset) {
 }
 
 TEST_IMPL(fs_read_dir) {
+  uv_os_fd_t file;
   int r;
   char buf[2];
   loop = uv_default_loop();
@@ -3493,12 +3733,14 @@ TEST_IMPL(fs_read_dir) {
                  UV_FS_O_RDONLY | UV_FS_O_DIRECTORY,
                  S_IWUSR | S_IRUSR,
                  NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
+  ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
   /* Try to read data from the directory */
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(NULL, &read_req, open_req1.result, &iov, 1, 0, NULL);
+  r = uv_fs_read(NULL, &read_req, file, &iov, 1, 0, NULL);
 #if defined(__FreeBSD__)   || \
     defined(__OpenBSD__)   || \
     defined(__NetBSD__)    || \
@@ -3517,7 +3759,7 @@ TEST_IMPL(fs_read_dir) {
 #endif
   uv_fs_req_cleanup(&read_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   uv_fs_req_cleanup(&close_req);
 
@@ -3758,93 +4000,23 @@ TEST_IMPL(fs_read_write_null_arguments) {
   return 0;
 }
 
-
-TEST_IMPL(get_osfhandle_valid_handle) {
-  int r;
-  uv_os_fd_t fd;
-
-  /* Setup. */
-  unlink("test_file");
-
-  loop = uv_default_loop();
-
-  r = uv_fs_open(NULL,
-                 &open_req1,
-                 "test_file",
-                 O_RDWR | O_CREAT,
-                 S_IWUSR | S_IRUSR,
-                 NULL);
-  ASSERT(r >= 0);
-  ASSERT(open_req1.result >= 0);
-  uv_fs_req_cleanup(&open_req1);
-
-  fd = uv_get_osfhandle(open_req1.result);
 #ifdef _WIN32
-  ASSERT(fd != INVALID_HANDLE_VALUE);
-#else
-  ASSERT(fd >= 0);
-#endif
-
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
-  ASSERT(r == 0);
-  ASSERT(close_req.result == 0);
-  uv_fs_req_cleanup(&close_req);
-
-  /* Cleanup. */
-  unlink("test_file");
-
-  MAKE_VALGRIND_HAPPY();
-  return 0;
-}
-
-TEST_IMPL(open_osfhandle_valid_handle) {
+TEST_IMPL(fs_invalid_filename) {
+  uv_fs_t req;
   int r;
-  uv_os_fd_t handle;
-  int fd;
 
-  /* Setup. */
-  unlink("test_file");
-
-  loop = uv_default_loop();
-
-  r = uv_fs_open(NULL,
-                 &open_req1,
-                 "test_file",
-                 O_RDWR | O_CREAT,
-                 S_IWUSR | S_IRUSR,
-                 NULL);
-  ASSERT(r >= 0);
-  ASSERT(open_req1.result >= 0);
-  uv_fs_req_cleanup(&open_req1);
-
-  handle = uv_get_osfhandle(open_req1.result);
-#ifdef _WIN32
-  ASSERT(handle != INVALID_HANDLE_VALUE);
-#else
-  ASSERT(handle >= 0);
-#endif
-
-  fd = uv_open_osfhandle(handle);
-#ifdef _WIN32
-  ASSERT(fd > 0);
-#else
-  ASSERT(fd == open_req1.result);
-#endif
-
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
-  ASSERT(r == 0);
-  ASSERT(close_req.result == 0);
-  uv_fs_req_cleanup(&close_req);
-
-  /* Cleanup. */
-  unlink("test_file");
+  r = uv_fs_open(NULL, &req, "foo??", O_RDONLY, 0, NULL);
+  ASSERT(r == UV_EINVAL);
+  ASSERT(req.result == UV_EINVAL);
+  uv_fs_req_cleanup(&req);
 
-  MAKE_VALGRIND_HAPPY();
   return 0;
 }
+#endif
 
 TEST_IMPL(fs_file_pos_after_op_with_offset) {
   int r;
+  uv_os_fd_t file;
 
   /* Setup. */
   unlink("test_file");
@@ -3856,23 +4028,28 @@ TEST_IMPL(fs_file_pos_after_op_with_offset) {
                  O_RDWR | O_CREAT,
                  S_IWUSR | S_IRUSR,
                  NULL);
-  ASSERT(r > 0);
+  ASSERT(r == 0);
   uv_fs_req_cleanup(&open_req1);
+  file = (uv_os_fd_t) open_req1.result;
 
   iov = uv_buf_init(test_buf, sizeof(test_buf));
-  r = uv_fs_write(NULL, &write_req, open_req1.result, &iov, 1, 0, NULL);
+  r = uv_fs_write(NULL, &write_req, file, &iov, 1, 0, NULL);
   ASSERT(r == sizeof(test_buf));
-  ASSERT(lseek(open_req1.result, 0, SEEK_CUR) == 0);
+
+  ASSERT(uv_test_lseek(file, 0, SEEK_CUR) == 0);
+
   uv_fs_req_cleanup(&write_req);
 
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(NULL, &read_req, open_req1.result, &iov, 1, 0, NULL);
+  r = uv_fs_read(NULL, &read_req, file, &iov, 1, 0, NULL);
   ASSERT(r == sizeof(test_buf));
   ASSERT(strcmp(buf, test_buf) == 0);
-  ASSERT(lseek(open_req1.result, 0, SEEK_CUR) == 0);
+
+  ASSERT(uv_test_lseek(file, 0, SEEK_CUR) == 0);
+
   uv_fs_req_cleanup(&read_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   uv_fs_req_cleanup(&close_req);
 
@@ -3884,59 +4061,60 @@ TEST_IMPL(fs_file_pos_after_op_with_offset) {
 }
 
 #ifdef _WIN32
-static void fs_file_pos_common(void) {
+static void fs_file_pos_common(uv_os_fd_t file) {
   int r;
 
   iov = uv_buf_init("abc", 3);
-  r = uv_fs_write(NULL, &write_req, open_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_write(NULL, &write_req, file, &iov, 1, -1, NULL);
   ASSERT(r == 3);
   uv_fs_req_cleanup(&write_req);
 
   /* Read with offset should not change the position */
   iov = uv_buf_init(buf, 1);
-  r = uv_fs_read(NULL, &read_req, open_req1.result, &iov, 1, 1, NULL);
+  r = uv_fs_read(NULL, &read_req, file, &iov, 1, 1, NULL);
   ASSERT(r == 1);
   ASSERT(buf[0] == 'b');
   uv_fs_req_cleanup(&read_req);
 
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(NULL, &read_req, open_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_read(NULL, &read_req, file, &iov, 1, -1, NULL);
   ASSERT(r == 0);
   uv_fs_req_cleanup(&read_req);
 
   /* Write without offset should change the position */
   iov = uv_buf_init("d", 1);
-  r = uv_fs_write(NULL, &write_req, open_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_write(NULL, &write_req, file, &iov, 1, -1, NULL);
   ASSERT(r == 1);
   uv_fs_req_cleanup(&write_req);
 
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(NULL, &read_req, open_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_read(NULL, &read_req, file, &iov, 1, -1, NULL);
   ASSERT(r == 0);
   uv_fs_req_cleanup(&read_req);
 }
 
-static void fs_file_pos_close_check(const char *contents, int size) {
+static void fs_file_pos_close_check(uv_os_fd_t file, const char *contents, int size) {
   int r;
 
   /* Close */
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   uv_fs_req_cleanup(&close_req);
 
   /* Confirm file contents */
   r = uv_fs_open(NULL, &open_req1, "test_file", O_RDONLY, 0, NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(NULL, &read_req, open_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_read(NULL, &read_req, file, &iov, 1, -1, NULL);
   ASSERT(r == size);
   ASSERT(strncmp(buf, contents, size) == 0);
   uv_fs_req_cleanup(&read_req);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   uv_fs_req_cleanup(&close_req);
 
@@ -3946,6 +4124,7 @@ static void fs_file_pos_close_check(const char *contents, int size) {
 
 static void fs_file_pos_write(int add_flags) {
   int r;
+  uv_os_fd_t file;
 
   /* Setup. */
   unlink("test_file");
@@ -3956,23 +4135,25 @@ static void fs_file_pos_write(int add_flags) {
                  O_TRUNC | O_CREAT | O_RDWR | add_flags,
                  S_IWUSR | S_IRUSR,
                  NULL);
-  ASSERT(r > 0);
+  ASSERT(r == 0);
+  ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
-  fs_file_pos_common();
+  fs_file_pos_common(file);
 
   /* Write with offset should not change the position */
   iov = uv_buf_init("e", 1);
-  r = uv_fs_write(NULL, &write_req, open_req1.result, &iov, 1, 1, NULL);
+  r = uv_fs_write(NULL, &write_req, file, &iov, 1, 1, NULL);
   ASSERT(r == 1);
   uv_fs_req_cleanup(&write_req);
 
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(NULL, &read_req, open_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_read(NULL, &read_req, file, &iov, 1, -1, NULL);
   ASSERT(r == 0);
   uv_fs_req_cleanup(&read_req);
 
-  fs_file_pos_close_check("aecd", 4);
+  fs_file_pos_close_check(file, "aecd", 4);
 }
 TEST_IMPL(fs_file_pos_write) {
   fs_file_pos_write(0);
@@ -3984,6 +4165,7 @@ TEST_IMPL(fs_file_pos_write) {
 
 static void fs_file_pos_append(int add_flags) {
   int r;
+  uv_os_fd_t file;
 
   /* Setup. */
   unlink("test_file");
@@ -3994,25 +4176,27 @@ static void fs_file_pos_append(int add_flags) {
                  O_APPEND | O_CREAT | O_RDWR | add_flags,
                  S_IWUSR | S_IRUSR,
                  NULL);
-  ASSERT(r > 0);
+  ASSERT(r == 0);
+  ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
-  fs_file_pos_common();
+  fs_file_pos_common(file);
 
   /* Write with offset appends (ignoring offset)
    * but does not change the position */
   iov = uv_buf_init("e", 1);
-  r = uv_fs_write(NULL, &write_req, open_req1.result, &iov, 1, 1, NULL);
+  r = uv_fs_write(NULL, &write_req, file, &iov, 1, 1, NULL);
   ASSERT(r == 1);
   uv_fs_req_cleanup(&write_req);
 
   iov = uv_buf_init(buf, sizeof(buf));
-  r = uv_fs_read(NULL, &read_req, open_req1.result, &iov, 1, -1, NULL);
+  r = uv_fs_read(NULL, &read_req, file, &iov, 1, -1, NULL);
   ASSERT(r == 1);
   ASSERT(buf[0] == 'e');
   uv_fs_req_cleanup(&read_req);
 
-  fs_file_pos_close_check("abcde", 5);
+  fs_file_pos_close_check(file, "abcde", 5);
 }
 TEST_IMPL(fs_file_pos_append) {
   fs_file_pos_append(0);
@@ -4129,6 +4313,7 @@ TEST_IMPL(fs_null_req) {
 #ifdef _WIN32
 TEST_IMPL(fs_exclusive_sharing_mode) {
   int r;
+  uv_os_fd_t file;
 
   /* Setup. */
   unlink("test_file");
@@ -4141,8 +4326,9 @@ TEST_IMPL(fs_exclusive_sharing_mode) {
                  O_RDWR | O_CREAT | UV_FS_O_EXLOCK,
                  S_IWUSR | S_IRUSR,
                  NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
   r = uv_fs_open(NULL,
@@ -4152,10 +4338,10 @@ TEST_IMPL(fs_exclusive_sharing_mode) {
                  S_IWUSR | S_IRUSR,
                  NULL);
   ASSERT(r < 0);
-  ASSERT(open_req2.result < 0);
+  ASSERT(open_req2.result == r);
   uv_fs_req_cleanup(&open_req2);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
@@ -4166,11 +4352,12 @@ TEST_IMPL(fs_exclusive_sharing_mode) {
                  O_RDONLY | UV_FS_O_EXLOCK,
                  S_IWUSR | S_IRUSR,
                  NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req2.result >= 0);
+  file = (uv_os_fd_t) open_req2.result;
   uv_fs_req_cleanup(&open_req2);
 
-  r = uv_fs_close(NULL, &close_req, open_req2.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
@@ -4186,6 +4373,7 @@ TEST_IMPL(fs_exclusive_sharing_mode) {
 #ifdef _WIN32
 TEST_IMPL(fs_file_flag_no_buffering) {
   int r;
+  uv_os_fd_t file;
 
   /* Setup. */
   unlink("test_file");
@@ -4202,11 +4390,12 @@ TEST_IMPL(fs_file_flag_no_buffering) {
                  UV_FS_O_RDWR | UV_FS_O_CREAT | UV_FS_O_DIRECT,
                  S_IWUSR | S_IRUSR,
                  NULL);
-  ASSERT(r >= 0);
+  ASSERT(r == 0);
   ASSERT(open_req1.result >= 0);
+  file = (uv_os_fd_t) open_req1.result;
   uv_fs_req_cleanup(&open_req1);
 
-  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+  r = uv_fs_close(NULL, &close_req, file, NULL);
   ASSERT(r == 0);
   ASSERT(close_req.result == 0);
   uv_fs_req_cleanup(&close_req);
@@ -4276,7 +4465,7 @@ TEST_IMPL(fs_open_readonly_acl) {
     ASSERT(r >= 0);
     ASSERT(open_req1.result >= 0);
     uv_fs_req_cleanup(&open_req1);
-    r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+    r = uv_fs_close(NULL, &close_req, (uv_os_fd_t) open_req1.result, NULL);
     ASSERT(r == 0);
     ASSERT(close_req.result == 0);
     uv_fs_req_cleanup(&close_req);
@@ -4298,7 +4487,7 @@ TEST_IMPL(fs_open_readonly_acl) {
         goto acl_cleanup;
     }
     uv_fs_req_cleanup(&open_req1);
-    r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);
+    r = uv_fs_close(NULL, &close_req, (uv_os_fd_t) open_req1.result, NULL);
     if (r != 0) {
         goto acl_cleanup;
     }
@@ -4319,7 +4508,7 @@ TEST_IMPL(fs_open_readonly_acl) {
 #ifdef _WIN32
 TEST_IMPL(fs_fchmod_archive_readonly) {
     uv_fs_t req;
-    uv_file file;
+    uv_os_fd_t file;
     int r;
     /* Test clearing read-only flag from files with Archive flag cleared */
 
@@ -4333,7 +4522,7 @@ TEST_IMPL(fs_fchmod_archive_readonly) {
                    NULL);
     ASSERT(r >= 0);
     ASSERT(req.result >= 0);
-    file = req.result;
+    file = (uv_os_fd_t) req.result;
     uv_fs_req_cleanup(&req);
     r = uv_fs_close(NULL, &req, file, NULL);
     ASSERT(r == 0);
@@ -4346,7 +4535,7 @@ TEST_IMPL(fs_fchmod_archive_readonly) {
     r = uv_fs_open(NULL, &req, "test_file", O_RDONLY, 0, NULL);
     ASSERT(r >= 0);
     ASSERT(req.result >= 0);
-    file = req.result;
+    file = (uv_os_fd_t) req.result;
     uv_fs_req_cleanup(&req);
     r = uv_fs_fchmod(NULL, &req, file, S_IWUSR, NULL);
     ASSERT(r == 0);
diff --git a/test/test-get-passwd.c b/test/test-get-passwd.c
index abe8be36..a64f410a 100644
--- a/test/test-get-passwd.c
+++ b/test/test-get-passwd.c
@@ -77,6 +77,7 @@ TEST_IMPL(get_passwd) {
   ASSERT(pwd.username == NULL);
   ASSERT(pwd.shell == NULL);
   ASSERT(pwd.homedir == NULL);
+  ASSERT(pwd.gecos == NULL);
 
   /* Test a double free */
   uv_os_free_passwd(&pwd);
@@ -84,6 +85,7 @@ TEST_IMPL(get_passwd) {
   ASSERT(pwd.username == NULL);
   ASSERT(pwd.shell == NULL);
   ASSERT(pwd.homedir == NULL);
+  ASSERT(pwd.gecos == NULL);
 
   /* Test invalid input */
   r = uv_os_get_passwd(NULL);
diff --git a/test/test-getters-setters.c b/test/test-getters-setters.c
index 42c9dcaf..5836b77e 100644
--- a/test/test-getters-setters.c
+++ b/test/test-getters-setters.c
@@ -92,6 +92,7 @@ TEST_IMPL(getters_setters) {
   r = uv_run(loop, UV_RUN_DEFAULT);
   ASSERT(r == 0);
 
+  ASSERT(uv_req_get_loop((uv_req_t*)fs) == loop);
   ASSERT(uv_fs_get_type(fs) == UV_FS_STAT);
   ASSERT(uv_fs_get_result(fs) == 0);
   ASSERT(uv_fs_get_ptr(fs) == uv_fs_get_statbuf(fs));
diff --git a/test/test-handle-fileno.c b/test/test-handle-fileno.c
index 8a093e2e..ce547d0b 100644
--- a/test/test-handle-fileno.c
+++ b/test/test-handle-fileno.c
@@ -23,20 +23,16 @@
 #include "task.h"
 
 
-static int get_tty_fd(void) {
+static uv_os_fd_t get_tty_fd(void) {
   /* Make sure we have an FD that refers to a tty */
 #ifdef _WIN32
-  HANDLE handle;
-  handle = CreateFileA("conin$",
-                       GENERIC_READ | GENERIC_WRITE,
-                       FILE_SHARE_READ | FILE_SHARE_WRITE,
-                       NULL,
-                       OPEN_EXISTING,
-                       FILE_ATTRIBUTE_NORMAL,
-                       NULL);
-  if (handle == INVALID_HANDLE_VALUE)
-    return -1;
-  return _open_osfhandle((intptr_t) handle, 0);
+  return CreateFileA("conin$",
+                     GENERIC_READ | GENERIC_WRITE,
+                     FILE_SHARE_READ | FILE_SHARE_WRITE,
+                     NULL,
+                     OPEN_EXISTING,
+                     FILE_ATTRIBUTE_NORMAL,
+                     NULL);
 #else /* unix */
   return open("/dev/tty", O_RDONLY, 0);
 #endif
@@ -45,7 +41,7 @@ static int get_tty_fd(void) {
 
 TEST_IMPL(handle_fileno) {
   int r;
-  int tty_fd;
+  uv_os_fd_t tty_fd;
   struct sockaddr_in addr;
   uv_os_fd_t fd;
   uv_tcp_t tcp;
@@ -101,7 +97,7 @@ TEST_IMPL(handle_fileno) {
   ASSERT(r == UV_EBADF);
 
   tty_fd = get_tty_fd();
-  if (tty_fd < 0) {
+  if (tty_fd == (uv_os_fd_t)-1) {
     fprintf(stderr, "Cannot open a TTY fd");
     fflush(stderr);
   } else {
diff --git a/test/test-ip6-addr.c b/test/test-ip6-addr.c
index 39d57065..09ebc44d 100644
--- a/test/test-ip6-addr.c
+++ b/test/test-ip6-addr.c
@@ -161,6 +161,17 @@ TEST_IMPL(ip6_pton) {
 #undef GOOD_ADDR_LIST
 #undef BAD_ADDR_LIST
 
+#ifndef _WIN32
+TEST_IMPL(ip6_invalid_interface) {
+  struct sockaddr_in6 s;
+  int r;
+
+  r = uv_ip6_addr("::0%bad", 0, &s);
+  ASSERT(r < 0);
+  return 0;
+}
+#endif
+
 #ifdef SIN6_LEN
 TEST_IMPL(ip6_sin6_len) {
   struct sockaddr_in6 s;
diff --git a/test/test-ipc-heavy-traffic-deadlock-bug.c b/test/test-ipc-heavy-traffic-deadlock-bug.c
index 753fb7b7..102c652a 100644
--- a/test/test-ipc-heavy-traffic-deadlock-bug.c
+++ b/test/test-ipc-heavy-traffic-deadlock-bug.c
@@ -147,7 +147,7 @@ int ipc_helper_heavy_traffic_deadlock_bug(void) {
 
   r = uv_pipe_init(uv_default_loop(), &pipe, 1);
   ASSERT(r == 0);
-  r = uv_pipe_open(&pipe, 0);
+  r = uv_pipe_open(&pipe, uv_convert_fd_to_handle(0));
   ASSERT(r == 0);
 
   notify_parent_process();
diff --git a/test/test-ipc-send-recv.c b/test/test-ipc-send-recv.c
index 12d4e332..5b0eac9c 100644
--- a/test/test-ipc-send-recv.c
+++ b/test/test-ipc-send-recv.c
@@ -388,7 +388,8 @@ int run_ipc_send_recv_helper(uv_loop_t* loop, int inprocess) {
     r = uv_listen((uv_stream_t*)&ctx2.listen, SOMAXCONN, listen_cb);
     ASSERT(r == 0);
   } else {
-    r = uv_pipe_open(&ctx2.channel, 0);
+    uv_os_fd_t stdin_handle = uv_convert_fd_to_handle(0);
+    r = uv_pipe_open(&ctx2.channel, stdin_handle);
     ASSERT(r == 0);
 
     send_recv_start();
diff --git a/test/test-ipc.c b/test/test-ipc.c
index 39ef4f11..cedfb781 100644
--- a/test/test-ipc.c
+++ b/test/test-ipc.c
@@ -321,9 +321,9 @@ void spawn_helper(uv_pipe_t* channel,
   stdio[0].flags = UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE;
   stdio[0].data.stream = (uv_stream_t*) channel;
   stdio[1].flags = UV_INHERIT_FD;
-  stdio[1].data.fd = 1;
+  stdio[1].data.file = uv_get_osfhandle(1);
   stdio[2].flags = UV_INHERIT_FD;
-  stdio[2].data.fd = 2;
+  stdio[2].data.file = uv_get_osfhandle(2);
 
   r = uv_spawn(uv_default_loop(), process, &options);
   ASSERT_EQ(r, 0);
@@ -733,13 +733,14 @@ int ipc_helper(int listen_after_write) {
   struct sockaddr_in addr;
   int r;
   uv_buf_t buf;
+  uv_os_fd_t stdin_handle = uv_convert_fd_to_handle(0);
 
   ASSERT_EQ(0, uv_ip4_addr("0.0.0.0", TEST_PORT, &addr));
 
   r = uv_pipe_init(uv_default_loop(), &channel, 1);
   ASSERT_EQ(r, 0);
 
-  uv_pipe_open(&channel, 0);
+  uv_pipe_open(&channel, stdin_handle);
 
   ASSERT_EQ(1, uv_is_readable((uv_stream_t*) &channel));
   ASSERT_EQ(1, uv_is_writable((uv_stream_t*) &channel));
@@ -786,11 +787,12 @@ int ipc_helper_tcp_connection(void) {
 
   int r;
   struct sockaddr_in addr;
+  uv_os_fd_t stdin_handle = uv_convert_fd_to_handle(0);
 
   r = uv_pipe_init(uv_default_loop(), &channel, 1);
   ASSERT_EQ(r, 0);
 
-  uv_pipe_open(&channel, 0);
+  uv_pipe_open(&channel, stdin_handle);
 
   ASSERT_EQ(1, uv_is_readable((uv_stream_t*) &channel));
   ASSERT_EQ(1, uv_is_writable((uv_stream_t*) &channel));
@@ -908,13 +910,14 @@ int ipc_helper_bind_twice(void) {
   struct sockaddr_in addr;
   int r;
   uv_buf_t buf;
+  uv_os_fd_t stdin_handle = uv_convert_fd_to_handle(0);
 
   ASSERT_EQ(0, uv_ip4_addr("0.0.0.0", TEST_PORT, &addr));
 
   r = uv_pipe_init(uv_default_loop(), &channel, 1);
   ASSERT_EQ(r, 0);
 
-  uv_pipe_open(&channel, 0);
+  uv_pipe_open(&channel, stdin_handle);
 
   ASSERT_EQ(1, uv_is_readable((uv_stream_t*) &channel));
   ASSERT_EQ(1, uv_is_writable((uv_stream_t*) &channel));
@@ -955,7 +958,7 @@ int ipc_helper_send_zero(void) {
   r = uv_pipe_init(uv_default_loop(), &channel, 0);
   ASSERT_EQ(r, 0);
 
-  uv_pipe_open(&channel, 0);
+  uv_pipe_open(&channel, UV_STDIN_FD);
 
   ASSERT_EQ(1, uv_is_readable((uv_stream_t*) &channel));
   ASSERT_EQ(1, uv_is_writable((uv_stream_t*) &channel));
diff --git a/test/test-list.h b/test/test-list.h
index 52b17a69..136b03a9 100644
--- a/test/test-list.h
+++ b/test/test-list.h
@@ -37,6 +37,7 @@ TEST_DECLARE   (default_loop_close)
 TEST_DECLARE   (barrier_1)
 TEST_DECLARE   (barrier_2)
 TEST_DECLARE   (barrier_3)
+TEST_DECLARE   (buf_large)
 TEST_DECLARE   (barrier_serial_thread)
 TEST_DECLARE   (barrier_serial_thread_single)
 TEST_DECLARE   (condvar_1)
@@ -78,6 +79,9 @@ TEST_DECLARE   (tty_pty)
 TEST_DECLARE   (stdio_over_pipes)
 TEST_DECLARE   (stdio_emulate_iocp)
 TEST_DECLARE   (ip6_pton)
+#ifndef _WIN32
+TEST_DECLARE   (ip6_invalid_interface)
+#endif
 TEST_DECLARE   (connect_unspecified)
 TEST_DECLARE   (ipc_heavy_traffic_deadlock_bug)
 TEST_DECLARE   (ipc_listen_before_write)
@@ -189,10 +193,16 @@ TEST_DECLARE   (udp_try_send)
 TEST_DECLARE   (pipe_bind_error_addrinuse)
 TEST_DECLARE   (pipe_bind_error_addrnotavail)
 TEST_DECLARE   (pipe_bind_error_inval)
+#ifndef _WIN32
+TEST_DECLARE   (pipe_bind_error_long_path)
+#endif
 TEST_DECLARE   (pipe_connect_multiple)
 TEST_DECLARE   (pipe_listen_without_bind)
 TEST_DECLARE   (pipe_connect_bad_name)
 TEST_DECLARE   (pipe_connect_to_file)
+#ifndef _WIN32
+TEST_DECLARE   (pipe_connect_to_long_path)
+#endif
 TEST_DECLARE   (pipe_connect_on_prepare)
 TEST_DECLARE   (pipe_getsockname)
 TEST_DECLARE   (pipe_getsockname_abstract)
@@ -260,6 +270,7 @@ TEST_DECLARE   (has_ref)
 TEST_DECLARE   (active)
 TEST_DECLARE   (embed)
 TEST_DECLARE   (async)
+TEST_DECLARE   (async_multi)
 TEST_DECLARE   (async_null_cb)
 TEST_DECLARE   (eintr_handling)
 TEST_DECLARE   (get_currentexe)
@@ -306,6 +317,8 @@ TEST_DECLARE   (spawn_and_ping)
 TEST_DECLARE   (spawn_preserve_env)
 TEST_DECLARE   (spawn_setuid_fails)
 TEST_DECLARE   (spawn_setgid_fails)
+TEST_DECLARE   (spawn_affinity)
+TEST_DECLARE   (spawn_affinity_invalid_mask)
 TEST_DECLARE   (spawn_stdout_to_file)
 TEST_DECLARE   (spawn_stdout_and_stderr_to_file)
 TEST_DECLARE   (spawn_stdout_and_stderr_to_file2)
@@ -359,7 +372,9 @@ TEST_DECLARE   (fs_open_flags)
 TEST_DECLARE   (fs_fd_hash)
 #endif
 TEST_DECLARE   (fs_utime)
+TEST_DECLARE   (fs_utime_ex)
 TEST_DECLARE   (fs_futime)
+TEST_DECLARE   (fs_futime_ex)
 TEST_DECLARE   (fs_lutime)
 TEST_DECLARE   (fs_file_open_append)
 TEST_DECLARE   (fs_statfs)
@@ -398,8 +413,9 @@ TEST_DECLARE   (fs_readdir_non_existing_dir)
 TEST_DECLARE   (fs_rename_to_existing_file)
 TEST_DECLARE   (fs_write_multiple_bufs)
 TEST_DECLARE   (fs_read_write_null_arguments)
-TEST_DECLARE   (get_osfhandle_valid_handle)
-TEST_DECLARE   (open_osfhandle_valid_handle)
+#ifdef _WIN32
+TEST_DECLARE   (fs_invalid_filename)
+#endif
 TEST_DECLARE   (fs_write_alotof_bufs)
 TEST_DECLARE   (fs_write_alotof_bufs_with_offset)
 TEST_DECLARE   (fs_partial_read)
@@ -436,6 +452,7 @@ TEST_DECLARE   (thread_rwlock)
 TEST_DECLARE   (thread_rwlock_trylock)
 TEST_DECLARE   (thread_create)
 TEST_DECLARE   (thread_equal)
+TEST_DECLARE   (thread_affinity)
 TEST_DECLARE   (dlerror)
 #if (defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))) && \
     !defined(__sun)
@@ -457,6 +474,9 @@ TEST_DECLARE   (ip6_addr_link_local)
 
 TEST_DECLARE   (poll_close_doesnt_corrupt_stack)
 TEST_DECLARE   (poll_closesocket)
+TEST_DECLARE   (close_fd)
+TEST_DECLARE   (closed_fd_events)
+TEST_DECLARE   (spawn_fs_open)
 #ifdef _WIN32
 TEST_DECLARE   (spawn_detect_pipe_name_collisions_on_windows)
 #if !defined(USING_UV_SHARED)
@@ -471,8 +491,6 @@ TEST_DECLARE   (ipc_listen_after_bind_twice)
 TEST_DECLARE   (win32_signum_number)
 #else
 TEST_DECLARE   (emfile)
-TEST_DECLARE   (close_fd)
-TEST_DECLARE   (spawn_fs_open)
 TEST_DECLARE   (spawn_setuid_setgid)
 TEST_DECLARE   (we_get_signal)
 TEST_DECLARE   (we_get_signals)
@@ -481,7 +499,6 @@ TEST_DECLARE   (we_get_signals_mixed)
 TEST_DECLARE   (signal_multiple_loops)
 TEST_DECLARE   (signal_pending_on_close)
 TEST_DECLARE   (signal_close_loop_alive)
-TEST_DECLARE   (closed_fd_events)
 #endif
 #ifdef __APPLE__
 TEST_DECLARE   (osx_select)
@@ -501,24 +518,6 @@ TEST_DECLARE   (handle_type_name)
 TEST_DECLARE   (req_type_name)
 TEST_DECLARE   (getters_setters)
 
-#ifndef _WIN32
-TEST_DECLARE  (fork_timer)
-TEST_DECLARE  (fork_socketpair)
-TEST_DECLARE  (fork_socketpair_started)
-TEST_DECLARE  (fork_signal_to_child)
-TEST_DECLARE  (fork_signal_to_child_closed)
-#ifndef __APPLE__ /* This is forbidden in a fork child: The process has forked
-                     and you cannot use this CoreFoundation functionality
-                     safely. You MUST exec(). */
-TEST_DECLARE  (fork_fs_events_child)
-TEST_DECLARE  (fork_fs_events_child_dir)
-TEST_DECLARE  (fork_fs_events_file_parent_child)
-#endif
-#ifndef __MVS__
-TEST_DECLARE  (fork_threadpool_queue_work_simple)
-#endif
-#endif
-
 TEST_DECLARE  (idna_toascii)
 TEST_DECLARE  (utf8_decode1)
 TEST_DECLARE  (uname)
@@ -548,6 +547,7 @@ TASK_LIST_START
   TEST_ENTRY  (barrier_1)
   TEST_ENTRY  (barrier_2)
   TEST_ENTRY  (barrier_3)
+  TEST_ENTRY  (buf_large)
   TEST_ENTRY  (barrier_serial_thread)
   TEST_ENTRY  (barrier_serial_thread_single)
   TEST_ENTRY  (condvar_1)
@@ -561,13 +561,17 @@ TASK_LIST_START
 
   TEST_ENTRY  (pipe_connect_bad_name)
   TEST_ENTRY  (pipe_connect_to_file)
+#ifndef _WIN32
+  TEST_ENTRY  (pipe_connect_to_long_path)
+#endif
   TEST_ENTRY  (pipe_connect_on_prepare)
 
   TEST_ENTRY  (pipe_server_close)
 #ifndef _WIN32
   TEST_ENTRY  (pipe_close_stdout_read_stdin)
 #endif
-  TEST_ENTRY  (pipe_set_non_blocking)
+  /* Seems to be either about 0.5s or 5s, depending on the OS. */
+  TEST_ENTRY_CUSTOM (pipe_set_non_blocking, 0, 0, 20000)
   TEST_ENTRY  (pipe_set_chmod)
   TEST_ENTRY  (tty)
 #ifdef _WIN32
@@ -600,6 +604,9 @@ TASK_LIST_START
   TEST_ENTRY  (stdio_over_pipes)
   TEST_ENTRY  (stdio_emulate_iocp)
   TEST_ENTRY  (ip6_pton)
+#ifndef _WIN32
+  TEST_ENTRY  (ip6_invalid_interface)
+#endif
   TEST_ENTRY  (connect_unspecified)
   TEST_ENTRY  (ipc_heavy_traffic_deadlock_bug)
   TEST_ENTRY  (ipc_listen_before_write)
@@ -750,6 +757,9 @@ TASK_LIST_START
   TEST_ENTRY  (pipe_bind_error_addrinuse)
   TEST_ENTRY  (pipe_bind_error_addrnotavail)
   TEST_ENTRY  (pipe_bind_error_inval)
+#ifndef _WIN32
+  TEST_ENTRY  (pipe_bind_error_long_path)
+#endif
   TEST_ENTRY  (pipe_connect_multiple)
   TEST_ENTRY  (pipe_listen_without_bind)
   TEST_ENTRY  (pipe_getsockname)
@@ -836,6 +846,7 @@ TASK_LIST_START
   TEST_ENTRY  (embed)
 
   TEST_ENTRY  (async)
+  TEST_ENTRY  (async_multi)
   TEST_ENTRY  (async_null_cb)
   TEST_ENTRY  (eintr_handling)
 
@@ -914,6 +925,8 @@ TASK_LIST_START
   TEST_ENTRY  (spawn_preserve_env)
   TEST_ENTRY  (spawn_setuid_fails)
   TEST_ENTRY  (spawn_setgid_fails)
+  TEST_ENTRY  (spawn_affinity)
+  TEST_ENTRY  (spawn_affinity_invalid_mask)
   TEST_ENTRY  (spawn_stdout_to_file)
   TEST_ENTRY  (spawn_stdout_and_stderr_to_file)
   TEST_ENTRY  (spawn_stdout_and_stderr_to_file2)
@@ -935,6 +948,9 @@ TASK_LIST_START
 
   TEST_ENTRY  (poll_close_doesnt_corrupt_stack)
   TEST_ENTRY  (poll_closesocket)
+  TEST_ENTRY  (close_fd)
+  TEST_ENTRY  (closed_fd_events)
+  TEST_ENTRY  (spawn_fs_open)
 #ifdef _WIN32
   TEST_ENTRY  (spawn_detect_pipe_name_collisions_on_windows)
 #if !defined(USING_UV_SHARED)
@@ -949,8 +965,6 @@ TASK_LIST_START
   TEST_ENTRY  (win32_signum_number)
 #else
   TEST_ENTRY  (emfile)
-  TEST_ENTRY  (close_fd)
-  TEST_ENTRY  (spawn_fs_open)
   TEST_ENTRY  (spawn_setuid_setgid)
   TEST_ENTRY  (we_get_signal)
   TEST_ENTRY  (we_get_signals)
@@ -959,7 +973,6 @@ TASK_LIST_START
   TEST_ENTRY  (signal_multiple_loops)
   TEST_ENTRY  (signal_pending_on_close)
   TEST_ENTRY  (signal_close_loop_alive)
-  TEST_ENTRY  (closed_fd_events)
 #endif
 
 #ifdef __APPLE__
@@ -988,7 +1001,9 @@ TASK_LIST_START
 #endif
   TEST_ENTRY  (fs_chown)
   TEST_ENTRY  (fs_utime)
+  TEST_ENTRY  (fs_utime_ex)
   TEST_ENTRY  (fs_futime)
+  TEST_ENTRY  (fs_futime_ex)
   TEST_ENTRY  (fs_lutime)
   TEST_ENTRY  (fs_readlink)
   TEST_ENTRY  (fs_realpath)
@@ -1044,6 +1059,9 @@ TASK_LIST_START
   TEST_ENTRY  (fs_partial_read)
   TEST_ENTRY  (fs_partial_write)
   TEST_ENTRY  (fs_read_write_null_arguments)
+#ifdef _WIN32
+  TEST_ENTRY  (fs_invalid_filename)
+#endif
   TEST_ENTRY  (fs_file_pos_after_op_with_offset)
   TEST_ENTRY  (fs_null_req)
   TEST_ENTRY  (fs_read_dir)
@@ -1057,8 +1075,6 @@ TASK_LIST_START
   TEST_ENTRY  (fs_invalid_mkdir_name)
 #endif
   TEST_ENTRY  (fs_get_system_error)
-  TEST_ENTRY  (get_osfhandle_valid_handle)
-  TEST_ENTRY  (open_osfhandle_valid_handle)
   TEST_ENTRY  (strscpy)
   TEST_ENTRY  (threadpool_queue_work_simple)
   TEST_ENTRY  (threadpool_queue_work_einval)
@@ -1078,6 +1094,7 @@ TASK_LIST_START
   TEST_ENTRY  (thread_rwlock_trylock)
   TEST_ENTRY  (thread_create)
   TEST_ENTRY  (thread_equal)
+  TEST_ENTRY  (thread_affinity)
   TEST_ENTRY  (dlerror)
   TEST_ENTRY  (ip4_addr)
   TEST_ENTRY  (ip6_addr_link_local)
@@ -1091,22 +1108,6 @@ TASK_LIST_START
   TEST_ENTRY  (req_type_name)
   TEST_ENTRY  (getters_setters)
 
-#ifndef _WIN32
-  TEST_ENTRY  (fork_timer)
-  TEST_ENTRY  (fork_socketpair)
-  TEST_ENTRY  (fork_socketpair_started)
-  TEST_ENTRY  (fork_signal_to_child)
-  TEST_ENTRY  (fork_signal_to_child_closed)
-#ifndef __APPLE__
-  TEST_ENTRY  (fork_fs_events_child)
-  TEST_ENTRY  (fork_fs_events_child_dir)
-  TEST_ENTRY  (fork_fs_events_file_parent_child)
-#endif
-#ifndef __MVS__
-  TEST_ENTRY  (fork_threadpool_queue_work_simple)
-#endif
-#endif
-
   TEST_ENTRY  (utf8_decode1)
   TEST_ENTRY  (uname)
 
diff --git a/test/test-loop-handles.c b/test/test-loop-handles.c
index 13109880..45d969dc 100644
--- a/test/test-loop-handles.c
+++ b/test/test-loop-handles.c
@@ -284,6 +284,8 @@ TEST_IMPL(loop_handles) {
 
   r = uv_prepare_init(uv_default_loop(), &prepare_1_handle);
   ASSERT(r == 0);
+  r = uv_prepare_start(&prepare_1_handle, NULL);
+  ASSERT(r == UV_EINVAL);
   r = uv_prepare_start(&prepare_1_handle, prepare_1_cb);
   ASSERT(r == 0);
 
diff --git a/test/test-ping-pong.c b/test/test-ping-pong.c
index 7f7758b3..b0738177 100644
--- a/test/test-ping-pong.c
+++ b/test/test-ping-pong.c
@@ -24,6 +24,7 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h> /* strlen */
 
 static int completed_pingers = 0;
 
@@ -33,23 +34,21 @@ static int completed_pingers = 0;
 #define NUM_PINGS 1000
 #endif
 
-/* 64 bytes is enough for a pinger */
-#define BUFSIZE 10240
-
 static char PING[] = "PING\n";
+static char PONG[] = "PONG\n";
 static int pinger_on_connect_count;
 
 
 typedef struct {
   int vectored_writes;
-  int pongs;
-  int state;
+  unsigned pongs;
+  unsigned state;
   union {
     uv_tcp_t tcp;
     uv_pipe_t pipe;
   } stream;
   uv_connect_t connect_req;
-  char read_buffer[BUFSIZE];
+  char* pong;
 } pinger_t;
 
 
@@ -59,28 +58,44 @@ static void alloc_cb(uv_handle_t* handle, size_t size, uv_buf_t* buf) {
 }
 
 
+static void ponger_on_close(uv_handle_t* handle) {
+  if (handle->data)
+    free(handle->data);
+  else
+    free(handle);
+}
+
+
 static void pinger_on_close(uv_handle_t* handle) {
-  pinger_t* pinger = (pinger_t*)handle->data;
+  pinger_t* pinger = (pinger_t*) handle->data;
 
-  ASSERT(NUM_PINGS == pinger->pongs);
+  ASSERT_EQ(NUM_PINGS, pinger->pongs);
 
-  free(pinger);
+  if (handle == (uv_handle_t*) &pinger->stream.tcp) {
+    free(pinger); /* also frees handle */
+  } else {
+    uv_close((uv_handle_t*) &pinger->stream.tcp, ponger_on_close);
+    free(handle);
+  }
 
   completed_pingers++;
 }
 
 
 static void pinger_after_write(uv_write_t* req, int status) {
-  ASSERT(status == 0);
+  ASSERT_EQ(status, 0);
   free(req);
 }
 
 
 static void pinger_write_ping(pinger_t* pinger) {
+  uv_stream_t* stream;
   uv_write_t* req;
   uv_buf_t bufs[sizeof PING - 1];
   int i, nbufs;
 
+  stream = (uv_stream_t*) &pinger->stream.tcp;
+
   if (!pinger->vectored_writes) {
     /* Write a single buffer. */
     nbufs = 1;
@@ -94,13 +109,8 @@ static void pinger_write_ping(pinger_t* pinger) {
   }
 
   req = malloc(sizeof(*req));
-  if (uv_write(req,
-               (uv_stream_t*) &pinger->stream.tcp,
-               bufs,
-               nbufs,
-               pinger_after_write)) {
-    FATAL("uv_write failed");
-  }
+  ASSERT_NOT_NULL(req);
+  ASSERT_EQ(0, uv_write(req, stream, bufs, nbufs, pinger_after_write));
 
   puts("PING");
 }
@@ -115,20 +125,20 @@ static void pinger_read_cb(uv_stream_t* stream,
   pinger = (pinger_t*) stream->data;
 
   if (nread < 0) {
-    ASSERT(nread == UV_EOF);
+    ASSERT_EQ(nread, UV_EOF);
 
     puts("got EOF");
     free(buf->base);
 
-    uv_close((uv_handle_t*)(&pinger->stream.tcp), pinger_on_close);
+    uv_close((uv_handle_t*) stream, pinger_on_close);
 
     return;
   }
 
-  /* Now we count the pings */
+  /* Now we count the pongs */
   for (i = 0; i < nread; i++) {
-    ASSERT(buf->base[i] == PING[pinger->state]);
-    pinger->state = (pinger->state + 1) % (sizeof(PING) - 1);
+    ASSERT_EQ(buf->base[i], pinger->pong[pinger->state]);
+    pinger->state = (pinger->state + 1) % strlen(pinger->pong);
 
     if (pinger->state != 0)
       continue;
@@ -139,7 +149,7 @@ static void pinger_read_cb(uv_stream_t* stream,
     if (pinger->pongs < NUM_PINGS) {
       pinger_write_ping(pinger);
     } else {
-      uv_close((uv_handle_t*)(&pinger->stream.tcp), pinger_on_close);
+      uv_close((uv_handle_t*) stream, pinger_on_close);
       break;
     }
   }
@@ -148,20 +158,53 @@ static void pinger_read_cb(uv_stream_t* stream,
 }
 
 
+static void ponger_read_cb(uv_stream_t* stream,
+                           ssize_t nread,
+                           const uv_buf_t* buf) {
+  uv_buf_t writebuf;
+  uv_write_t* req;
+  int i;
+
+  if (nread < 0) {
+    ASSERT_EQ(nread, UV_EOF);
+
+    puts("got EOF");
+    free(buf->base);
+
+    uv_close((uv_handle_t*) stream, ponger_on_close);
+
+    return;
+  }
+
+  /* Echo back */
+  for (i = 0; i < nread; i++) {
+    if (buf->base[i] == 'I')
+      buf->base[i] = 'O';
+  }
+
+  writebuf = uv_buf_init(buf->base, nread);
+  req = malloc(sizeof(*req));
+  ASSERT_NOT_NULL(req);
+  ASSERT_EQ(0, uv_write(req, stream, &writebuf, 1, pinger_after_write));
+}
+
+
 static void pinger_on_connect(uv_connect_t* req, int status) {
-  pinger_t* pinger = (pinger_t*)req->handle->data;
+  pinger_t* pinger = (pinger_t*) req->handle->data;
 
   pinger_on_connect_count++;
 
-  ASSERT(status == 0);
+  ASSERT_EQ(status, 0);
 
-  ASSERT(1 == uv_is_readable(req->handle));
-  ASSERT(1 == uv_is_writable(req->handle));
-  ASSERT(0 == uv_is_closing((uv_handle_t *) req->handle));
+  ASSERT_EQ(1, uv_is_readable(req->handle));
+  ASSERT_EQ(1, uv_is_writable(req->handle));
+  ASSERT_EQ(0, uv_is_closing((uv_handle_t *) req->handle));
 
   pinger_write_ping(pinger);
 
-  uv_read_start((uv_stream_t*)(req->handle), alloc_cb, pinger_read_cb);
+  ASSERT_EQ(0, uv_read_start((uv_stream_t*) req->handle,
+                             alloc_cb,
+                             pinger_read_cb));
 }
 
 
@@ -172,17 +215,18 @@ static void tcp_pinger_v6_new(int vectored_writes) {
   pinger_t* pinger;
 
 
-  ASSERT(0 == uv_ip6_addr("::1", TEST_PORT, &server_addr));
+  ASSERT_EQ(0, uv_ip6_addr("::1", TEST_PORT, &server_addr));
   pinger = malloc(sizeof(*pinger));
-  ASSERT(pinger != NULL);
+  ASSERT_NOT_NULL(pinger);
   pinger->vectored_writes = vectored_writes;
   pinger->state = 0;
   pinger->pongs = 0;
+  pinger->pong = PING;
 
   /* Try to connect to the server and do NUM_PINGS ping-pongs. */
   r = uv_tcp_init(uv_default_loop(), &pinger->stream.tcp);
   pinger->stream.tcp.data = pinger;
-  ASSERT(!r);
+  ASSERT_EQ(0, r);
 
   /* We are never doing multiple reads/connects at a time anyway, so these
    * handles can be pre-initialized. */
@@ -190,10 +234,10 @@ static void tcp_pinger_v6_new(int vectored_writes) {
                      &pinger->stream.tcp,
                      (const struct sockaddr*) &server_addr,
                      pinger_on_connect);
-  ASSERT(!r);
+  ASSERT_EQ(0, r);
 
   /* Synchronous connect callbacks are not allowed. */
-  ASSERT(pinger_on_connect_count == 0);
+  ASSERT_EQ(pinger_on_connect_count, 0);
 }
 
 
@@ -202,17 +246,18 @@ static void tcp_pinger_new(int vectored_writes) {
   struct sockaddr_in server_addr;
   pinger_t* pinger;
 
-  ASSERT(0 == uv_ip4_addr("127.0.0.1", TEST_PORT, &server_addr));
+  ASSERT_EQ(0, uv_ip4_addr("127.0.0.1", TEST_PORT, &server_addr));
   pinger = malloc(sizeof(*pinger));
-  ASSERT(pinger != NULL);
+  ASSERT_NOT_NULL(pinger);
   pinger->vectored_writes = vectored_writes;
   pinger->state = 0;
   pinger->pongs = 0;
+  pinger->pong = PING;
 
   /* Try to connect to the server and do NUM_PINGS ping-pongs. */
   r = uv_tcp_init(uv_default_loop(), &pinger->stream.tcp);
   pinger->stream.tcp.data = pinger;
-  ASSERT(!r);
+  ASSERT_EQ(0, r);
 
   /* We are never doing multiple reads/connects at a time anyway, so these
    * handles can be pre-initialized. */
@@ -220,10 +265,10 @@ static void tcp_pinger_new(int vectored_writes) {
                      &pinger->stream.tcp,
                      (const struct sockaddr*) &server_addr,
                      pinger_on_connect);
-  ASSERT(!r);
+  ASSERT_EQ(0, r);
 
   /* Synchronous connect callbacks are not allowed. */
-  ASSERT(pinger_on_connect_count == 0);
+  ASSERT_EQ(pinger_on_connect_count, 0);
 }
 
 
@@ -232,15 +277,16 @@ static void pipe_pinger_new(int vectored_writes) {
   pinger_t* pinger;
 
   pinger = malloc(sizeof(*pinger));
-  ASSERT(pinger != NULL);
+  ASSERT_NOT_NULL(pinger);
   pinger->vectored_writes = vectored_writes;
   pinger->state = 0;
   pinger->pongs = 0;
+  pinger->pong = PING;
 
   /* Try to connect to the server and do NUM_PINGS ping-pongs. */
   r = uv_pipe_init(uv_default_loop(), &pinger->stream.pipe, 0);
   pinger->stream.pipe.data = pinger;
-  ASSERT(!r);
+  ASSERT_EQ(0, r);
 
   /* We are never doing multiple reads/connects at a time anyway, so these
    * handles can be pre-initialized. */
@@ -248,13 +294,86 @@ static void pipe_pinger_new(int vectored_writes) {
       pinger_on_connect);
 
   /* Synchronous connect callbacks are not allowed. */
-  ASSERT(pinger_on_connect_count == 0);
+  ASSERT_EQ(pinger_on_connect_count, 0);
 }
 
 
+static void socketpair_pinger_new(int vectored_writes) {
+  pinger_t* pinger;
+  uv_os_sock_t fds[2];
+  uv_tcp_t* ponger;
+
+  pinger = malloc(sizeof(*pinger));
+  ASSERT_NOT_NULL(pinger);
+  pinger->vectored_writes = vectored_writes;
+  pinger->state = 0;
+  pinger->pongs = 0;
+  pinger->pong = PONG;
+
+  /* Try to make a socketpair and do NUM_PINGS ping-pongs. */
+  (void)uv_default_loop(); /* ensure WSAStartup has been performed */
+  ASSERT_EQ(0, uv_socketpair(SOCK_STREAM, 0, fds, UV_NONBLOCK_PIPE, UV_NONBLOCK_PIPE));
+#ifndef _WIN32
+  /* On Windows, this is actually a UV_TCP, but libuv doesn't detect that. */
+  ASSERT_EQ(uv_guess_handle((uv_os_fd_t) fds[0]), UV_NAMED_PIPE);
+  ASSERT_EQ(uv_guess_handle((uv_os_fd_t) fds[1]), UV_NAMED_PIPE);
+#endif
+
+  ASSERT_EQ(0, uv_tcp_init(uv_default_loop(), &pinger->stream.tcp));
+  pinger->stream.pipe.data = pinger;
+  ASSERT_EQ(0, uv_tcp_open(&pinger->stream.tcp, fds[1]));
+
+  ponger = malloc(sizeof(*ponger));
+  ASSERT_NOT_NULL(ponger);
+  ponger->data = NULL;
+  ASSERT_EQ(0, uv_tcp_init(uv_default_loop(), ponger));
+  ASSERT_EQ(0, uv_tcp_open(ponger, fds[0]));
+
+  pinger_write_ping(pinger);
+
+  ASSERT_EQ(0, uv_read_start((uv_stream_t*) &pinger->stream.tcp,
+                             alloc_cb,
+                             pinger_read_cb));
+  ASSERT_EQ(0, uv_read_start((uv_stream_t*) ponger,
+                             alloc_cb,
+                             ponger_read_cb));
+}
+
+
+static void pipe2_pinger_new(int vectored_writes) {
+  uv_os_fd_t fds[2];
+  pinger_t* pinger;
+  uv_pipe_t* ponger;
+
+  /* Try to make a pipe and do NUM_PINGS pings. */
+  ASSERT_EQ(0, uv_pipe(fds, UV_NONBLOCK_PIPE, UV_NONBLOCK_PIPE));
+  ASSERT_EQ(uv_guess_handle(fds[0]), UV_NAMED_PIPE);
+  ASSERT_EQ(uv_guess_handle(fds[1]), UV_NAMED_PIPE);
+
+  ponger = malloc(sizeof(*ponger));
+  ASSERT_NOT_NULL(ponger);
+  ASSERT_EQ(0, uv_pipe_init(uv_default_loop(), ponger, 0));
+  ASSERT_EQ(0, uv_pipe_open(ponger, fds[0]));
+
+  pinger = malloc(sizeof(*pinger));
+  ASSERT_NOT_NULL(pinger);
+  pinger->vectored_writes = vectored_writes;
+  pinger->state = 0;
+  pinger->pongs = 0;
+  pinger->pong = PING;
+  ASSERT_EQ(0, uv_pipe_init(uv_default_loop(), &pinger->stream.pipe, 0));
+  ASSERT_EQ(0, uv_pipe_open(&pinger->stream.pipe, fds[1]));
+  pinger->stream.pipe.data = pinger; /* record for close_cb */
+  ponger->data = pinger; /* record for read_cb */
+
+  pinger_write_ping(pinger);
+
+  ASSERT_EQ(0, uv_read_start((uv_stream_t*) ponger, alloc_cb, pinger_read_cb));
+}
+
 static int run_ping_pong_test(void) {
   uv_run(uv_default_loop(), UV_RUN_DEFAULT);
-  ASSERT(completed_pingers == 1);
+  ASSERT_EQ(completed_pingers, 1);
 
   MAKE_VALGRIND_HAPPY();
   return 0;
@@ -263,12 +382,20 @@ static int run_ping_pong_test(void) {
 
 TEST_IMPL(tcp_ping_pong) {
   tcp_pinger_new(0);
+  run_ping_pong_test();
+
+  completed_pingers = 0;
+  socketpair_pinger_new(0);
   return run_ping_pong_test();
 }
 
 
 TEST_IMPL(tcp_ping_pong_vec) {
   tcp_pinger_new(1);
+  run_ping_pong_test();
+
+  completed_pingers = 0;
+  socketpair_pinger_new(1);
   return run_ping_pong_test();
 }
 
@@ -291,11 +418,19 @@ TEST_IMPL(tcp6_ping_pong_vec) {
 
 TEST_IMPL(pipe_ping_pong) {
   pipe_pinger_new(0);
+  run_ping_pong_test();
+
+  completed_pingers = 0;
+  pipe2_pinger_new(0);
   return run_ping_pong_test();
 }
 
 
 TEST_IMPL(pipe_ping_pong_vec) {
   pipe_pinger_new(1);
+  run_ping_pong_test();
+
+  completed_pingers = 0;
+  pipe2_pinger_new(1);
   return run_ping_pong_test();
 }
diff --git a/test/test-pipe-bind-error.c b/test/test-pipe-bind-error.c
index 9cf93165..f3427749 100644
--- a/test/test-pipe-bind-error.c
+++ b/test/test-pipe-bind-error.c
@@ -23,6 +23,7 @@
 #include "task.h"
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 
 
 #ifdef _WIN32
@@ -137,3 +138,27 @@ TEST_IMPL(pipe_listen_without_bind) {
   MAKE_VALGRIND_HAPPY();
   return 0;
 }
+
+
+TEST_IMPL(pipe_bind_error_long_path) {
+  char path[2048];
+  uv_pipe_t server;
+  int r;
+
+  memset(path, '.', sizeof(path) - 1);
+  path[sizeof(path) - 1] = '\0';
+
+  r = uv_pipe_init(uv_default_loop(), &server, 0);
+  ASSERT(r == 0);
+  r = uv_pipe_bind(&server, path);
+  ASSERT(r == UV_ENAMETOOLONG);
+
+  uv_close((uv_handle_t*)&server, close_cb);
+
+  uv_run(uv_default_loop(), UV_RUN_DEFAULT);
+
+  ASSERT(close_cb_called == 1);
+
+  MAKE_VALGRIND_HAPPY();
+  return 0;
+}
diff --git a/test/test-pipe-connect-error.c b/test/test-pipe-connect-error.c
index ebb2a6ca..bf1896a8 100644
--- a/test/test-pipe-connect-error.c
+++ b/test/test-pipe-connect-error.c
@@ -23,6 +23,7 @@
 #include "task.h"
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 
 
 #ifdef _WIN32
@@ -56,6 +57,13 @@ static void connect_cb_file(uv_connect_t* connect_req, int status) {
 }
 
 
+static void connect_cb_long_path(uv_connect_t* connect_req, int status) {
+  ASSERT(status == UV_ENAMETOOLONG);
+  uv_close((uv_handle_t*)connect_req->handle, close_cb);
+  connect_cb_called++;
+}
+
+
 TEST_IMPL(pipe_connect_bad_name) {
   uv_pipe_t client;
   uv_connect_t req;
@@ -93,3 +101,26 @@ TEST_IMPL(pipe_connect_to_file) {
   MAKE_VALGRIND_HAPPY();
   return 0;
 }
+
+
+TEST_IMPL(pipe_connect_to_long_path) {
+  char path[2048];
+  uv_pipe_t client;
+  uv_connect_t req;
+  int r;
+
+  memset(path, '.', sizeof(path) - 1);
+  path[sizeof(path) - 1] = '\0';
+
+  r = uv_pipe_init(uv_default_loop(), &client, 0);
+  ASSERT(r == 0);
+  uv_pipe_connect(&req, &client, path, connect_cb_long_path);
+
+  uv_run(uv_default_loop(), UV_RUN_DEFAULT);
+
+  ASSERT(close_cb_called == 1);
+  ASSERT(connect_cb_called == 1);
+
+  MAKE_VALGRIND_HAPPY();
+  return 0;
+}
diff --git a/test/test-pipe-getsockname.c b/test/test-pipe-getsockname.c
index 48ee400e..748aeea2 100644
--- a/test/test-pipe-getsockname.c
+++ b/test/test-pipe-getsockname.c
@@ -211,7 +211,6 @@ TEST_IMPL(pipe_getsockname_abstract) {
 TEST_IMPL(pipe_getsockname_blocking) {
 #ifdef _WIN32
   HANDLE readh, writeh;
-  int readfd;
   char buf1[1024], buf2[1024];
   size_t len1, len2;
   int r;
@@ -221,9 +220,7 @@ TEST_IMPL(pipe_getsockname_blocking) {
 
   r = uv_pipe_init(uv_default_loop(), &pipe_client, 0);
   ASSERT(r == 0);
-  readfd = _open_osfhandle((intptr_t)readh, _O_RDONLY);
-  ASSERT(r != -1);
-  r = uv_pipe_open(&pipe_client, readfd);
+  r = uv_pipe_open(&pipe_client, readh);
   ASSERT(r == 0);
   r = uv_read_start((uv_stream_t*)&pipe_client, NULL, NULL);
   ASSERT(r == 0);
diff --git a/test/test-pipe-set-non-blocking.c b/test/test-pipe-set-non-blocking.c
index 626b53f0..b5561f33 100644
--- a/test/test-pipe-set-non-blocking.c
+++ b/test/test-pipe-set-non-blocking.c
@@ -16,22 +16,14 @@
 #include "uv.h"
 #include "task.h"
 
-#ifdef _WIN32
-
-TEST_IMPL(pipe_set_non_blocking) {
-  RETURN_SKIP("Test not implemented on Windows.");
-}
-
-#else  /* !_WIN32 */
-
 #include <string.h> /* memset */
+#ifndef _WIN32
 #include <unistd.h> /* close */
-#include <sys/types.h>
-#include <sys/socket.h>
+#endif
 
 struct thread_ctx {
   uv_barrier_t barrier;
-  uv_file fd;
+  uv_os_fd_t fd;
 };
 
 static void thread_main(void* arg) {
@@ -54,9 +46,28 @@ static void thread_main(void* arg) {
     uv_fs_req_cleanup(&req);
   } while (n > 0 || (n == -1 && uv_errno == UV_EINTR));
 
+#ifdef _WIN32
+  ASSERT(n == UV_EOF);
+#else
   ASSERT(n == 0);
+#endif
 }
 
+
+#ifdef _WIN32
+static void write_cb(uv_write_t* req, int status) {
+  ASSERT(status == 0);
+  req->handle = NULL; /* signal completion of write_cb */
+}
+#endif
+
+#ifdef _WIN32
+#define NWRITES (10 << 16)
+#else
+#define NWRITES (10 << 20)
+#endif
+
+
 TEST_IMPL(pipe_set_non_blocking) {
   struct thread_ctx ctx;
   uv_pipe_t pipe_handle;
@@ -64,14 +75,22 @@ TEST_IMPL(pipe_set_non_blocking) {
   size_t nwritten;
   char data[4096];
   uv_buf_t buf;
-  uv_file fd[2];
+  uv_os_fd_t fd[2];
   int n;
+#ifdef _WIN32
+  uv_write_t write_req;
+#endif
 
   ASSERT(0 == uv_pipe_init(uv_default_loop(), &pipe_handle, 0));
-  ASSERT(0 == socketpair(AF_UNIX, SOCK_STREAM, 0, fd));
+  ASSERT(0 == uv_pipe(fd, 0, 0));
   ASSERT(0 == uv_pipe_open(&pipe_handle, fd[1]));
   ASSERT(0 == uv_stream_set_blocking((uv_stream_t*) &pipe_handle, 1));
-  fd[1] = -1; /* fd[1] is owned by pipe_handle now. */
+  /* fd[1] is owned by pipe_handle now. */
+#ifdef _WIN32
+  fd[1] = INVALID_HANDLE_VALUE;
+#else
+  fd[1] = -1;
+#endif
 
   ctx.fd = fd[0];
   ASSERT(0 == uv_barrier_init(&ctx.barrier, 2));
@@ -83,11 +102,20 @@ TEST_IMPL(pipe_set_non_blocking) {
   memset(data, '.', sizeof(data));
 
   nwritten = 0;
-  while (nwritten < 10 << 20) {
+  while (nwritten < NWRITES) {
     /* The stream is in blocking mode so uv_try_write() should always succeed
      * with the exact number of bytes that we wanted written.
      */
     n = uv_try_write((uv_stream_t*) &pipe_handle, &buf, 1);
+#ifdef _WIN32
+    ASSERT(n == UV_EAGAIN); /* E_NOTIMPL */
+    ASSERT(0 == uv_write(&write_req, (uv_stream_t*) &pipe_handle, &buf, 1, write_cb));
+    ASSERT(write_req.handle != NULL);
+    ASSERT(1 == uv_run(uv_default_loop(), UV_RUN_ONCE)); /* queue write_cb */
+    ASSERT(0 == uv_run(uv_default_loop(), UV_RUN_ONCE)); /* process write_cb */
+    ASSERT(write_req.handle == NULL); /* check for signaled completion of write_cb */
+    n = buf.len;
+#endif
     ASSERT(n == sizeof(data));
     nwritten += n;
   }
@@ -96,12 +124,15 @@ TEST_IMPL(pipe_set_non_blocking) {
   ASSERT(0 == uv_run(uv_default_loop(), UV_RUN_DEFAULT));
 
   ASSERT(0 == uv_thread_join(&thread));
+#ifdef _WIN32
+  ASSERT(0 != CloseHandle(fd[0]));  /* fd[1] is closed by uv_close(). */
+  fd[0] = INVALID_HANDLE_VALUE;
+#else
   ASSERT(0 == close(fd[0]));  /* fd[1] is closed by uv_close(). */
   fd[0] = -1;
+#endif
   uv_barrier_destroy(&ctx.barrier);
 
   MAKE_VALGRIND_HAPPY();
   return 0;
 }
-
-#endif  /* !_WIN32 */
diff --git a/test/test-platform-output.c b/test/test-platform-output.c
index f547ddfd..de1d9127 100644
--- a/test/test-platform-output.c
+++ b/test/test-platform-output.c
@@ -155,6 +155,7 @@ TEST_IMPL(platform_output) {
   printf("  username: %s\n", pwd.username);
   printf("  shell: %s\n", pwd.shell);
   printf("  home directory: %s\n", pwd.homedir);
+  printf("  gecos: %s\n", pwd.gecos);
 
   pid = uv_os_getpid();
   ASSERT(pid > 0);
diff --git a/test/test-poll-close-doesnt-corrupt-stack.c b/test/test-poll-close-doesnt-corrupt-stack.c
index 1d7e84f6..242845b1 100644
--- a/test/test-poll-close-doesnt-corrupt-stack.c
+++ b/test/test-poll-close-doesnt-corrupt-stack.c
@@ -94,7 +94,7 @@ TEST_IMPL(poll_close_doesnt_corrupt_stack) {
   ASSERT(r != 0);
   ASSERT(WSAGetLastError() == WSAEWOULDBLOCK);
 
-  r = uv_poll_init_socket(uv_default_loop(), &handle, sock);
+  r = uv_poll_init(uv_default_loop(), &handle, sock);
   ASSERT(r == 0);
   r = uv_poll_start(&handle, UV_READABLE | UV_WRITABLE, poll_cb);
   ASSERT(r == 0);
diff --git a/test/test-poll-close.c b/test/test-poll-close.c
index 2eccddf5..50c8d55a 100644
--- a/test/test-poll-close.c
+++ b/test/test-poll-close.c
@@ -56,7 +56,7 @@ TEST_IMPL(poll_close) {
 
   for (i = 0; i < NUM_SOCKETS; i++) {
     sockets[i] = socket(AF_INET, SOCK_STREAM, 0);
-    uv_poll_init_socket(uv_default_loop(), &poll_handles[i], sockets[i]);
+    uv_poll_init(uv_default_loop(), &poll_handles[i], sockets[i]);
     uv_poll_start(&poll_handles[i], UV_READABLE | UV_WRITABLE, NULL);
   }
 
diff --git a/test/test-poll-closesocket.c b/test/test-poll-closesocket.c
index 1a1c3641..4fd71dc4 100644
--- a/test/test-poll-closesocket.c
+++ b/test/test-poll-closesocket.c
@@ -77,7 +77,7 @@ TEST_IMPL(poll_closesocket) {
   ASSERT(r != 0);
   ASSERT(WSAGetLastError() == WSAEWOULDBLOCK);
 
-  r = uv_poll_init_socket(uv_default_loop(), &handle, sock);
+  r = uv_poll_init(uv_default_loop(), &handle, sock);
   ASSERT(r == 0);
   r = uv_poll_start(&handle, UV_WRITABLE, poll_cb);
   ASSERT(r == 0);
diff --git a/test/test-poll-oob.c b/test/test-poll-oob.c
index 77ffe31e..e4edd9e6 100644
--- a/test/test-poll-oob.c
+++ b/test/test-poll-oob.c
@@ -138,8 +138,8 @@ static void connection_cb(uv_stream_t* handle, int status) {
   ASSERT(0 == status);
   ASSERT(0 == uv_accept(handle, (uv_stream_t*) &peer_handle));
   ASSERT(0 == uv_fileno((uv_handle_t*) &peer_handle, &server_fd));
-  ASSERT(0 == uv_poll_init_socket(uv_default_loop(), &poll_req[0], client_fd));
-  ASSERT(0 == uv_poll_init_socket(uv_default_loop(), &poll_req[1], server_fd));
+  ASSERT(0 == uv_poll_init(uv_default_loop(), &poll_req[0], client_fd));
+  ASSERT(0 == uv_poll_init(uv_default_loop(), &poll_req[1], server_fd));
   ASSERT(0 == uv_poll_start(&poll_req[0],
                             UV_PRIORITIZED | UV_READABLE | UV_WRITABLE,
                             poll_cb));
diff --git a/test/test-poll.c b/test/test-poll.c
index edd75d38..efff0d33 100644
--- a/test/test-poll.c
+++ b/test/test-poll.c
@@ -160,7 +160,7 @@ static connection_context_t* create_connection_context(
   context->sent_fin = 0;
   context->got_disconnect = 0;
 
-  r = uv_poll_init_socket(uv_default_loop(), &context->poll_handle, sock);
+  r = uv_poll_init(uv_default_loop(), &context->poll_handle, sock);
   context->open_handles++;
   context->poll_handle.data = context;
   ASSERT(r == 0);
@@ -469,7 +469,7 @@ static server_context_t* create_server_context(
   context->sock = sock;
   context->connections = 0;
 
-  r = uv_poll_init_socket(uv_default_loop(), &context->poll_handle, sock);
+  r = uv_poll_init(uv_default_loop(), &context->poll_handle, sock);
   context->poll_handle.data = context;
   ASSERT(r == 0);
 
@@ -635,6 +635,7 @@ TEST_IMPL(poll_bad_fdtype) {
     !defined(__OpenBSD__) && !defined(__CYGWIN__) && !defined(__MSYS__) && \
     !defined(__NetBSD__)
   uv_poll_t poll_handle;
+  uv_os_fd_t handle;
   int fd;
 
 #if defined(_WIN32)
@@ -643,7 +644,8 @@ TEST_IMPL(poll_bad_fdtype) {
   fd = open(".", O_RDONLY);
 #endif
   ASSERT(fd != -1);
-  ASSERT(0 != uv_poll_init(uv_default_loop(), &poll_handle, fd));
+  handle = uv_get_osfhandle(fd);
+  ASSERT(0 != uv_poll_init(uv_default_loop(), &poll_handle, (uv_os_sock_t)handle)); /* bad cast on windows to allow passing an invalid SOCKET */
   ASSERT(0 == close(fd));
 #endif
 
diff --git a/test/test-signal.c b/test/test-signal.c
index c2ce5ec0..3203c708 100644
--- a/test/test-signal.c
+++ b/test/test-signal.c
@@ -19,6 +19,8 @@
  * IN THE SOFTWARE.
  */
 
+#include <signal.h>
+
 #include "uv.h"
 #include "task.h"
 
@@ -44,6 +46,8 @@ TEST_IMPL(kill_invalid_signum) {
 
 /* For Windows we test only signum handling */
 #ifdef _WIN32
+#define NSIG 32
+
 static void signum_test_cb(uv_signal_t* handle, int signum) {
   FATAL("signum_test_cb should not be called");
 }
diff --git a/test/test-spawn.c b/test/test-spawn.c
index d1757337..9690dea4 100644
--- a/test/test-spawn.c
+++ b/test/test-spawn.c
@@ -29,14 +29,18 @@
 #include <string.h>
 
 #ifdef _WIN32
-# if defined(__MINGW32__)
-#  include <basetyps.h>
-# endif
 # include <shellapi.h>
 # include <wchar.h>
+  typedef BOOL (WINAPI *sCompareObjectHandles)(_In_ HANDLE, _In_ HANDLE);
 #else
 # include <unistd.h>
 # include <sys/wait.h>
+# include <sched.h>
+# if defined(__FreeBSD__)
+#  include <sys/param.h>
+#  include <sys/cpuset.h>
+#  include <pthread_np.h>
+# endif
 #endif
 
 
@@ -49,9 +53,7 @@ static char exepath[1024];
 static size_t exepath_size = 1024;
 static char* args[5];
 static int no_term_signal;
-#ifndef _WIN32
 static int timer_counter;
-#endif
 static uv_tcp_t tcp_server;
 
 #define OUTPUT_SIZE 1024
@@ -85,8 +87,6 @@ static void fail_cb(uv_process_t* process,
 static void kill_cb(uv_process_t* process,
                     int64_t exit_status,
                     int term_signal) {
-  int err;
-
   printf("exit_cb\n");
   exit_cb_called++;
 #ifdef _WIN32
@@ -107,12 +107,9 @@ static void kill_cb(uv_process_t* process,
   uv_close((uv_handle_t*) process, close_cb);
 
   /*
-   * Sending signum == 0 should check if the
-   * child process is still alive, not kill it.
    * This process should be dead.
    */
-  err = uv_kill(process->pid, 0);
-  ASSERT(err == UV_ESRCH);
+  ASSERT(process->pid == 0);
 }
 
 static void detach_failure_cb(uv_process_t* process,
@@ -140,12 +137,10 @@ static void on_read(uv_stream_t* tcp, ssize_t nread, const uv_buf_t* buf) {
 }
 
 
-#ifndef _WIN32
 static void on_read_once(uv_stream_t* tcp, ssize_t nread, const uv_buf_t* buf) {
   uv_read_stop(tcp);
   on_read(tcp, nread, buf);
 }
-#endif
 
 
 static void write_cb(uv_write_t* req, int status) {
@@ -154,6 +149,11 @@ static void write_cb(uv_write_t* req, int status) {
 }
 
 
+static void write_null_cb(uv_write_t* req, int status) {
+  ASSERT(status == 0);
+}
+
+
 static void init_process_options(char* test, uv_exit_cb exit_cb) {
   /* Note spawn_helper1 defined in test/run-tests.c */
   int r = uv_exepath(exepath, &exepath_size);
@@ -177,11 +177,9 @@ static void timer_cb(uv_timer_t* handle) {
 }
 
 
-#ifndef _WIN32
 static void timer_counter_cb(uv_timer_t* handle) {
   ++timer_counter;
 }
-#endif
 
 
 TEST_IMPL(spawn_fails) {
@@ -204,25 +202,16 @@ TEST_IMPL(spawn_fails) {
 #ifndef _WIN32
 TEST_IMPL(spawn_fails_check_for_waitpid_cleanup) {
   int r;
-  int status;
-  int err;
 
   init_process_options("", fail_cb);
   options.file = options.args[0] = "program-that-had-better-not-exist";
 
   r = uv_spawn(uv_default_loop(), &process, &options);
+  ASSERT(process.pid == 0);
   ASSERT(r == UV_ENOENT || r == UV_EACCES);
   ASSERT(0 == uv_is_active((uv_handle_t*) &process));
   ASSERT(0 == uv_run(uv_default_loop(), UV_RUN_DEFAULT));
 
-  /* verify the child is successfully cleaned up within libuv */
-  do
-    err = waitpid(process.pid, &status, 0);
-  while (err == -1 && errno == EINTR);
-
-  ASSERT(err == -1);
-  ASSERT(errno == ECHILD);
-
   uv_close((uv_handle_t*) &process, NULL);
   ASSERT(0 == uv_run(uv_default_loop(), UV_RUN_DEFAULT));
 
@@ -315,7 +304,7 @@ TEST_IMPL(spawn_stdout) {
 
 TEST_IMPL(spawn_stdout_to_file) {
   int r;
-  uv_file file;
+  uv_os_fd_t file;
   uv_fs_t fs_req;
   uv_stdio_container_t stdio[2];
   uv_buf_t buf;
@@ -327,15 +316,14 @@ TEST_IMPL(spawn_stdout_to_file) {
 
   r = uv_fs_open(NULL, &fs_req, "stdout_file", O_CREAT | O_RDWR,
       S_IRUSR | S_IWUSR, NULL);
-  ASSERT(r != -1);
+  ASSERT(r == 0);
+  file = (uv_os_fd_t)fs_req.result;
   uv_fs_req_cleanup(&fs_req);
 
-  file = r;
-
   options.stdio = stdio;
   options.stdio[0].flags = UV_IGNORE;
   options.stdio[1].flags = UV_INHERIT_FD;
-  options.stdio[1].data.fd = file;
+  options.stdio[1].data.file = file;
   options.stdio_count = 2;
 
   r = uv_spawn(uv_default_loop(), &process, &options);
@@ -369,7 +357,7 @@ TEST_IMPL(spawn_stdout_to_file) {
 
 TEST_IMPL(spawn_stdout_and_stderr_to_file) {
   int r;
-  uv_file file;
+  uv_os_fd_t file;
   uv_fs_t fs_req;
   uv_stdio_container_t stdio[3];
   uv_buf_t buf;
@@ -381,17 +369,16 @@ TEST_IMPL(spawn_stdout_and_stderr_to_file) {
 
   r = uv_fs_open(NULL, &fs_req, "stdout_file", O_CREAT | O_RDWR,
       S_IRUSR | S_IWUSR, NULL);
-  ASSERT(r != -1);
+  ASSERT(r == 0);
+  file = (uv_os_fd_t)fs_req.result;
   uv_fs_req_cleanup(&fs_req);
 
-  file = r;
-
   options.stdio = stdio;
   options.stdio[0].flags = UV_IGNORE;
   options.stdio[1].flags = UV_INHERIT_FD;
-  options.stdio[1].data.fd = file;
+  options.stdio[1].data.file = file;
   options.stdio[2].flags = UV_INHERIT_FD;
-  options.stdio[2].data.fd = file;
+  options.stdio[2].data.file = file;
   options.stdio_count = 3;
 
   r = uv_spawn(uv_default_loop(), &process, &options);
@@ -426,7 +413,7 @@ TEST_IMPL(spawn_stdout_and_stderr_to_file) {
 TEST_IMPL(spawn_stdout_and_stderr_to_file2) {
 #ifndef _WIN32
   int r;
-  uv_file file;
+  uv_os_fd_t file;
   uv_fs_t fs_req;
   uv_stdio_container_t stdio[3];
   uv_buf_t buf;
@@ -443,17 +430,18 @@ TEST_IMPL(spawn_stdout_and_stderr_to_file2) {
                  O_CREAT | O_RDWR,
                  S_IRUSR | S_IWUSR,
                  NULL);
-  ASSERT(r != -1);
+  ASSERT(r == 0);
+  file = (uv_os_fd_t)fs_req.result;
   uv_fs_req_cleanup(&fs_req);
-  file = dup2(r, STDERR_FILENO);
+  file = dup2(file, STDERR_FILENO);
   ASSERT(file != -1);
 
   options.stdio = stdio;
   options.stdio[0].flags = UV_IGNORE;
   options.stdio[1].flags = UV_INHERIT_FD;
-  options.stdio[1].data.fd = file;
+  options.stdio[1].data.file = file;
   options.stdio[2].flags = UV_INHERIT_FD;
-  options.stdio[2].data.fd = file;
+  options.stdio[2].data.file = file;
   options.stdio_count = 3;
 
   r = uv_spawn(uv_default_loop(), &process, &options);
@@ -491,8 +479,8 @@ TEST_IMPL(spawn_stdout_and_stderr_to_file2) {
 TEST_IMPL(spawn_stdout_and_stderr_to_file_swap) {
 #ifndef _WIN32
   int r;
-  uv_file stdout_file;
-  uv_file stderr_file;
+  uv_os_fd_t stdout_file;
+  uv_os_fd_t stderr_file;
   uv_fs_t fs_req;
   uv_stdio_container_t stdio[3];
   uv_buf_t buf;
@@ -510,17 +498,19 @@ TEST_IMPL(spawn_stdout_and_stderr_to_file_swap) {
                  O_CREAT | O_RDWR,
                  S_IRUSR | S_IWUSR,
                  NULL);
-  ASSERT(r != -1);
+  ASSERT(r == 0);
+  stdout_file = (uv_os_fd_t)fs_req.result;
   uv_fs_req_cleanup(&fs_req);
-  stdout_file = dup2(r, STDOUT_FILENO);
+  stdout_file = dup2(stdout_file, STDOUT_FILENO);
   ASSERT(stdout_file != -1);
 
   /* open 'stderr_file' and replace STDERR_FILENO with it */
   r = uv_fs_open(NULL, &fs_req, "stderr_file", O_CREAT | O_RDWR,
       S_IRUSR | S_IWUSR, NULL);
-  ASSERT(r != -1);
+  ASSERT(r == 0);
+  stderr_file = (uv_os_fd_t)fs_req.result;
   uv_fs_req_cleanup(&fs_req);
-  stderr_file = dup2(r, STDERR_FILENO);
+  stderr_file = dup2(stderr_file, STDERR_FILENO);
   ASSERT(stderr_file != -1);
 
   /* now we're going to swap them: the child process' stdout will be our
@@ -528,9 +518,9 @@ TEST_IMPL(spawn_stdout_and_stderr_to_file_swap) {
   options.stdio = stdio;
   options.stdio[0].flags = UV_IGNORE;
   options.stdio[1].flags = UV_INHERIT_FD;
-  options.stdio[1].data.fd = stderr_file;
+  options.stdio[1].data.file = stderr_file;
   options.stdio[2].flags = UV_INHERIT_FD;
-  options.stdio[2].data.fd = stdout_file;
+  options.stdio[2].data.file = stdout_file;
   options.stdio_count = 3;
 
   r = uv_spawn(uv_default_loop(), &process, &options);
@@ -687,39 +677,29 @@ int spawn_tcp_server_helper(void) {
 TEST_IMPL(spawn_tcp_server) {
   uv_stdio_container_t stdio[4];
   struct sockaddr_in addr;
-  int fd;
+  uv_os_fd_t fd;
   int r;
-#ifdef _WIN32
-  uv_os_fd_t handle;
-#endif
 
   init_process_options("spawn_tcp_server_helper", exit_cb);
 
   ASSERT(0 == uv_ip4_addr("127.0.0.1", TEST_PORT, &addr));
 
-  fd = -1;
   r = uv_tcp_init_ex(uv_default_loop(), &tcp_server, AF_INET);
   ASSERT(r == 0);
   r = uv_tcp_bind(&tcp_server, (const struct sockaddr*) &addr, 0);
   ASSERT(r == 0);
-#ifdef _WIN32
-  r = uv_fileno((uv_handle_t*) &tcp_server, &handle);
-  fd = _open_osfhandle((intptr_t) handle, 0);
-#else
   r = uv_fileno((uv_handle_t*) &tcp_server, &fd);
- #endif
   ASSERT(r == 0);
-  ASSERT(fd > 0);
 
   options.stdio = stdio;
   options.stdio[0].flags = UV_INHERIT_FD;
-  options.stdio[0].data.fd = 0;
+  options.stdio[0].data.file = uv_get_osfhandle(0);
   options.stdio[1].flags = UV_INHERIT_FD;
-  options.stdio[1].data.fd = 1;
+  options.stdio[1].data.file = uv_get_osfhandle(1);
   options.stdio[2].flags = UV_INHERIT_FD;
-  options.stdio[2].data.fd = 2;
+  options.stdio[2].data.file = uv_get_osfhandle(2);
   options.stdio[3].flags = UV_INHERIT_FD;
-  options.stdio[3].data.fd = fd;
+  options.stdio[3].data.file = fd;
   options.stdio_count = 4;
 
   r = uv_spawn(uv_default_loop(), &process, &options);
@@ -1328,11 +1308,8 @@ TEST_IMPL(environment_creation) {
         found = 1;
       }
     }
-    if (prev) { /* verify sort order -- requires Vista */
-#if _WIN32_WINNT >= 0x0600 && \
-    (!defined(__MINGW32__) || defined(__MINGW64_VERSION_MAJOR))
+    if (prev) { /* verify sort order  */
       ASSERT(CompareStringOrdinal(prev, -1, str, -1, TRUE) == 1);
-#endif
     }
     ASSERT(found); /* verify that we expected this variable */
   }
@@ -1513,6 +1490,109 @@ TEST_IMPL(spawn_setgid_fails) {
 }
 #endif
 
+TEST_IMPL(spawn_affinity) {
+#if defined(NO_CPU_AFFINITY)
+  RETURN_SKIP(NO_CPU_AFFINITY);
+#else
+  int i;
+  int r;
+  int cpu;
+  char cpustr[11];
+  char* newmask;
+  int cpumask_size;
+#if defined(_WIN32)
+  DWORD_PTR procmask;
+  DWORD_PTR sysmask;
+#elif defined(__linux__)
+  cpu_set_t cpuset;
+#else
+  cpuset_t cpuset;
+#endif
+
+  cpumask_size = uv_cpumask_size();
+  ASSERT(cpumask_size > 0);
+
+  /* find a cpu we can use */
+  cpu = cpumask_size;
+#ifdef _WIN32
+  r = GetProcessAffinityMask(GetCurrentProcess(), &procmask, &sysmask);
+  ASSERT(r != 0);
+  for (i = 0; i < cpumask_size; ++i) {
+    if (procmask & (((DWORD_PTR)1) << i)) {
+      cpu = i;
+      break;
+    }
+  }
+#else
+  CPU_ZERO(&cpuset);
+  r = pthread_getaffinity_np(pthread_self(), sizeof(cpuset), &cpuset);
+  ASSERT(r == 0);
+  for (i = 0; i < cpumask_size; ++i) {
+    if (CPU_ISSET(i, &cpuset)) {
+      cpu = i;
+      break;
+    }
+  }
+#endif
+  ASSERT(cpu < cpumask_size);
+  snprintf(cpustr, sizeof(cpustr), "%d", cpu);
+
+  init_process_options("spawn_helper_affinity", exit_cb);
+
+  /* mask the child to just one cpu */
+  newmask = (char*)calloc(cpumask_size, 1);
+  ASSERT(newmask != NULL);
+  newmask[cpu] = 1;
+  options.cpumask_size = (size_t)cpumask_size;
+  options.cpumask = newmask;
+
+  /* tell the child which one it should get */
+  options.args[2] = cpustr;
+  options.args[3] = "dummy"; /* need 4 args for test/run-tests.c dispatch */
+
+  r = uv_spawn(uv_default_loop(), &process, &options);
+  ASSERT(r == 0);
+
+  r = uv_run(uv_default_loop(), UV_RUN_DEFAULT);
+  ASSERT(r == 0);
+
+  ASSERT(exit_cb_called == 1);
+  ASSERT(close_cb_called == 1);
+
+  free(newmask);
+
+  MAKE_VALGRIND_HAPPY();
+  return 0;
+#endif
+}
+
+TEST_IMPL(spawn_affinity_invalid_mask) {
+#if defined(NO_CPU_AFFINITY)
+  RETURN_SKIP(NO_CPU_AFFINITY);
+#else
+  int r;
+  char newmask[1];
+  int cpumask_size;
+
+  cpumask_size = uv_cpumask_size();
+  ASSERT(cpumask_size > 0);
+
+  init_process_options("", exit_cb);
+
+  /* provide a mask that is too small */
+  newmask[0] = 0;
+  options.cpumask_size = 0;
+  options.cpumask = newmask;
+
+  r = uv_spawn(uv_default_loop(), &process, &options);
+  ASSERT(r == UV_EINVAL);
+
+  ASSERT(exit_cb_called == 0);
+
+  MAKE_VALGRIND_HAPPY();
+  return 0;
+#endif
+}
 
 #ifdef _WIN32
 
@@ -1579,18 +1659,27 @@ TEST_IMPL(spawn_auto_unref) {
 }
 
 
-#ifndef _WIN32
 TEST_IMPL(spawn_fs_open) {
-  int fd;
+  int r;
+  uv_os_fd_t fd;
+  uv_os_fd_t dup_fd;
   uv_fs_t fs_req;
   uv_pipe_t in;
   uv_write_t write_req;
+  uv_write_t write_req2;
   uv_buf_t buf;
   uv_stdio_container_t stdio[1];
+#ifdef _WIN32
+  const char dev_null[] = "NUL";
+  HMODULE kernelbase_module;
+  sCompareObjectHandles pCompareObjectHandles; /* function introduced in Windows 10 */
+#else
+  const char dev_null[] = "/dev/null";
+#endif
 
-  fd = uv_fs_open(NULL, &fs_req, "/dev/null", O_RDWR, 0, NULL);
-  ASSERT(fd >= 0);
-  uv_fs_req_cleanup(&fs_req);
+  r = uv_fs_open(NULL, &fs_req, dev_null, O_RDWR, 0, NULL);
+  ASSERT(r == 0);
+  fd = (uv_os_fd_t) fs_req.result;
 
   init_process_options("spawn_helper8", exit_cb);
 
@@ -1601,13 +1690,28 @@ TEST_IMPL(spawn_fs_open) {
   options.stdio[0].data.stream = (uv_stream_t*) &in;
   options.stdio_count = 1;
 
+  /* make an inheritable copy */
+#ifdef _WIN32
+  ASSERT(0 != DuplicateHandle(GetCurrentProcess(), fd, GetCurrentProcess(), &dup_fd,
+                              0, /* inherit */ TRUE, DUPLICATE_SAME_ACCESS));
+  kernelbase_module = GetModuleHandleA("kernelbase.dll");
+  pCompareObjectHandles = (sCompareObjectHandles)
+      GetProcAddress(kernelbase_module, "CompareObjectHandles");
+  ASSERT(pCompareObjectHandles(fd, dup_fd));
+#else
+  dup_fd = dup(fd);
+#endif
+
   ASSERT(0 == uv_spawn(uv_default_loop(), &process, &options));
 
   buf = uv_buf_init((char*) &fd, sizeof(fd));
-  ASSERT(0 == uv_write(&write_req, (uv_stream_t*) &in, &buf, 1, write_cb));
+  ASSERT(0 == uv_write(&write_req, (uv_stream_t*) &in, &buf, 1, write_null_cb));
+
+  buf = uv_buf_init((char*) &dup_fd, sizeof(fd));
+  ASSERT(0 == uv_write(&write_req2, (uv_stream_t*) &in, &buf, 1, write_cb));
 
   ASSERT(0 == uv_run(uv_default_loop(), UV_RUN_DEFAULT));
-  ASSERT(0 == uv_fs_close(NULL, &fs_req, fd, NULL));
+  ASSERT(0 == uv_fs_close(NULL, &fs_req, r, NULL));
 
   ASSERT(exit_cb_called == 1);
   ASSERT(close_cb_called == 2);  /* One for `in`, one for process */
@@ -1615,24 +1719,25 @@ TEST_IMPL(spawn_fs_open) {
   MAKE_VALGRIND_HAPPY();
   return 0;
 }
-#endif  /* !_WIN32 */
 
 
-#ifndef _WIN32
 TEST_IMPL(closed_fd_events) {
   uv_stdio_container_t stdio[3];
   uv_pipe_t pipe_handle;
-  int fd[2];
+  uv_fs_t req;
+  uv_buf_t bufs[1];
+  uv_os_fd_t fd[2];
+  bufs[0] = uv_buf_init("", 1);
 
   /* create a pipe and share it with a child process */
-  ASSERT(0 == pipe(fd));
+  ASSERT(0 == uv_pipe(fd, 0, 0));
 
   /* spawn_helper4 blocks indefinitely. */
   init_process_options("spawn_helper4", exit_cb);
   options.stdio_count = 3;
   options.stdio = stdio;
   options.stdio[0].flags = UV_INHERIT_FD;
-  options.stdio[0].data.fd = fd[0];
+  options.stdio[0].data.file = fd[0];
   options.stdio[1].flags = UV_IGNORE;
   options.stdio[2].flags = UV_IGNORE;
 
@@ -1642,12 +1747,22 @@ TEST_IMPL(closed_fd_events) {
   /* read from the pipe with uv */
   ASSERT(0 == uv_pipe_init(uv_default_loop(), &pipe_handle, 0));
   ASSERT(0 == uv_pipe_open(&pipe_handle, fd[0]));
+  /* uv_pipe_open() takes ownership of the file descriptor. */
+#ifdef _WIN32
+  fd[0] = INVALID_HANDLE_VALUE;
+#else
   fd[0] = -1;
+#endif
 
   ASSERT(0 == uv_read_start((uv_stream_t*) &pipe_handle, on_alloc, on_read_once));
 
-  ASSERT(1 == write(fd[1], "", 1));
+  ASSERT(1 == uv_fs_write(NULL, &req, fd[1], bufs, 1, -1, NULL));
+  ASSERT(req.result == 1);
+  uv_fs_req_cleanup(&req);
 
+#ifdef _WIN32
+  ASSERT(1 == uv_run(uv_default_loop(), UV_RUN_ONCE));
+#endif
   ASSERT(0 == uv_run(uv_default_loop(), UV_RUN_ONCE));
 
   /* should have received just one byte */
@@ -1656,7 +1771,9 @@ TEST_IMPL(closed_fd_events) {
   /* close the pipe and see if we still get events */
   uv_close((uv_handle_t*) &pipe_handle, close_cb);
 
-  ASSERT(1 == write(fd[1], "", 1));
+  ASSERT(1 == uv_fs_write(NULL, &req, fd[1], bufs, 1, -1, NULL));
+  ASSERT(req.result == 1);
+  uv_fs_req_cleanup(&req);
 
   ASSERT(0 == uv_timer_init(uv_default_loop(), &timer));
   ASSERT(0 == uv_timer_start(&timer, timer_counter_cb, 10, 0));
@@ -1669,13 +1786,19 @@ TEST_IMPL(closed_fd_events) {
   ASSERT(timer_counter == 1);
 
   /* cleanup */
-  ASSERT(0 == uv_process_kill(&process, /* SIGTERM */ 15));
+  ASSERT(0 == uv_process_kill(&process, SIGTERM));
+#ifdef _WIN32
+  ASSERT(0 != CloseHandle(fd[1]));
+  fd[1] = INVALID_HANDLE_VALUE;
+#else
   ASSERT(0 == close(fd[1]));
+  fd[1] = -1;
+#endif
 
   MAKE_VALGRIND_HAPPY();
   return 0;
 }
-#endif  /* !_WIN32 */
+
 
 TEST_IMPL(spawn_reads_child_path) {
   int r;
@@ -1746,43 +1869,12 @@ TEST_IMPL(spawn_reads_child_path) {
   return 0;
 }
 
-#ifndef _WIN32
-static int mpipe(int *fds) {
-  if (pipe(fds) == -1)
-    return -1;
-  if (fcntl(fds[0], F_SETFD, FD_CLOEXEC) == -1 ||
-      fcntl(fds[1], F_SETFD, FD_CLOEXEC) == -1) {
-    close(fds[0]);
-    close(fds[1]);
-    return -1;
-  }
-  return 0;
-}
-#else
-static int mpipe(int *fds) {
-  SECURITY_ATTRIBUTES attr;
-  HANDLE readh, writeh;
-  attr.nLength = sizeof(attr);
-  attr.lpSecurityDescriptor = NULL;
-  attr.bInheritHandle = FALSE;
-  if (!CreatePipe(&readh, &writeh, &attr, 0))
-    return -1;
-  fds[0] = _open_osfhandle((intptr_t)readh, 0);
-  fds[1] = _open_osfhandle((intptr_t)writeh, 0);
-  if (fds[0] == -1 || fds[1] == -1) {
-    CloseHandle(readh);
-    CloseHandle(writeh);
-    return -1;
-  }
-  return 0;
-}
-#endif /* !_WIN32 */
 
 TEST_IMPL(spawn_inherit_streams) {
   uv_process_t child_req;
   uv_stdio_container_t child_stdio[2];
-  int fds_stdin[2];
-  int fds_stdout[2];
+  uv_os_fd_t fds_stdin[2];
+  uv_os_fd_t fds_stdout[2];
   uv_pipe_t pipe_stdin_child;
   uv_pipe_t pipe_stdout_child;
   uv_pipe_t pipe_stdin_parent;
@@ -1803,8 +1895,8 @@ TEST_IMPL(spawn_inherit_streams) {
   ASSERT(uv_pipe_init(loop, &pipe_stdin_parent, 0) == 0);
   ASSERT(uv_pipe_init(loop, &pipe_stdout_parent, 0) == 0);
 
-  ASSERT(mpipe(fds_stdin) != -1);
-  ASSERT(mpipe(fds_stdout) != -1);
+  ASSERT(uv_pipe(fds_stdin, 0, 0) == 0);
+  ASSERT(uv_pipe(fds_stdout, 0, 0) == 0);
 
   ASSERT(uv_pipe_open(&pipe_stdin_child, fds_stdin[0]) == 0);
   ASSERT(uv_pipe_open(&pipe_stdout_child, fds_stdout[1]) == 0);
diff --git a/test/test-stdio-over-pipes.c b/test/test-stdio-over-pipes.c
index 1aed4712..6042faf9 100644
--- a/test/test-stdio-over-pipes.c
+++ b/test/test-stdio-over-pipes.c
@@ -136,7 +136,7 @@ static void test_stdio_over_pipes(int overlapped) {
       (overlapped ? UV_OVERLAPPED_PIPE : 0);
   options.stdio[1].data.stream = (uv_stream_t*) &out;
   options.stdio[2].flags = UV_INHERIT_FD;
-  options.stdio[2].data.fd = 2;
+  options.stdio[2].data.file = uv_get_osfhandle(2);
   options.stdio_count = 3;
 
   r = uv_spawn(loop, &process, &options);
@@ -222,8 +222,8 @@ int stdio_over_pipes_helper(void) {
   int r;
   uv_loop_t* loop = uv_default_loop();
 
-  ASSERT(UV_NAMED_PIPE == uv_guess_handle(0));
-  ASSERT(UV_NAMED_PIPE == uv_guess_handle(1));
+  ASSERT(UV_NAMED_PIPE == uv_guess_handle(UV_STDIN_FD));
+  ASSERT(UV_NAMED_PIPE == uv_guess_handle(UV_STDOUT_FD));
 
   r = uv_pipe_init(loop, &stdin_pipe1, 0);
   ASSERT(r == 0);
@@ -234,10 +234,14 @@ int stdio_over_pipes_helper(void) {
   r = uv_pipe_init(loop, &stdout_pipe2, 0);
   ASSERT(r == 0);
 
-  uv_pipe_open(&stdin_pipe1, 0);
-  uv_pipe_open(&stdout_pipe1, 1);
-  uv_pipe_open(&stdin_pipe2, 0);
-  uv_pipe_open(&stdout_pipe2, 1);
+  r = uv_pipe_open(&stdin_pipe1, UV_STDIN_FD);
+  ASSERT(r == 0);
+  r = uv_pipe_open(&stdout_pipe1, UV_STDOUT_FD);
+  ASSERT(r == 0);
+  r = uv_pipe_open(&stdin_pipe2, UV_STDIN_FD);
+  ASSERT(r == 0);
+  r = uv_pipe_open(&stdout_pipe2, UV_STDOUT_FD);
+  ASSERT(r == 0);
 
   for (j = 0; j < 2; j++) {
     /* Unref both stdio handles to make sure that all writes complete. */
diff --git a/test/test-thread-affinity.c b/test/test-thread-affinity.c
new file mode 100644
index 00000000..43783bc4
--- /dev/null
+++ b/test/test-thread-affinity.c
@@ -0,0 +1,116 @@
+/* Copyright libuv project contributors. All rights reserved.
+ */
+
+#include "uv.h"
+#include "task.h"
+
+#include <string.h>
+
+#ifndef NO_CPU_AFFINITY
+
+static void check_affinity(void* arg) {
+  int r;
+  char* cpumask;
+  int cpumasksize;
+  uv_thread_t tid;
+
+  cpumask = (char*)arg;
+  cpumasksize = uv_cpumask_size();
+  ASSERT(cpumasksize > 0);
+  tid = uv_thread_self();
+  r = uv_thread_setaffinity(&tid, cpumask, NULL, cpumasksize);
+  ASSERT(r == 0);
+  r = uv_thread_setaffinity(&tid, cpumask + cpumasksize, cpumask, cpumasksize);
+  ASSERT(r == 0);
+}
+
+
+TEST_IMPL(thread_affinity) {
+  int t1first;
+  int t1second;
+  int t2first;
+  int t2second;
+  int cpumasksize;
+  char* cpumask;
+  int ncpus;
+  int r;
+  uv_thread_t threads[3];
+
+#ifdef _WIN32
+  /* uv_thread_self isn't defined for the main thread on Windows */
+  threads[0] = GetCurrentThread();
+#else
+  threads[0] = uv_thread_self();
+#endif
+  cpumasksize = uv_cpumask_size();
+  ASSERT(cpumasksize > 0);
+
+  cpumask = calloc(4 * cpumasksize, 1);
+  ASSERT(cpumask);
+
+  r = uv_thread_getaffinity(&threads[0], cpumask, cpumasksize);
+  ASSERT(r == 0);
+  ASSERT(cpumask[0] && "test must be run with cpu 0 affinity");
+  ncpus = 0;
+  while (cpumask[++ncpus]) { }
+  memset(cpumask, 0, 4 * cpumasksize);
+
+  t1first = cpumasksize * 0;
+  t1second = cpumasksize * 1;
+  t2first = cpumasksize * 2;
+  t2second = cpumasksize * 3;
+
+  cpumask[t1second + 0] = 1;
+  cpumask[t2first + 0] = 1;
+  cpumask[t1first + (ncpus >= 2)] = 1;
+  cpumask[t2second + (ncpus >= 2)] = 1;
+#ifdef __linux__
+  cpumask[t1second + 2] = 1;
+  cpumask[t2first + 2] = 1;
+  cpumask[t1first + 3] = 1;
+  cpumask[t2second + 3] = 1;
+#else
+  if (ncpus >= 3) {
+    cpumask[t1second + 2] = 1;
+    cpumask[t2first + 2] = 1;
+  }
+  if (ncpus >= 4) {
+    cpumask[t1first + 3] = 1;
+    cpumask[t2second + 3] = 1;
+  }
+#endif
+
+  ASSERT(0 == uv_thread_create(threads + 1,
+                               check_affinity,
+                               &cpumask[t1first]));
+  ASSERT(0 == uv_thread_create(threads + 2,
+                               check_affinity,
+                               &cpumask[t2first]));
+  ASSERT(0 == uv_thread_join(threads + 1));
+  ASSERT(0 == uv_thread_join(threads + 2));
+
+  ASSERT(cpumask[t1first + 0] == (ncpus == 1));
+  ASSERT(cpumask[t1first + 1] == (ncpus >= 2));
+  ASSERT(cpumask[t1first + 2] == 0);
+  ASSERT(cpumask[t1first + 3] == (ncpus >= 4));
+
+  ASSERT(cpumask[t2first + 0] == 1);
+  ASSERT(cpumask[t2first + 1] == 0);
+  ASSERT(cpumask[t2first + 2] == (ncpus >= 3));
+  ASSERT(cpumask[t2first + 3] == 0);
+
+  free(cpumask);
+
+  return 0;
+}
+
+#else
+
+TEST_IMPL(thread_affinity) {
+  int cpumasksize;
+  cpumasksize = uv_cpumask_size();
+  ASSERT(cpumasksize == UV_ENOTSUP);
+  return 0;
+}
+
+#endif
diff --git a/test/test-timer-again.c b/test/test-timer-again.c
index e87d2edf..78b1a097 100644
--- a/test/test-timer-again.c
+++ b/test/test-timer-again.c
@@ -112,6 +112,10 @@ TEST_IMPL(timer_again) {
   ASSERT(r == 0);
   ASSERT(uv_timer_get_repeat(&repeat_1) == 0);
 
+  /* Verify that it is not possible to uv_timer_again a non-repeating timer. */
+  r = uv_timer_again(&repeat_1);
+  ASSERT(r == UV_EINVAL);
+
   /* Actually make repeat_1 repeating. */
   uv_timer_set_repeat(&repeat_1, 50);
   ASSERT(uv_timer_get_repeat(&repeat_1) == 50);
diff --git a/test/test-tty-duplicate-key.c b/test/test-tty-duplicate-key.c
index 1ec2f369..8ec9ec3f 100644
--- a/test/test-tty-duplicate-key.c
+++ b/test/test-tty-duplicate-key.c
@@ -53,7 +53,7 @@ static void print_err_msg(const char* expect, ssize_t expect_len,
   fprintf(stderr, "\n");
 }
 
-static void tty_alloc(uv_handle_t* handle, size_t size, uv_buf_t* buf) {
+static void tty_alloc(uv_handle_t* ttyin_fd, size_t size, uv_buf_t* buf) {
   buf->base = malloc(size);
   ASSERT(buf->base != NULL);
   buf->len = size;
@@ -133,26 +133,23 @@ static void make_key_event_records(WORD virt_key, DWORD ctr_key_state,
 
 TEST_IMPL(tty_duplicate_vt100_fn_key) {
   int r;
-  int ttyin_fd;
+  uv_os_fd_t ttyin_fd;
   uv_tty_t tty_in;
   uv_loop_t* loop;
-  HANDLE handle;
   INPUT_RECORD records[2];
   DWORD written;
 
   loop = uv_default_loop();
 
   /* Make sure we have an FD that refers to a tty */
-  handle = CreateFileA("conin$",
-                       GENERIC_READ | GENERIC_WRITE,
-                       FILE_SHARE_READ | FILE_SHARE_WRITE,
-                       NULL,
-                       OPEN_EXISTING,
-                       FILE_ATTRIBUTE_NORMAL,
-                       NULL);
-  ASSERT(handle != INVALID_HANDLE_VALUE);
-  ttyin_fd = _open_osfhandle((intptr_t) handle, 0);
-  ASSERT(ttyin_fd >= 0);
+  ttyin_fd = CreateFileA("conin$",
+                         GENERIC_READ | GENERIC_WRITE,
+                         FILE_SHARE_READ | FILE_SHARE_WRITE,
+                         NULL,
+                         OPEN_EXISTING,
+                         FILE_ATTRIBUTE_NORMAL,
+                         NULL);
+  ASSERT(ttyin_fd != INVALID_HANDLE_VALUE);
   ASSERT(UV_TTY == uv_guess_handle(ttyin_fd));
 
   r = uv_tty_init(uv_default_loop(), &tty_in, ttyin_fd, 1);  /* Readable. */
@@ -175,7 +172,7 @@ TEST_IMPL(tty_duplicate_vt100_fn_key) {
    * duplicate.
    */
   make_key_event_records(VK_F1, 0, TRUE, records);
-  WriteConsoleInputW(handle, records, ARRAY_SIZE(records), &written);
+  WriteConsoleInputW(ttyin_fd, records, ARRAY_SIZE(records), &written);
   ASSERT(written == ARRAY_SIZE(records));
 
   uv_run(loop, UV_RUN_DEFAULT);
@@ -186,10 +183,9 @@ TEST_IMPL(tty_duplicate_vt100_fn_key) {
 
 TEST_IMPL(tty_duplicate_alt_modifier_key) {
   int r;
-  int ttyin_fd;
+  uv_os_fd_t ttyin_fd;
   uv_tty_t tty_in;
   uv_loop_t* loop;
-  HANDLE handle;
   INPUT_RECORD records[2];
   INPUT_RECORD alt_records[2];
   DWORD written;
@@ -197,16 +193,14 @@ TEST_IMPL(tty_duplicate_alt_modifier_key) {
   loop = uv_default_loop();
 
   /* Make sure we have an FD that refers to a tty */
-  handle = CreateFileA("conin$",
-                       GENERIC_READ | GENERIC_WRITE,
-                       FILE_SHARE_READ | FILE_SHARE_WRITE,
-                       NULL,
-                       OPEN_EXISTING,
-                       FILE_ATTRIBUTE_NORMAL,
-                       NULL);
-  ASSERT(handle != INVALID_HANDLE_VALUE);
-  ttyin_fd = _open_osfhandle((intptr_t) handle, 0);
-  ASSERT(ttyin_fd >= 0);
+  ttyin_fd = CreateFileA("conin$",
+                        GENERIC_READ | GENERIC_WRITE,
+                        FILE_SHARE_READ | FILE_SHARE_WRITE,
+                        NULL,
+                        OPEN_EXISTING,
+                        FILE_ATTRIBUTE_NORMAL,
+                        NULL);
+  ASSERT(ttyin_fd != INVALID_HANDLE_VALUE);
   ASSERT(UV_TTY == uv_guess_handle(ttyin_fd));
 
   r = uv_tty_init(uv_default_loop(), &tty_in, ttyin_fd, 1);  /* Readable. */
@@ -226,22 +220,22 @@ TEST_IMPL(tty_duplicate_alt_modifier_key) {
 
   /* Emulate transmission of M-a at normal console */
   make_key_event_records(VK_MENU, 0, TRUE, alt_records);
-  WriteConsoleInputW(handle, &alt_records[0], 1, &written);
+  WriteConsoleInputW(ttyin_fd, &alt_records[0], 1, &written);
   ASSERT(written == 1);
   make_key_event_records(L'A', LEFT_ALT_PRESSED, FALSE, records);
-  WriteConsoleInputW(handle, records, ARRAY_SIZE(records), &written);
+  WriteConsoleInputW(ttyin_fd, records, ARRAY_SIZE(records), &written);
   ASSERT(written == 2);
-  WriteConsoleInputW(handle, &alt_records[1], 1, &written);
+  WriteConsoleInputW(ttyin_fd, &alt_records[1], 1, &written);
   ASSERT(written == 1);
 
   /* Emulate transmission of M-a at WSL(#2111) */
   make_key_event_records(VK_MENU, 0, TRUE, alt_records);
-  WriteConsoleInputW(handle, &alt_records[0], 1, &written);
+  WriteConsoleInputW(ttyin_fd, &alt_records[0], 1, &written);
   ASSERT(written == 1);
   make_key_event_records(L'A', LEFT_ALT_PRESSED, TRUE, records);
-  WriteConsoleInputW(handle, records, ARRAY_SIZE(records), &written);
+  WriteConsoleInputW(ttyin_fd, records, ARRAY_SIZE(records), &written);
   ASSERT(written == 2);
-  WriteConsoleInputW(handle, &alt_records[1], 1, &written);
+  WriteConsoleInputW(ttyin_fd, &alt_records[1], 1, &written);
   ASSERT(written == 1);
 
   uv_run(loop, UV_RUN_DEFAULT);
@@ -252,10 +246,9 @@ TEST_IMPL(tty_duplicate_alt_modifier_key) {
 
 TEST_IMPL(tty_composing_character) {
   int r;
-  int ttyin_fd;
+  uv_os_fd_t ttyin_fd;
   uv_tty_t tty_in;
   uv_loop_t* loop;
-  HANDLE handle;
   INPUT_RECORD records[2];
   INPUT_RECORD alt_records[2];
   DWORD written;
@@ -263,16 +256,14 @@ TEST_IMPL(tty_composing_character) {
   loop = uv_default_loop();
 
   /* Make sure we have an FD that refers to a tty */
-  handle = CreateFileA("conin$",
-                       GENERIC_READ | GENERIC_WRITE,
-                       FILE_SHARE_READ | FILE_SHARE_WRITE,
-                       NULL,
-                       OPEN_EXISTING,
-                       FILE_ATTRIBUTE_NORMAL,
-                       NULL);
-  ASSERT(handle != INVALID_HANDLE_VALUE);
-  ttyin_fd = _open_osfhandle((intptr_t) handle, 0);
-  ASSERT(ttyin_fd >= 0);
+  ttyin_fd = CreateFileA("conin$",
+                         GENERIC_READ | GENERIC_WRITE,
+                         FILE_SHARE_READ | FILE_SHARE_WRITE,
+                         NULL,
+                         OPEN_EXISTING,
+                         FILE_ATTRIBUTE_NORMAL,
+                         NULL);
+  ASSERT(ttyin_fd != INVALID_HANDLE_VALUE);
   ASSERT(UV_TTY == uv_guess_handle(ttyin_fd));
 
   r = uv_tty_init(uv_default_loop(), &tty_in, ttyin_fd, 1);  /* Readable. */
@@ -293,20 +284,20 @@ TEST_IMPL(tty_composing_character) {
   /* Emulate EUR inputs by LEFT ALT+NUMPAD ASCII KeyComos */
   make_key_event_records(VK_MENU, 0, FALSE, alt_records);
   alt_records[1].Event.KeyEvent.uChar.UnicodeChar = EUR_UNICODE;
-  WriteConsoleInputW(handle, &alt_records[0], 1, &written);
+  WriteConsoleInputW(ttyin_fd, &alt_records[0], 1, &written);
   make_key_event_records(VK_NUMPAD0, LEFT_ALT_PRESSED, FALSE, records);
-  WriteConsoleInputW(handle, records, ARRAY_SIZE(records), &written);
+  WriteConsoleInputW(ttyin_fd, records, ARRAY_SIZE(records), &written);
   ASSERT(written == ARRAY_SIZE(records));
   make_key_event_records(VK_NUMPAD1, LEFT_ALT_PRESSED, FALSE, records);
-  WriteConsoleInputW(handle, records, ARRAY_SIZE(records), &written);
+  WriteConsoleInputW(ttyin_fd, records, ARRAY_SIZE(records), &written);
   ASSERT(written == ARRAY_SIZE(records));
   make_key_event_records(VK_NUMPAD2, LEFT_ALT_PRESSED, FALSE, records);
-  WriteConsoleInputW(handle, records, ARRAY_SIZE(records), &written);
+  WriteConsoleInputW(ttyin_fd, records, ARRAY_SIZE(records), &written);
   ASSERT(written == ARRAY_SIZE(records));
   make_key_event_records(VK_NUMPAD8, LEFT_ALT_PRESSED, FALSE, records);
-  WriteConsoleInputW(handle, records, ARRAY_SIZE(records), &written);
+  WriteConsoleInputW(ttyin_fd, records, ARRAY_SIZE(records), &written);
   ASSERT(written == ARRAY_SIZE(records));
-  WriteConsoleInputW(handle, &alt_records[1], 1, &written);
+  WriteConsoleInputW(ttyin_fd, &alt_records[1], 1, &written);
 
   uv_run(loop, UV_RUN_DEFAULT);
 
diff --git a/test/test-tty-escape-sequence-processing.c b/test/test-tty-escape-sequence-processing.c
index c4461e91..d7ac31ed 100644
--- a/test/test-tty-escape-sequence-processing.c
+++ b/test/test-tty-escape-sequence-processing.c
@@ -349,23 +349,19 @@ static BOOL compare_screen(uv_tty_t* tty_out,
 
 static void initialize_tty(uv_tty_t* tty_out) {
   int r;
-  int ttyout_fd;
   /* Make sure we have an FD that refers to a tty */
-  HANDLE handle;
+  HANDLE ttyout;
 
   uv_tty_set_vterm_state(UV_TTY_UNSUPPORTED);
 
-  handle = CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE,
+  ttyout = CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE,
                                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                                      NULL,
                                      CONSOLE_TEXTMODE_BUFFER,
                                      NULL);
-  ASSERT(handle != INVALID_HANDLE_VALUE);
-
-  ttyout_fd = _open_osfhandle((intptr_t) handle, 0);
-  ASSERT(ttyout_fd >= 0);
-  ASSERT(UV_TTY == uv_guess_handle(ttyout_fd));
-  r = uv_tty_init(uv_default_loop(), tty_out, ttyout_fd, 0); /* Writable. */
+  ASSERT(ttyout != INVALID_HANDLE_VALUE);
+  ASSERT(UV_TTY == uv_guess_handle(ttyout));
+  r = uv_tty_init(uv_default_loop(), tty_out, ttyout, 0); /* Writable. */
   ASSERT(r == 0);
 }
 
diff --git a/test/test-tty.c b/test/test-tty.c
index a9d38f22..5b9a7235 100644
--- a/test/test-tty.c
+++ b/test/test-tty.c
@@ -43,32 +43,29 @@
 
 TEST_IMPL(tty) {
   int r, width, height;
-  int ttyin_fd, ttyout_fd;
+  uv_os_fd_t ttyin_fd, ttyout_fd;
   uv_tty_t tty_in, tty_out;
   uv_loop_t* loop = uv_default_loop();
 
   /* Make sure we have an FD that refers to a tty */
 #ifdef _WIN32
-  HANDLE handle;
-  handle = CreateFileA("conin$",
-                       GENERIC_READ | GENERIC_WRITE,
-                       FILE_SHARE_READ | FILE_SHARE_WRITE,
-                       NULL,
-                       OPEN_EXISTING,
-                       FILE_ATTRIBUTE_NORMAL,
-                       NULL);
-  ASSERT(handle != INVALID_HANDLE_VALUE);
-  ttyin_fd = _open_osfhandle((intptr_t) handle, 0);
-
-  handle = CreateFileA("conout$",
-                       GENERIC_READ | GENERIC_WRITE,
-                       FILE_SHARE_READ | FILE_SHARE_WRITE,
-                       NULL,
-                       OPEN_EXISTING,
-                       FILE_ATTRIBUTE_NORMAL,
-                       NULL);
-  ASSERT(handle != INVALID_HANDLE_VALUE);
-  ttyout_fd = _open_osfhandle((intptr_t) handle, 0);
+  ttyin_fd = CreateFileA("conin$",
+                         GENERIC_READ | GENERIC_WRITE,
+                         FILE_SHARE_READ | FILE_SHARE_WRITE,
+                         NULL,
+                         OPEN_EXISTING,
+                         FILE_ATTRIBUTE_NORMAL,
+                         NULL);
+  ASSERT(ttyin_fd != INVALID_HANDLE_VALUE);
+
+  ttyout_fd = CreateFileA("conout$",
+                          GENERIC_READ | GENERIC_WRITE,
+                          FILE_SHARE_READ | FILE_SHARE_WRITE,
+                          NULL,
+                          OPEN_EXISTING,
+                          FILE_ATTRIBUTE_NORMAL,
+                          NULL);
+  ASSERT(ttyout_fd != INVALID_HANDLE_VALUE);
 
 #else /* unix */
   ttyin_fd = open("/dev/tty", O_RDONLY, 0);
@@ -84,12 +81,12 @@ TEST_IMPL(tty) {
     fflush(stderr);
     return TEST_SKIP;
   }
-#endif
 
   ASSERT(ttyin_fd >= 0);
   ASSERT(ttyout_fd >= 0);
+#endif
 
-  ASSERT(UV_UNKNOWN_HANDLE == uv_guess_handle(-1));
+  ASSERT(UV_UNKNOWN_HANDLE == uv_guess_handle((uv_os_fd_t)-1));
 
   ASSERT(UV_TTY == uv_guess_handle(ttyin_fd));
   ASSERT(UV_TTY == uv_guess_handle(ttyout_fd));
@@ -168,24 +165,21 @@ static void tty_raw_read(uv_stream_t* tty_in, ssize_t nread, const uv_buf_t* buf
 
 TEST_IMPL(tty_raw) {
   int r;
-  int ttyin_fd;
+  uv_os_fd_t ttyin_fd;
   uv_tty_t tty_in;
   uv_loop_t* loop = uv_default_loop();
-  HANDLE handle;
   INPUT_RECORD record;
   DWORD written;
 
   /* Make sure we have an FD that refers to a tty */
-  handle = CreateFileA("conin$",
-                       GENERIC_READ | GENERIC_WRITE,
-                       FILE_SHARE_READ | FILE_SHARE_WRITE,
-                       NULL,
-                       OPEN_EXISTING,
-                       FILE_ATTRIBUTE_NORMAL,
-                       NULL);
-  ASSERT(handle != INVALID_HANDLE_VALUE);
-  ttyin_fd = _open_osfhandle((intptr_t) handle, 0);
-  ASSERT(ttyin_fd >= 0);
+  ttyin_fd = CreateFileA("conin$",
+                         GENERIC_READ | GENERIC_WRITE,
+                         FILE_SHARE_READ | FILE_SHARE_WRITE,
+                         NULL,
+                         OPEN_EXISTING,
+                         FILE_ATTRIBUTE_NORMAL,
+                         NULL);
+  ASSERT(ttyin_fd != INVALID_HANDLE_VALUE);
   ASSERT(UV_TTY == uv_guess_handle(ttyin_fd));
 
   r = uv_tty_init(uv_default_loop(), &tty_in, ttyin_fd, 1);  /* Readable. */
@@ -211,7 +205,7 @@ TEST_IMPL(tty_raw) {
   record.Event.KeyEvent.wVirtualScanCode = MapVirtualKeyW(VK_SPACE, MAPVK_VK_TO_VSC);
   record.Event.KeyEvent.uChar.UnicodeChar = L' ';
   record.Event.KeyEvent.dwControlKeyState = 0;
-  WriteConsoleInputW(handle, &record, 1, &written);
+  WriteConsoleInputW(ttyin_fd, &record, 1, &written);
 
   uv_run(loop, UV_RUN_DEFAULT);
 
@@ -221,28 +215,23 @@ TEST_IMPL(tty_raw) {
 
 TEST_IMPL(tty_empty_write) {
   int r;
-  int ttyout_fd;
+  uv_os_fd_t ttyout_fd;
   uv_tty_t tty_out;
   char dummy[1];
   uv_buf_t bufs[1];
   uv_loop_t* loop;
 
-  /* Make sure we have an FD that refers to a tty */
-  HANDLE handle;
-
   loop = uv_default_loop();
 
-  handle = CreateFileA("conout$",
+  /* Make sure we have an FD that refers to a tty */
+  ttyout_fd = CreateFileA("conout$",
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
-  ASSERT(handle != INVALID_HANDLE_VALUE);
-  ttyout_fd = _open_osfhandle((intptr_t) handle, 0);
-
-  ASSERT(ttyout_fd >= 0);
+  ASSERT(ttyout_fd != INVALID_HANDLE_VALUE);
 
   ASSERT(UV_TTY == uv_guess_handle(ttyout_fd));
 
@@ -267,28 +256,23 @@ TEST_IMPL(tty_empty_write) {
 
 TEST_IMPL(tty_large_write) {
   int r;
-  int ttyout_fd;
+  uv_os_fd_t ttyout_fd;
   uv_tty_t tty_out;
   char dummy[10000];
   uv_buf_t bufs[1];
   uv_loop_t* loop;
 
-  /* Make sure we have an FD that refers to a tty */
-  HANDLE handle;
-
   loop = uv_default_loop();
 
-  handle = CreateFileA("conout$",
+  /* Make sure we have an FD that refers to a tty */
+  ttyout_fd = CreateFileA("conout$",
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
-  ASSERT(handle != INVALID_HANDLE_VALUE);
-  ttyout_fd = _open_osfhandle((intptr_t) handle, 0);
-
-  ASSERT(ttyout_fd >= 0);
+  ASSERT(ttyout_fd != INVALID_HANDLE_VALUE);
 
   ASSERT(UV_TTY == uv_guess_handle(ttyout_fd));
 
@@ -313,7 +297,6 @@ TEST_IMPL(tty_large_write) {
 
 TEST_IMPL(tty_raw_cancel) {
   int r;
-  int ttyin_fd;
   uv_tty_t tty_in;
   HANDLE handle;
 
@@ -326,11 +309,9 @@ TEST_IMPL(tty_raw_cancel) {
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
   ASSERT(handle != INVALID_HANDLE_VALUE);
-  ttyin_fd = _open_osfhandle((intptr_t) handle, 0);
-  ASSERT(ttyin_fd >= 0);
-  ASSERT(UV_TTY == uv_guess_handle(ttyin_fd));
+  ASSERT(UV_TTY == uv_guess_handle(handle));
 
-  r = uv_tty_init(uv_default_loop(), &tty_in, ttyin_fd, 1);  /* Readable. */
+  r = uv_tty_init(uv_default_loop(), &tty_in, handle, 1);  /* Readable. */
   ASSERT(r == 0);
   r = uv_tty_set_mode(&tty_in, UV_TTY_MODE_RAW);
   ASSERT(r == 0);
diff --git a/test/test-udp-multicast-interface6.c b/test/test-udp-multicast-interface6.c
index 23a68a00..0a486fcc 100644
--- a/test/test-udp-multicast-interface6.c
+++ b/test/test-udp-multicast-interface6.c
@@ -79,9 +79,19 @@ TEST_IMPL(udp_multicast_interface6) {
 
 #if defined(__APPLE__) || defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
   r = uv_udp_set_multicast_interface(&server, "::1%lo0");
+#elif defined(__MVS__)
+  r = uv_udp_set_multicast_interface(&server, "::1%LOOPBACK6");
 #else
   r = uv_udp_set_multicast_interface(&server, NULL);
 #endif
+
+#if defined(__MVS__)
+  if (r == UV_EADDRNOTAVAIL) {
+    MAKE_VALGRIND_HAPPY();
+    RETURN_SKIP("No ipv6 multicast route");
+  }
+#endif
+
   ASSERT(r == 0);
 
   /* server sends "PING" */
diff --git a/test/test-udp-multicast-join6.c b/test/test-udp-multicast-join6.c
index 40aa577d..cf3e76d2 100644
--- a/test/test-udp-multicast-join6.c
+++ b/test/test-udp-multicast-join6.c
@@ -32,12 +32,14 @@
 
 #if defined(__APPLE__)          || \
     defined(_AIX)               || \
-    defined(__MVS__)            || \
     defined(__FreeBSD_kernel__) || \
     defined(__NetBSD__)         || \
     defined(__OpenBSD__)
   #define MULTICAST_ADDR "ff02::1%lo0"
   #define INTERFACE_ADDR "::1%lo0"
+#elif defined(__MVS__)
+  #define MULTICAST_ADDR "ff02::1%LOOPBACK6"
+  #define INTERFACE_ADDR "::1%LOOPBACK6"
 #else
   #define MULTICAST_ADDR "ff02::1"
   #define INTERFACE_ADDR NULL
@@ -186,7 +188,12 @@ TEST_IMPL(udp_multicast_join6) {
   ASSERT(r == 0);
 
   r = uv_udp_set_membership(&server, MULTICAST_ADDR, INTERFACE_ADDR, UV_JOIN_GROUP);
+
+ #if defined(__MVS__)
+  if (r == UV_EADDRNOTAVAIL) {
+#else
   if (r == UV_ENODEV) {
+#endif
     MAKE_VALGRIND_HAPPY();
     RETURN_SKIP("No ipv6 multicast route");
   }
diff --git a/test/test-udp-open.c b/test/test-udp-open.c
index dee408ba..1b80bc26 100644
--- a/test/test-udp-open.c
+++ b/test/test-udp-open.c
@@ -299,6 +299,7 @@ TEST_IMPL(udp_open_connect) {
   return 0;
 }
 
+
 #ifndef _WIN32
 TEST_IMPL(udp_send_unix) {
   /* Test that "uv_udp_send()" supports sending over
